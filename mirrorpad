#!/usr/bin/env perl 

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Carp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP';
  package Carp;
  
  { use 5.006; }
  use strict;
  use warnings;
  BEGIN {
      # Very old versions of warnings.pm load Carp.  This can go wrong due
      # to the circular dependency.  If warnings is invoked before Carp,
      # then warnings starts by loading Carp, then Carp (above) tries to
      # invoke warnings, and gets nothing because warnings is in the process
      # of loading and hasn't defined its import method yet.  If we were
      # only turning on warnings ("use warnings" above) this wouldn't be too
      # bad, because Carp would just gets the state of the -w switch and so
      # might not get some warnings that it wanted.  The real problem is
      # that we then want to turn off Unicode warnings, but "no warnings
      # 'utf8'" won't be effective if we're in this circular-dependency
      # situation.  So, if warnings.pm is an affected version, we turn
      # off all warnings ourselves by directly setting ${^WARNING_BITS}.
      # On unaffected versions, we turn off just Unicode warnings, via
      # the proper API.
      if(!defined($warnings::VERSION) || eval($warnings::VERSION) < 1.06) {
  	${^WARNING_BITS} = "";
      } else {
  	"warnings"->unimport("utf8");
      }
  }
  
  sub _fetch_sub { # fetch sub without autovivifying
      my($pack, $sub) = @_;
      $pack .= '::';
      # only works with top-level packages
      return unless exists($::{$pack});
      for ($::{$pack}) {
  	return unless ref \$_ eq 'GLOB' && *$_{HASH} && exists $$_{$sub};
  	for ($$_{$sub}) {
  	    return ref \$_ eq 'GLOB' ? *$_{CODE} : undef
  	}
      }
  }
  
  # UTF8_REGEXP_PROBLEM is a compile-time constant indicating whether Carp
  # must avoid applying a regular expression to an upgraded (is_utf8)
  # string.  There are multiple problems, on different Perl versions,
  # that require this to be avoided.  All versions prior to 5.13.8 will
  # load utf8_heavy.pl for the swash system, even if the regexp doesn't
  # use character classes.  Perl 5.6 and Perls [5.11.2, 5.13.11) exhibit
  # specific problems when Carp is being invoked in the aftermath of a
  # syntax error.
  BEGIN {
      if("$]" < 5.013011) {
  	*UTF8_REGEXP_PROBLEM = sub () { 1 };
      } else {
  	*UTF8_REGEXP_PROBLEM = sub () { 0 };
      }
  }
  
  # is_utf8() is essentially the utf8::is_utf8() function, which indicates
  # whether a string is represented in the upgraded form (using UTF-8
  # internally).  As utf8::is_utf8() is only available from Perl 5.8
  # onwards, extra effort is required here to make it work on Perl 5.6.
  BEGIN {
      if(defined(my $sub = _fetch_sub utf8 => 'is_utf8')) {
  	*is_utf8 = $sub;
      } else {
  	# black magic for perl 5.6
  	*is_utf8 = sub { unpack("C", "\xaa".$_[0]) != 170 };
      }
  }
  
  # The downgrade() function defined here is to be used for attempts to
  # downgrade where it is acceptable to fail.  It must be called with a
  # second argument that is a true value.
  BEGIN {
      if(defined(my $sub = _fetch_sub utf8 => 'downgrade')) {
  	*downgrade = \&{"utf8::downgrade"};
      } else {
  	*downgrade = sub {
  	    my $r = "";
  	    my $l = length($_[0]);
  	    for(my $i = 0; $i != $l; $i++) {
  		my $o = ord(substr($_[0], $i, 1));
  		return if $o > 255;
  		$r .= chr($o);
  	    }
  	    $_[0] = $r;
  	};
      }
  }
  
  our $VERSION = '1.38';
  $VERSION =~ tr/_//d;
  
  our $MaxEvalLen = 0;
  our $Verbose    = 0;
  our $CarpLevel  = 0;
  our $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.
  our $MaxArgNums = 8;     # How many arguments to print. 0 = all.
  our $RefArgFormatter = undef; # allow caller to format reference arguments
  
  require Exporter;
  our @ISA       = ('Exporter');
  our @EXPORT    = qw(confess croak carp);
  our @EXPORT_OK = qw(cluck verbose longmess shortmess);
  our @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode
  
  # The members of %Internal are packages that are internal to perl.
  # Carp will not report errors from within these packages if it
  # can.  The members of %CarpInternal are internal to Perl's warning
  # system.  Carp will not report errors from within these packages
  # either, and will not report calls *to* these packages for carp and
  # croak.  They replace $CarpLevel, which is deprecated.    The
  # $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval
  # text and function arguments should be formatted when printed.
  
  our %CarpInternal;
  our %Internal;
  
  # disable these by default, so they can live w/o require Carp
  $CarpInternal{Carp}++;
  $CarpInternal{warnings}++;
  $Internal{Exporter}++;
  $Internal{'Exporter::Heavy'}++;
  
  # if the caller specifies verbose usage ("perl -MCarp=verbose script.pl")
  # then the following method will be called by the Exporter which knows
  # to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word
  # 'verbose'.
  
  sub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }
  
  sub _cgc {
      no strict 'refs';
      return \&{"CORE::GLOBAL::caller"} if defined &{"CORE::GLOBAL::caller"};
      return;
  }
  
  sub longmess {
      local($!, $^E);
      # Icky backwards compatibility wrapper. :-(
      #
      # The story is that the original implementation hard-coded the
      # number of call levels to go back, so calls to longmess were off
      # by one.  Other code began calling longmess and expecting this
      # behaviour, so the replacement has to emulate that behaviour.
      my $cgc = _cgc();
      my $call_pack = $cgc ? $cgc->() : caller();
      if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {
          return longmess_heavy(@_);
      }
      else {
          local $CarpLevel = $CarpLevel + 1;
          return longmess_heavy(@_);
      }
  }
  
  our @CARP_NOT;
  
  sub shortmess {
      local($!, $^E);
      my $cgc = _cgc();
  
      # Icky backwards compatibility wrapper. :-(
      local @CARP_NOT = $cgc ? $cgc->() : caller();
      shortmess_heavy(@_);
  }
  
  sub croak   { die shortmess @_ }
  sub confess { die longmess @_ }
  sub carp    { warn shortmess @_ }
  sub cluck   { warn longmess @_ }
  
  BEGIN {
      if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015) ||
  	    ("$]" >= 5.012005 && "$]" < 5.013)) {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };
      } else {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };
      }
  }
  
  sub caller_info {
      my $i = shift(@_) + 1;
      my %call_info;
      my $cgc = _cgc();
      {
  	# Some things override caller() but forget to implement the
  	# @DB::args part of it, which we need.  We check for this by
  	# pre-populating @DB::args with a sentinel which no-one else
  	# has the address of, so that we can detect whether @DB::args
  	# has been properly populated.  However, on earlier versions
  	# of perl this check tickles a bug in CORE::caller() which
  	# leaks memory.  So we only check on fixed perls.
          @DB::args = \$i if CALLER_OVERRIDE_CHECK_OK;
          package DB;
          @call_info{
              qw(pack file line sub has_args wantarray evaltext is_require) }
              = $cgc ? $cgc->($i) : caller($i);
      }
  
      unless ( defined $call_info{file} ) {
          return ();
      }
  
      my $sub_name = Carp::get_subname( \%call_info );
      if ( $call_info{has_args} ) {
          my @args;
          if (CALLER_OVERRIDE_CHECK_OK && @DB::args == 1
              && ref $DB::args[0] eq ref \$i
              && $DB::args[0] == \$i ) {
              @DB::args = ();    # Don't let anyone see the address of $i
              local $@;
              my $where = eval {
                  my $func    = $cgc or return '';
                  my $gv      =
                      (_fetch_sub B => 'svref_2object' or return '')
                          ->($func)->GV;
                  my $package = $gv->STASH->NAME;
                  my $subname = $gv->NAME;
                  return unless defined $package && defined $subname;
  
                  # returning CORE::GLOBAL::caller isn't useful for tracing the cause:
                  return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';
                  " in &${package}::$subname";
              } || '';
              @args
                  = "** Incomplete caller override detected$where; \@DB::args were not set **";
          }
          else {
              @args = @DB::args;
              my $overflow;
              if ( $MaxArgNums and @args > $MaxArgNums )
              {    # More than we want to show?
                  $#args = $MaxArgNums - 1;
                  $overflow = 1;
              }
  
              @args = map { Carp::format_arg($_) } @args;
  
              if ($overflow) {
                  push @args, '...';
              }
          }
  
          # Push the args onto the subroutine
          $sub_name .= '(' . join( ', ', @args ) . ')';
      }
      $call_info{sub_name} = $sub_name;
      return wantarray() ? %call_info : \%call_info;
  }
  
  # Transform an argument to a function into a string.
  our $in_recurse;
  sub format_arg {
      my $arg = shift;
  
      if ( ref($arg) ) {
           # legitimate, let's not leak it.
          if (!$in_recurse &&
  	    do {
                  local $@;
  	        local $in_recurse = 1;
  		local $SIG{__DIE__} = sub{};
                  eval {$arg->can('CARP_TRACE') }
              })
          {
              return $arg->CARP_TRACE();
          }
          elsif (!$in_recurse &&
  	       defined($RefArgFormatter) &&
  	       do {
                  local $@;
  	        local $in_recurse = 1;
  		local $SIG{__DIE__} = sub{};
                  eval {$arg = $RefArgFormatter->($arg); 1}
                  })
          {
              return $arg;
          }
          else
          {
  	    my $sub = _fetch_sub(overload => 'StrVal');
  	    return $sub ? &$sub($arg) : "$arg";
          }
      }
      return "undef" if !defined($arg);
      downgrade($arg, 1);
      return $arg if !(UTF8_REGEXP_PROBLEM && is_utf8($arg)) &&
  	    $arg =~ /\A-?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?\z/;
      my $suffix = "";
      if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
          substr ( $arg, $MaxArgLen - 3 ) = "";
  	$suffix = "...";
      }
      if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
  	for(my $i = length($arg); $i--; ) {
  	    my $c = substr($arg, $i, 1);
  	    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
  	    if($c eq "\"" || $c eq "\\" || $c eq "\$" || $c eq "\@") {
  		substr $arg, $i, 0, "\\";
  		next;
  	    }
  	    my $o = ord($c);
  
              # This code is repeated in Regexp::CARP_TRACE()
              if ($] ge 5.007_003) {
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
  		  if utf8::native_to_unicode($o) < utf8::native_to_unicode(0x20)
                    || utf8::native_to_unicode($o) > utf8::native_to_unicode(0x7e);
              } elsif (ord("A") == 65) {
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
                      if $o < 0x20 || $o > 0x7e;
              } else { # Early EBCDIC
  
                  # 3 EBCDIC code pages supported then;  all controls but one
                  # are the code points below SPACE.  The other one is 0x5F on
                  # POSIX-BC; FF on the other two.
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
                      if $o < ord(" ") || ((ord ("^") == 106)
                                            ? $o == 0x5f
                                            : $o == 0xff);
              }
  	}
      } else {
  	$arg =~ s/([\"\\\$\@])/\\$1/g;
          # This is all the ASCII printables spelled-out.  It is portable to all
          # Perl versions and platforms (such as EBCDIC).  There are other more
          # compact ways to do this, but may not work everywhere every version.
          $arg =~ s/([^ !"\$\%#'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg;
      }
      downgrade($arg, 1);
      return "\"".$arg."\"".$suffix;
  }
  
  sub Regexp::CARP_TRACE {
      my $arg = "$_[0]";
      downgrade($arg, 1);
      if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
  	for(my $i = length($arg); $i--; ) {
  	    my $o = ord(substr($arg, $i, 1));
  	    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
  
              # This code is repeated in format_arg()
              if ($] ge 5.007_003) {
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
  		  if utf8::native_to_unicode($o) < utf8::native_to_unicode(0x20)
                    || utf8::native_to_unicode($o) > utf8::native_to_unicode(0x7e);
              } elsif (ord("A") == 65) {
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
                      if $o < 0x20 || $o > 0x7e;
              } else { # Early EBCDIC
                  substr $arg, $i, 1, sprintf("\\x{%x}", $o)
                      if $o < ord(" ") || ((ord ("^") == 106)
                                            ? $o == 0x5f
                                            : $o == 0xff);
              }
  	}
      } else {
          # See comment in format_arg() about this same regex.
          $arg =~ s/([^ !"\$\%#'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg;
      }
      downgrade($arg, 1);
      my $suffix = "";
      if($arg =~ /\A\(\?\^?([a-z]*)(?:-[a-z]*)?:(.*)\)\z/s) {
  	($suffix, $arg) = ($1, $2);
      }
      if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
          substr ( $arg, $MaxArgLen - 3 ) = "";
  	$suffix = "...".$suffix;
      }
      return "qr($arg)$suffix";
  }
  
  # Takes an inheritance cache and a package and returns
  # an anon hash of known inheritances and anon array of
  # inheritances which consequences have not been figured
  # for.
  sub get_status {
      my $cache = shift;
      my $pkg   = shift;
      $cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];
      return @{ $cache->{$pkg} };
  }
  
  # Takes the info from caller() and figures out the name of
  # the sub/require/eval
  sub get_subname {
      my $info = shift;
      if ( defined( $info->{evaltext} ) ) {
          my $eval = $info->{evaltext};
          if ( $info->{is_require} ) {
              return "require $eval";
          }
          else {
              $eval =~ s/([\\\'])/\\$1/g;
              return "eval '" . str_len_trim( $eval, $MaxEvalLen ) . "'";
          }
      }
  
      # this can happen on older perls when the sub (or the stash containing it)
      # has been deleted
      if ( !defined( $info->{sub} ) ) {
          return '__ANON__::__ANON__';
      }
  
      return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};
  }
  
  # Figures out what call (from the point of view of the caller)
  # the long error backtrace should start at.
  sub long_error_loc {
      my $i;
      my $lvl = $CarpLevel;
      {
          ++$i;
          my $cgc = _cgc();
          my @caller = $cgc ? $cgc->($i) : caller($i);
          my $pkg = $caller[0];
          unless ( defined($pkg) ) {
  
              # This *shouldn't* happen.
              if (%Internal) {
                  local %Internal;
                  $i = long_error_loc();
                  last;
              }
              elsif (defined $caller[2]) {
                  # this can happen when the stash has been deleted
                  # in that case, just assume that it's a reasonable place to
                  # stop (the file and line data will still be intact in any
                  # case) - the only issue is that we can't detect if the
                  # deleted package was internal (so don't do that then)
                  # -doy
                  redo unless 0 > --$lvl;
                  last;
              }
              else {
                  return 2;
              }
          }
          redo if $CarpInternal{$pkg};
          redo unless 0 > --$lvl;
          redo if $Internal{$pkg};
      }
      return $i - 1;
  }
  
  sub longmess_heavy {
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = long_error_loc();
      return ret_backtrace( $i, @_ );
  }
  
  # Returns a full stack backtrace starting from where it is
  # told.
  sub ret_backtrace {
      my ( $i, @error ) = @_;
      my $mess;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      $mess = "$err at $i{file} line $i{line}$tid_msg";
      if( defined $. ) {
          local $@ = '';
          local $SIG{__DIE__};
          eval {
              CORE::die;
          };
          if($@ =~ /^Died at .*(, <.*?> line \d+).$/ ) {
              $mess .= $1;
          }
      }
      $mess .= "\.\n";
  
      while ( my %i = caller_info( ++$i ) ) {
          $mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n";
      }
  
      return $mess;
  }
  
  sub ret_summary {
      my ( $i, @error ) = @_;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      return "$err at $i{file} line $i{line}$tid_msg\.\n";
  }
  
  sub short_error_loc {
      # You have to create your (hash)ref out here, rather than defaulting it
      # inside trusts *on a lexical*, as you want it to persist across calls.
      # (You can default it on $_[2], but that gets messy)
      my $cache = {};
      my $i     = 1;
      my $lvl   = $CarpLevel;
      {
          my $cgc = _cgc();
          my $called = $cgc ? $cgc->($i) : caller($i);
          $i++;
          my $caller = $cgc ? $cgc->($i) : caller($i);
  
          if (!defined($caller)) {
              my @caller = $cgc ? $cgc->($i) : caller($i);
              if (@caller) {
                  # if there's no package but there is other caller info, then
                  # the package has been deleted - treat this as a valid package
                  # in this case
                  redo if defined($called) && $CarpInternal{$called};
                  redo unless 0 > --$lvl;
                  last;
              }
              else {
                  return 0;
              }
          }
          redo if $Internal{$caller};
          redo if $CarpInternal{$caller};
          redo if $CarpInternal{$called};
          redo if trusts( $called, $caller, $cache );
          redo if trusts( $caller, $called, $cache );
          redo unless 0 > --$lvl;
      }
      return $i - 1;
  }
  
  sub shortmess_heavy {
      return longmess_heavy(@_) if $Verbose;
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = short_error_loc();
      if ($i) {
          ret_summary( $i, @_ );
      }
      else {
          longmess_heavy(@_);
      }
  }
  
  # If a string is too long, trims it with ...
  sub str_len_trim {
      my $str = shift;
      my $max = shift || 0;
      if ( 2 < $max and $max < length($str) ) {
          substr( $str, $max - 3 ) = '...';
      }
      return $str;
  }
  
  # Takes two packages and an optional cache.  Says whether the
  # first inherits from the second.
  #
  # Recursive versions of this have to work to avoid certain
  # possible endless loops, and when following long chains of
  # inheritance are less efficient.
  sub trusts {
      my $child  = shift;
      my $parent = shift;
      my $cache  = shift;
      my ( $known, $partial ) = get_status( $cache, $child );
  
      # Figure out consequences until we have an answer
      while ( @$partial and not exists $known->{$parent} ) {
          my $anc = shift @$partial;
          next if exists $known->{$anc};
          $known->{$anc}++;
          my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );
          my @found = keys %$anc_knows;
          @$known{@found} = ();
          push @$partial, @$anc_partial;
      }
      return exists $known->{$parent};
  }
  
  # Takes a package and gives a list of those trusted directly
  sub trusts_directly {
      my $class = shift;
      no strict 'refs';
      my $stash = \%{"$class\::"};
      for my $var (qw/ CARP_NOT ISA /) {
          # Don't try using the variable until we know it exists,
          # to avoid polluting the caller's namespace.
          if ( $stash->{$var} && *{$stash->{$var}}{ARRAY} && @{$stash->{$var}} ) {
             return @{$stash->{$var}}
          }
      }
      return;
  }
  
  if(!defined($warnings::VERSION) ||
  	do { no warnings "numeric"; $warnings::VERSION < 1.03 }) {
      # Very old versions of warnings.pm import from Carp.  This can go
      # wrong due to the circular dependency.  If Carp is invoked before
      # warnings, then Carp starts by loading warnings, then warnings
      # tries to import from Carp, and gets nothing because Carp is in
      # the process of loading and hasn't defined its import method yet.
      # So we work around that by manually exporting to warnings here.
      no strict "refs";
      *{"warnings::$_"} = \&$_ foreach @EXPORT;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Carp - alternative warn and die for modules
  
  =head1 SYNOPSIS
  
      use Carp;
  
      # warn user (from perspective of caller)
      carp "string trimmed to 80 chars";
  
      # die of errors (from perspective of caller)
      croak "We're outta here!";
  
      # die of errors with stack backtrace
      confess "not implemented";
  
      # cluck, longmess and shortmess not exported by default
      use Carp qw(cluck longmess shortmess);
      cluck "This is how we got here!";
      $long_message   = longmess( "message from cluck() or confess()" );
      $short_message  = shortmess( "message from carp() or croak()" );
  
  =head1 DESCRIPTION
  
  The Carp routines are useful in your own modules because
  they act like C<die()> or C<warn()>, but with a message which is more
  likely to be useful to a user of your module.  In the case of
  C<cluck()> and C<confess()>, that context is a summary of every
  call in the call-stack; C<longmess()> returns the contents of the error
  message.
  
  For a shorter message you can use C<carp()> or C<croak()> which report the
  error as being from where your module was called.  C<shortmess()> returns the
  contents of this error message.  There is no guarantee that that is where the
  error was, but it is a good educated guess.
  
  C<Carp> takes care not to clobber the status variables C<$!> and C<$^E>
  in the course of assembling its error messages.  This means that a
  C<$SIG{__DIE__}> or C<$SIG{__WARN__}> handler can capture the error
  information held in those variables, if it is required to augment the
  error message, and if the code calling C<Carp> left useful values there.
  Of course, C<Carp> can't guarantee the latter.
  
  You can also alter the way the output and logic of C<Carp> works, by
  changing some global variables in the C<Carp> namespace. See the
  section on C<GLOBAL VARIABLES> below.
  
  Here is a more complete description of how C<carp> and C<croak> work.
  What they do is search the call-stack for a function call stack where
  they have not been told that there shouldn't be an error.  If every
  call is marked safe, they give up and give a full stack backtrace
  instead.  In other words they presume that the first likely looking
  potential suspect is guilty.  Their rules for telling whether
  a call shouldn't generate errors work as follows:
  
  =over 4
  
  =item 1.
  
  Any call from a package to itself is safe.
  
  =item 2.
  
  Packages claim that there won't be errors on calls to or from
  packages explicitly marked as safe by inclusion in C<@CARP_NOT>, or
  (if that array is empty) C<@ISA>.  The ability to override what
  @ISA says is new in 5.8.
  
  =item 3.
  
  The trust in item 2 is transitive.  If A trusts B, and B
  trusts C, then A trusts C.  So if you do not override C<@ISA>
  with C<@CARP_NOT>, then this trust relationship is identical to,
  "inherits from".
  
  =item 4.
  
  Any call from an internal Perl module is safe.  (Nothing keeps
  user modules from marking themselves as internal to Perl, but
  this practice is discouraged.)
  
  =item 5.
  
  Any call to Perl's warning system (eg Carp itself) is safe.
  (This rule is what keeps it from reporting the error at the
  point where you call C<carp> or C<croak>.)
  
  =item 6.
  
  C<$Carp::CarpLevel> can be set to skip a fixed number of additional
  call levels.  Using this is not recommended because it is very
  difficult to get it to behave correctly.
  
  =back
  
  =head2 Forcing a Stack Trace
  
  As a debugging aid, you can force Carp to treat a croak as a confess
  and a carp as a cluck across I<all> modules. In other words, force a
  detailed stack trace to be given.  This can be very helpful when trying
  to understand why, or from where, a warning or error is being generated.
  
  This feature is enabled by 'importing' the non-existent symbol
  'verbose'. You would typically enable it by saying
  
      perl -MCarp=verbose script.pl
  
  or by including the string C<-MCarp=verbose> in the PERL5OPT
  environment variable.
  
  Alternately, you can set the global variable C<$Carp::Verbose> to true.
  See the C<GLOBAL VARIABLES> section below.
  
  =head2 Stack Trace formatting
  
  At each stack level, the subroutine's name is displayed along with
  its parameters.  For simple scalars, this is sufficient.  For complex
  data types, such as objects and other references, this can simply
  display C<'HASH(0x1ab36d8)'>.
  
  Carp gives two ways to control this.
  
  =over 4
  
  =item 1.
  
  For objects, a method, C<CARP_TRACE>, will be called, if it exists.  If
  this method doesn't exist, or it recurses into C<Carp>, or it otherwise
  throws an exception, this is skipped, and Carp moves on to the next option,
  otherwise checking stops and the string returned is used.  It is recommended
  that the object's type is part of the string to make debugging easier.
  
  =item 2.
  
  For any type of reference, C<$Carp::RefArgFormatter> is checked (see below).
  This variable is expected to be a code reference, and the current parameter
  is passed in.  If this function doesn't exist (the variable is undef), or
  it recurses into C<Carp>, or it otherwise throws an exception, this is
  skipped, and Carp moves on to the next option, otherwise checking stops
  and the string returned is used.
  
  =item 3.
  
  Otherwise, if neither C<CARP_TRACE> nor C<$Carp::RefArgFormatter> is
  available, stringify the value ignoring any overloading.
  
  =back
  
  =head1 GLOBAL VARIABLES
  
  =head2 $Carp::MaxEvalLen
  
  This variable determines how many characters of a string-eval are to
  be shown in the output. Use a value of C<0> to show all text.
  
  Defaults to C<0>.
  
  =head2 $Carp::MaxArgLen
  
  This variable determines how many characters of each argument to a
  function to print. Use a value of C<0> to show the full length of the
  argument.
  
  Defaults to C<64>.
  
  =head2 $Carp::MaxArgNums
  
  This variable determines how many arguments to each function to show.
  Use a false value to show all arguments to a function call.  To suppress all
  arguments, use C<-1> or C<'0 but true'>.
  
  Defaults to C<8>.
  
  =head2 $Carp::Verbose
  
  This variable makes C<carp()> and C<croak()> generate stack backtraces
  just like C<cluck()> and C<confess()>.  This is how C<use Carp 'verbose'>
  is implemented internally.
  
  Defaults to C<0>.
  
  =head2 $Carp::RefArgFormatter
  
  This variable sets a general argument formatter to display references.
  Plain scalars and objects that implement C<CARP_TRACE> will not go through
  this formatter.  Calling C<Carp> from within this function is not supported.
  
  local $Carp::RefArgFormatter = sub {
      require Data::Dumper;
      Data::Dumper::Dump($_[0]); # not necessarily safe
  };
  
  =head2 @CARP_NOT
  
  This variable, I<in your package>, says which packages are I<not> to be
  considered as the location of an error. The C<carp()> and C<cluck()>
  functions will skip over callers when reporting where an error occurred.
  
  NB: This variable must be in the package's symbol table, thus:
  
      # These work
      our @CARP_NOT; # file scope
      use vars qw(@CARP_NOT); # package scope
      @My::Package::CARP_NOT = ... ; # explicit package variable
  
      # These don't work
      sub xyz { ... @CARP_NOT = ... } # w/o declarations above
      my @CARP_NOT; # even at top-level
  
  Example of use:
  
      package My::Carping::Package;
      use Carp;
      our @CARP_NOT;
      sub bar     { .... or _error('Wrong input') }
      sub _error  {
          # temporary control of where'ness, __PACKAGE__ is implicit
          local @CARP_NOT = qw(My::Friendly::Caller);
          carp(@_)
      }
  
  This would make C<Carp> report the error as coming from a caller not
  in C<My::Carping::Package>, nor from C<My::Friendly::Caller>.
  
  Also read the L</DESCRIPTION> section above, about how C<Carp> decides
  where the error is reported from.
  
  Use C<@CARP_NOT>, instead of C<$Carp::CarpLevel>.
  
  Overrides C<Carp>'s use of C<@ISA>.
  
  =head2 %Carp::Internal
  
  This says what packages are internal to Perl.  C<Carp> will never
  report an error as being from a line in a package that is internal to
  Perl.  For example:
  
      $Carp::Internal{ (__PACKAGE__) }++;
      # time passes...
      sub foo { ... or confess("whatever") };
  
  would give a full stack backtrace starting from the first caller
  outside of __PACKAGE__.  (Unless that package was also internal to
  Perl.)
  
  =head2 %Carp::CarpInternal
  
  This says which packages are internal to Perl's warning system.  For
  generating a full stack backtrace this is the same as being internal
  to Perl, the stack backtrace will not start inside packages that are
  listed in C<%Carp::CarpInternal>.  But it is slightly different for
  the summary message generated by C<carp> or C<croak>.  There errors
  will not be reported on any lines that are calling packages in
  C<%Carp::CarpInternal>.
  
  For example C<Carp> itself is listed in C<%Carp::CarpInternal>.
  Therefore the full stack backtrace from C<confess> will not start
  inside of C<Carp>, and the short message from calling C<croak> is
  not placed on the line where C<croak> was called.
  
  =head2 $Carp::CarpLevel
  
  This variable determines how many additional call frames are to be
  skipped that would not otherwise be when reporting where an error
  occurred on a call to one of C<Carp>'s functions.  It is fairly easy
  to count these call frames on calls that generate a full stack
  backtrace.  However it is much harder to do this accounting for calls
  that generate a short message.  Usually people skip too many call
  frames.  If they are lucky they skip enough that C<Carp> goes all of
  the way through the call stack, realizes that something is wrong, and
  then generates a full stack backtrace.  If they are unlucky then the
  error is reported from somewhere misleading very high in the call
  stack.
  
  Therefore it is best to avoid C<$Carp::CarpLevel>.  Instead use
  C<@CARP_NOT>, C<%Carp::Internal> and C<%Carp::CarpInternal>.
  
  Defaults to C<0>.
  
  =head1 BUGS
  
  The Carp routines don't handle exception objects currently.
  If called with a first argument that is a reference, they simply
  call die() or warn(), as appropriate.
  
  =head1 SEE ALSO
  
  L<Carp::Always>,
  L<Carp::Clan>
  
  =head1 AUTHOR
  
  The Carp module first appeared in Larry Wall's perl 5.000 distribution.
  Since then it has been modified by several of the perl 5 porters.
  Andrew Main (Zefram) <zefram@fysh.org> divested Carp into an independent
  distribution.
  
  =head1 COPYRIGHT
  
  Copyright (C) 1994-2013 Larry Wall
  
  Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
CARP

$fatpacked{"Carp/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_HEAVY';
  package Carp::Heavy;
  
  use Carp ();
  
  our $VERSION = '1.38';
  $VERSION =~ tr/_//d;
  
  # Carp::Heavy was merged into Carp in version 1.12.  Any mismatched versions
  # after this point are not significant and can be ignored.
  if(($Carp::VERSION || 0) < 1.12) {
  	my $cv = defined($Carp::VERSION) ? $Carp::VERSION : "undef";
  	die "Version mismatch between Carp $cv ($INC{q(Carp.pm)}) and Carp::Heavy $VERSION ($INC{q(Carp/Heavy.pm)}).  Did you alter \@INC after Carp was loaded?\n";
  }
  
  1;
  
  # Most of the machinery of Carp used to be here.
  # It has been moved in Carp.pm now, but this placeholder remains for
  # the benefit of modules that like to preload Carp::Heavy directly.
  # This must load Carp, because some modules rely on the historical
  # behaviour of Carp::Heavy loading Carp.
CARP_HEAVY

$fatpacked{"Config/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_YAML';
  package Config::YAML;
  
  # $Id: YAML.pm 41 2005-03-15 22:33:09Z mdxi $
  
  use warnings;
  use strict;
  use YAML;
  
  use vars qw( $AUTOLOAD );
  
  =head1 NAME
  
  Config::YAML - Simple configuration automation
  
  =head1 VERSION
  
  Version 1.42
  
  =cut
  
  our $VERSION = '1.42';
  
  =head1 SYNOPSIS
  
  Config::YAML is a somewhat object-oriented wrapper around the YAML
  module which makes reading and writing configuration files
  simple. Handling multiple config files (e.g. system and per-user
  configuration, or a gallery app with per-directory configuration) is a
  snap.
  
      use Config::YAML;
  
      # create Config::YAML object with any desired initial options
      # parameters; load system config; set alternate output file
      my $c = Config::YAML->new( config => "/usr/share/foo/globalconf",
                                 output => "~/.foorc",
                                 param1 => value1,
                                 param2 => value2,
                                 ...
                                 paramN => valueN,
                               );
  
      # integrate user's own config
      $c->read("~/.foorc");
  
      # integrate command line args using Getopt::Long
      $rc = GetOptions ( $c,
                         'param1|p!',
                         'param2|P',
                         'paramN|n',
                       );
  
      # Write configuration state to disk
      $c->write;
  
      # simply get params back for use...
      do_something() unless $c->{param1};
      # or get them more OO-ly if that makes you feel better
      my $value = $c->get_param2;
  
  =cut
  
  
  
  
  =head1 METHODS
  
  =head2 new
  
  Creates a new Config::YAML object.
  
      my $c = Config::YAML->new( config => initial_config, 
                                 output => output_config
                               );
  
  The C<config> parameter specifies the file to be read in during object
  creation. It is required, and must be the first parameter given. If
  the second parameter is C<output>, then it is used to specify the file
  to which configuration data will later be written out.  This
  positional dependancy makes it possible to have parameters named
  "config" and/or "output" in config files.
  
  Initial configuration values can be passed as subsequent parameters to
  the constructor:
  
      my $c = Config::YAML->new( config => "~/.foorc",
                                 foo    => "abc",
                                 bar    => "xyz",
                                 baz    => [ 1, 2, 3 ],
                               );
  
  =cut
  
  sub new {
      my $class = shift;
      my %priv  = ();
      my %args  = ();
  
      die("Can't create Config::YAML object with no config file.\n") 
          if ($_[0] ne "config");
      shift; $priv{config} = shift;
  
      if (@_ && ($_[0] eq "output")) { shift; $priv{output} = shift; }
      if (@_ && ($_[0] eq "strict")) { shift; $priv{strict} = shift; }
  
      my $self = bless { _infile   => $priv{config},
                         _outfile  => $priv{output}   || $priv{config},
                         _strict   => $priv{strict}   || 0,
                       }, $class;
  
      %args = @_;
      @{$self}{keys %args} = values %args;
  
      $self->read;
      return $self;
  }
  
  =head2 get_*/set_*
  
  If you'd prefer not to directly molest the object to store and
  retrieve configuration data, autoloading methods of the forms
  C<get_[param]> and C<set_[param]> are provided. Continuing from the
  previous example:
  
      print $c->get_foo;      # prints "abc"
      my $val = $c->get_quux; # $c->{quux} doesn't exist; returns undef
  
      $c->set_bar(30);     # $c->{bar} now equals 30, not "xyz"
      my @list = qw(alpha beta gamma);
      $c->set_baz(\@list); # $c->{baz} now a reference to @list
  
  =cut
  
  sub Config::YAML::AUTOLOAD {
      no strict 'refs';
      my ($self, $newval) = @_;
  
      if ($AUTOLOAD =~ /.*::get_(\w+)/) {
          my $attr = $1;
          return undef if (!defined $self->{$attr});
          *{$AUTOLOAD} = sub { return $_[0]->{$attr} };
          return $self->{$attr};
      }
  
      if ($AUTOLOAD =~ /.*::set_(\w+)/) {
          my $attr = $1;
          *{$AUTOLOAD} = sub { $_[0]->{$attr} = $_[1]; return };
          $self->{$attr} = $newval;
          return;
      }
  }
  
  =head2 fold
  
  Convenience method for folding multiple values into the config object
  at once. Requires a hashref as its argument.
  
      $prefs{theme}  = param(theme);
      $prefs{format} = param(format);
      $prefs{sortby} = param(order);
  
      $c->fold(\%prefs);
  
      my $format = $c->get_format; # value matches that of param(format)
  
  =cut
  
  sub fold {
      my ($self, $data) = @_;
      # add check for HASHREF when strict mode is implemented
      @{$self}{keys %{$data}} = values %{$data};
  }
  
  =head2 read
  
  Imports a YAML-formatted config file.
  
      $c->read('/usr/share/fooapp/fooconf');
  
  C<read()> is called at object creation and imports the file specified
  by C<< new(config=>) >>, so there is no need to call it manually
  unless multiple config files exist.
  
  =cut
  
  sub read {
      my ($self, $file) = @_;
      $self->{_infile} = $file if $file;
  
      my $yaml;
      my $line;
  
      open(FH,'<',$self->{_infile}) or die "Can't open $self->{_infile}; $!\n";
      while ($line = <FH>) {
          next if ($line =~ /^\-{3,}/);
          next if ($line =~ /^#/);
          next if ($line =~ /^$/);
          $yaml .= $line;
      }
      close(FH);
  
      my $tmpyaml = Load($yaml);
      @{$self}{keys %{$tmpyaml}} = values %{$tmpyaml}; # woo, hash slice
  }
  
  =head2 write
  
  Dump current configuration state to a YAML-formatted flat file.
  
      $c->write;
  
  The file to be written is specified in the constructor call. See the
  C<new> method documentation for details.
  
  =cut
  
  sub write {
      my $self = shift;
      my %tmpyaml;
  
      # strip out internal state parameters
      while(my($k,$v) = each%{$self}) {
          $tmpyaml{$k} = $v unless ($k =~ /^_/);
      }
  
      # write data out to file
      open(FH,'>',$self->{_outfile}) or die "Can't open $self->{_outfile}: $!\n";
      print FH Dump(\%tmpyaml);
      close(FH);
  }
  
  =head1 DEPRECATED METHODS
  
  These methods have been superceded and will likely be removed in the
  next release.
  
  =head2 get
  
  Returns the value of a parameter.
  
      print $c->get('foo');
  
  =cut
  
  sub get {
      my ($self, $arg) = @_;
      return $self->{$arg};
  }
  
  =head2 set
  
  Sets the value of a parameter:
  
      $c->set('foo',1);
  
      my @paints = qw( oil acrylic tempera );
      $c->set('paints', \@paints);
  
  =cut
  
  sub set {
      my ($self, $key, $val) = @_;
      $self->{$key} = $val;
  }
  
  =head1 AUTHOR
  
  Shawn Boyette (C<< <mdxi@cpan.org> >>)
  
  Original implementation by Kirrily "Skud" Robert (as
  C<YAML::ConfigFile>).
  
  =head1 BUGS
  
  =over
  
  =item
  
  Config::YAML ignores the YAML document separation string (C<--->)
  because it has no concept of multiple targets for the data coming from
  a config file.
  
  =back
  
  Please report any bugs or feature requests to
  C<bug-yaml-configfile@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.  I will be notified, and then you'll
  automatically be notified of progress on your bug as I make changes.
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2004 Shawn Boyette, All Rights Reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1; # End of Config::YAML
CONFIG_YAML

$fatpacked{"URI/Encode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ENCODE';
  package URI::Encode;
  
  #######################
  # LOAD MODULES
  #######################
  use strict;
  use warnings FATAL => 'all';
  
  use 5.008001;
  use Encode qw();
  use Carp qw(croak carp);
  
  #######################
  # VERSION
  #######################
  our $VERSION = '1.1.1';
  
  #######################
  # EXPORT
  #######################
  use base qw(Exporter);
  our (@EXPORT_OK);
  
  @EXPORT_OK = qw(uri_encode uri_decode);
  
  #######################
  # SETTINGS
  #######################
  
  # Reserved characters
  my $reserved_re
    = qr{([^a-zA-Z0-9\-\_\.\~\!\*\'\(\)\;\:\@\&\=\+\$\,\/\?\#\[\]\%])}x;
  
  # Un-reserved characters
  my $unreserved_re = qr{([^a-zA-Z0-9\Q-_.~\E\%])}x;
  
  # Encoded character set
  my $encoded_chars = qr{%([a-fA-F0-9]{2})}x;
  
  #######################
  # CONSTRUCTOR
  #######################
  sub new {
      my ( $class, @in ) = @_;
  
      # Check Input
      my $defaults = {
  
          #   this module, unlike URI::Escape,
          #   does not encode reserved characters
          encode_reserved => 0,
  
          #   Allow Double encoding?
          #   defaults to YES
          double_encode => 1,
      };
  
      my $input = {};
      if   ( ref $in[0] eq 'HASH' ) { $input = $in[0]; }
      else                          { $input = {@in}; }
  
      # Set options
      my $options = {
  
          # Defaults
          %{$defaults},
  
          # Input
          %{$input},
  
          # Encoding Map
          enc_map =>
            { ( map { chr($_) => sprintf( "%%%02X", $_ ) } ( 0 ... 255 ) ) },
  
          # Decoding Map
          dec_map =>
            { ( map { sprintf( "%02X", $_ ) => chr($_) } ( 0 ... 255 ) ), },
      };
  
      # Return
      my $self = bless $options, $class;
    return $self;
  } ## end sub new
  
  #######################
  # ENCODE
  #######################
  sub encode {
      my ( $self, $data, $options ) = @_;
  
      # Check for data
      # Allow to be '0'
    return unless defined $data;
  
      my $enc_res       = $self->{encode_reserved};
      my $double_encode = $self->{double_encode};
  
      if ( defined $options ) {
          if ( ref $options eq 'HASH' ) {
              $enc_res = $options->{encode_reserved}
                if exists $options->{encode_reserved};
              $double_encode = $options->{double_encode}
                if exists $options->{double_encode};
          } ## end if ( ref $options eq 'HASH')
          else {
              $enc_res = $options;
          }
      } ## end if ( defined $options )
  
      # UTF-8 encode
      $data = Encode::encode( 'utf-8-strict', $data );
  
      # Encode a literal '%'
      if ($double_encode) { $data =~ s{(\%)}{$self->_get_encoded_char($1)}gex; }
      else { $data =~ s{(\%)(.*)}{$self->_encode_literal_percent($1, $2)}gex; }
  
      # Percent Encode
      if ($enc_res) {
          $data =~ s{$unreserved_re}{$self->_get_encoded_char($1)}gex;
      }
      else {
          $data =~ s{$reserved_re}{$self->_get_encoded_char($1)}gex;
      }
  
      # Done
    return $data;
  } ## end sub encode
  
  #######################
  # DECODE
  #######################
  sub decode {
      my ( $self, $data ) = @_;
  
      # Check for data
      # Allow to be '0'
    return unless defined $data;
  
      # Percent Decode
      $data =~ s{$encoded_chars}{ $self->_get_decoded_char($1) }gex;
  
    return $data;
  } ## end sub decode
  
  #######################
  # EXPORTED FUNCTIONS
  #######################
  
  # Encoder
  sub uri_encode { return __PACKAGE__->new()->encode(@_); }
  
  # Decoder
  sub uri_decode { return __PACKAGE__->new()->decode(@_); }
  
  #######################
  # INTERNAL
  #######################
  
  
  sub _get_encoded_char {
      my ( $self, $char ) = @_;
    return $self->{enc_map}->{$char} if exists $self->{enc_map}->{$char};
    return $char;
  } ## end sub _get_encoded_char
  
  
  sub _encode_literal_percent {
      my ( $self, $char, $post ) = @_;
  
    return $self->_get_encoded_char($char) if not defined $post;
  
      my $return_char;
      if ( $post =~ m{^([a-fA-F0-9]{2})}x ) {
          if ( exists $self->{dec_map}->{$1} ) {
              $return_char = join( '', $char, $post );
          }
      } ## end if ( $post =~ m{^([a-fA-F0-9]{2})}x)
  
      $return_char ||= join( '', $self->_get_encoded_char($char), $post );
    return $return_char;
  } ## end sub _encode_literal_percent
  
  
  sub _get_decoded_char {
      my ( $self, $char ) = @_;
    return $self->{dec_map}->{ uc($char) }
        if exists $self->{dec_map}->{ uc($char) };
    return $char;
  } ## end sub _get_decoded_char
  
  #######################
  1;
  
  __END__
  
  #######################
  # POD SECTION
  #######################
  =pod
  
  =head1 NAME
  
  URI::Encode - Simple percent Encoding/Decoding
  
  =for html <a href="https://travis-ci.org/mithun/perl-uri-encode"><img src="https://travis-ci.org/mithun/perl-uri-encode.svg?branch=master"></a>
  
  =head1 SYNOPSIS
  
      # OOP Interface
      use URI::Encode;
      my $uri     = URI::Encode->new( { encode_reserved => 0 } );
      my $encoded = $uri->encode($data);
      my $decoded = $uri->decode($encoded);
  
      # Functional
      use URI::Encode qw(uri_encode uri_decode);
      my $encoded = uri_encode($data);
      my $decoded = uri_decode($encoded);
  
  
  =head1 DESCRIPTION
  
  This modules provides simple URI (Percent) encoding/decoding
  
  The main purpose of this module (at least for me) was to provide an
  easy method to encode strings (mainly URLs) into a format which can be
  pasted into a plain text emails, and that those links are 'click-able'
  by the person reading that email. This can be accomplished by NOT
  encoding the reserved characters.
  
  This module can also be useful when using L<HTTP::Tiny> to ensure the
  URLs are properly escaped.
  
  B<This module does not encode reserved characters by default>. If you
  are looking for speed and want to encode reserved characters, use
  L<URI::Escape::XS>
  
  See L<this
  script|https://github.com/mithun/perl-uri-encode/raw/master/.author/benchmark.pl>
  for a comparison on encoding results and performance.
  
  =head1 METHODS
  
  =head2 new()
  
  Creates a new object, no arguments are required
  
      my $encoder = URI::Encode->new(\%options);
  
  The following options can be passed to the constructor
  
  =over
  
  =item encode_reserved
  
      my $encoder = URI::Encode->new({encode_reserved => 0});
  
  If true, L</"Reserved Characters"> are also encoded. Defaults to false.
  
  =item double_encode
  
      my $encoder = URI::Encode->new({double_encode => 1});
  
  If false, characters that are already percent-encoded will not be
  encoded again. Defaults to true.
  
      my $encoder = URI::Encode->new({double_encode => 0});
      print $encoder->encode('http://perl.com/foo%20bar'); # prints http://perl.com/foo%20bar
  
  =back
  
  =head2 C<encode($url, \%options)>
  
  This method encodes the URL provided. The C<$url> provided is first
  converted into UTF-8 before percent encoding. Options set in the
  constructor, or defaults, can be overridden by passing them as the
  (optional) second argument. Options passed must be a hashref.
  
      $uri->encode("http://perl.com/foo bar");
      $uri->encode( "http://perl.com/foo bar", { encode_reserved => 1 } );
  
  =head2 C<decode($url)>
  
  This method decodes a 'percent' encoded URL. If you had encoded the URL
  using this module (or any other method), chances are that the URL was
  converted to UTF-8 before 'percent' encoding. Be sure to check the
  format and convert back if required.
  
      $uri->decode("http%3A%2F%2Fperl.com%2Ffoo%20bar");
  
  =head1 EXPORTED FUNCTIONS
  
  The following functions are exported upon request. This provides a
  non-OOP interface
  
  =over
  
  =item C<uri_encode($url, \%options)>
  
  =item C<uri_decode($url)>
  
  =back
  
  =head1 CHARACTER CLASSES
  
  =head2 Reserved Characters
  
  The following characters are considered as reserved (L<RFC
  3986|http://tools.ietf.org/html/rfc3986>). They will be encoded only if
  requested.
  
       ! * ' ( ) ; : @ & = + $ , / ? # [ ]
  
  =head2 Unreserved Characters
  
  The following characters are considered as Unreserved. They will not be
  encoded
  
      a-z
      A-Z
      0-9
      - _ . ~
  
  =head1 DEPENDENCIES
  
  L<Encode>
  
  =head1 ACKNOWLEDGEMENTS
  
  Gisle Aas for L<URI::Escape>
  
  David Nicol for L<Tie::UrlEncoder>
  
  =head1 SEE ALSO
  
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>
  
  L<URI::Escape>
  
  L<URI::Escape::XS>
  
  L<URI::Escape::JavaScript>
  
  L<Tie::UrlEncoder>
  
  =head1 BUGS AND LIMITATIONS
  
  Please report any bugs or feature requests at
  L<https://github.com/mithun/perl-uri-encode/issues>
  
  =head1 AUTHOR
  
  Mithun Ayachit C<mithun@cpan.org>
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2014, Mithun Ayachit. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
URI_ENCODE

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  package YAML;
  our $VERSION = '1.23';
  
  use YAML::Mo;
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  our (
      $UseCode, $DumpCode, $LoadCode,
      $SpecVersion,
      $UseHeader, $UseVersion, $UseBlock, $UseFold, $UseAliases,
      $Indent, $SortKeys, $Preserve,
      $AnchorPrefix, $CompressSeries, $InlineSeries, $Purity,
      $Stringify, $Numify
  );
  
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  use Scalar::Util qw/ openhandle /;
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (openhandle $filename) {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, "$!");
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
      unless (ref $filename eq 'GLOB') {
          close $OUT
            or do {
                my $errsav = $!;
                YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT_CLOSE', $filename, $errsav);
            }
      }
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (openhandle $filename) {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, "$!");
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  use strict; use warnings;
  package YAML::Any;
  our $VERSION = '1.23';
  
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
      Preserve
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::croak(@_);
  }
  
  1;
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;
  
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  use Scalar::Util qw();
  use B ();
  use Carp ();
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo);
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0],
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) =
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      require YAML;
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} =
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) =
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash.
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
  
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_number($_[0]),
          $self->_emit($ef), last
            if $self->is_literal_number($_[0]);
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  sub is_literal_number {
      my $self = shift;
      # Stolen from JSON::Tiny
      return B::svref_2object(\$_[0])->FLAGS & (B::SVp_IOK | B::SVp_NOK)
              && 0 + $_[0] eq $_[0];
  }
  
  sub _emit_number {
      my $self = shift;
      return $self->_emit_plain($_[0]);
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      return 0 if $self->quote_numeric_strings and Scalar::Util::looks_like_number($_[0]);
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 0 if $_[0] eq '-';
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  
  use YAML::Mo;
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  has quote_numeric_strings => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
      $self->quote_numeric_strings($YAML::QuoteNumericStrings)
        if defined $YAML::QuoteNumericStrings;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
  
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;
  
  use YAML::Mo;
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;s/\\n/\n/;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_FILE_OUTPUT_CLOSE
    Error closing %s:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key '%s' found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)}
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
       YAML_PARSE_ERR_NO_ANCHOR
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  
  our @ISA = 'YAML::Error';
  
  1;
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;
  
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  use YAML::Loader::Base;
  use YAML::Types;
  use YAML::Node;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';
  my $LIT_CHAR_RX = "\\$LIT_CHAR";
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS')
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->{stream} =~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) =
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) =
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) {
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE');
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]*)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]*)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface);
  }
  
  # Morph a node to it's explicit type
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
  
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = $self->preserve ? YAML::Node->new({}) : {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
  
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY', $key);
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
  
          # Check whether the preface looks like a YAML mapping ("key: value").
          # This is complicated because it has to account for the possibility
          # that a key is a quoted string, which itself may contain escaped
          # quotes.
          my $preface = $self->preface;
          if ( $preface =~ /^ (\s*) ( \w .*?               \: (?:\ |$).*) $/x  or
               $preface =~ /^ (\s*) ((') (?:''|[^'])*? ' \s* \: (?:\ |$).*) $/x or
               $preface =~ /^ (\s*) ((") (?:\\\\|[^"])*? " \s* \: (?:\ |$).*) $/x
             ) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) =
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
  
          if ($self->numify and defined $node and not ref $node and length $node
              and $node =~ m/\A-?(?:0|[1-9][0-9]*)?(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?\z/) {
              $node += 0;
          }
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}\s*//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY', $key);
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]\s*//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      # https://rt.cpan.org/Public/Bug/Display.html?id=90593
      if ($self->inline =~ /^"((?:(?:\\"|[^"]){0,32766}){0,32766})"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:(?:''|[^']){0,32766}){0,32766})'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      if ($self->eos) {
          $self->offset->[$level + 1] = $offset + 1;
          return;
      }
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or
                  $self->die('YAML_PARSE_ERR_NONSPACE_INDENTATION');
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
  
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos;
  
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION')
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
  
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  
  use YAML::Mo;
  
  has load_code     => default => sub {0};
  has preserve      => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  has numify        => default => sub {0};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
      $self->preserve($YAML::Preserve) if defined $YAML::Preserve;
      $self->numify($YAML::Numify) if defined $YAML::Numify;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict; use warnings;
  package YAML::Marshall;
  
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo;
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.4
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{my$c=shift;my$s=bless{@_},$c;my%n=%{$c.'::'.':E'};map{$s->{$_}=$n{$_}->()if!exists$s->{$_}}keys%n;$s};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};@_=(default,@_)if!($#_%2);$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=\&{$P.$b}and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;exists$a{default}or return$m;my($d,$r)=$a{default};my$g='HASH'eq($r=ref$d)?sub{+{%$d}}:'ARRAY'eq$r?sub{[@$d]}:'CODE'eq$r?$d:sub{$d};my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=$g and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$g->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not$_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict; use warnings;
  package YAML::Node;
  
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
          $self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
          $self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
          $self = tied(*{$_[0]});
      }
      else {
          $self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
                      ($type eq 'HASH') ? 'mapping' :
                      $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
          yaml_scalar->new($self, $_[1]);
          return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
                 $self->{TAG} = YAML::Tag->new($value);
          return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
                 $self->{KEYS} = $value;
          return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}};
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
          return (grep {$_ eq $key} @{$self->{KEYS}})
                 ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
          $self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
          $self->{HASH}{$key} = $value;
      }
      else {
          if (not grep {$_ eq $key} @{$self->{KEYS}}) {
              push(@{$self->{KEYS}}, $key);
          }
          $self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
          $return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
          $return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
          if ($self->{KEYS}[$i] eq $key) {
              splice(@{$self->{KEYS}}, $i, 1);
          }
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict; use warnings;
  package YAML::Tag;
  
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;
  
  use YAML::Mo;
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      }
      elsif ($type eq 'GLOB') {
          # blessed glob support is minimal, and will not round-trip
          # initial aim: to not cause an error
          return YAML::Type::glob->yaml_dump($value, $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  
  sub yaml_dump {
      my $self = shift;
      # $_[0] remains as the glob
      my $tag = pop @_ if 2==@_;
  
      $tag = '!perl/glob:' unless defined $tag;
      my $ynode = YAML::Node->new({}, $tag);
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value;
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  
  my $dummy_warned = 0;
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { require B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
YAML_TYPES

$fatpacked{"base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BASE';
  use 5.008;
  package base;
  
  use strict 'vars';
  use vars qw($VERSION);
  $VERSION = '2.23';
  $VERSION =~ tr/_//d;
  
  # constant.pm is slow
  sub SUCCESS () { 1 }
  
  sub PUBLIC     () { 2**0  }
  sub PRIVATE    () { 2**1  }
  sub INHERITED  () { 2**2  }
  sub PROTECTED  () { 2**3  }
  
  
  my $Fattr = \%fields::attr;
  
  sub has_fields {
      my($base) = shift;
      my $fglob = ${"$base\::"}{FIELDS};
      return( ($fglob && 'GLOB' eq ref($fglob) && *$fglob{HASH}) ? 1 : 0 );
  }
  
  sub has_attr {
      my($proto) = shift;
      my($class) = ref $proto || $proto;
      return exists $Fattr->{$class};
  }
  
  sub get_attr {
      $Fattr->{$_[0]} = [1] unless $Fattr->{$_[0]};
      return $Fattr->{$_[0]};
  }
  
  if ($] < 5.009) {
      *get_fields = sub {
          # Shut up a possible typo warning.
          () = \%{$_[0].'::FIELDS'};
          my $f = \%{$_[0].'::FIELDS'};
  
          # should be centralized in fields? perhaps
          # fields::mk_FIELDS_be_OK. Peh. As long as %{ $package . '::FIELDS' }
          # is used here anyway, it doesn't matter.
          bless $f, 'pseudohash' if (ref($f) ne 'pseudohash');
  
          return $f;
      }
  }
  else {
      *get_fields = sub {
          # Shut up a possible typo warning.
          () = \%{$_[0].'::FIELDS'};
          return \%{$_[0].'::FIELDS'};
      }
  }
  
  if ($] < 5.008) {
      *_module_to_filename = sub {
          (my $fn = $_[0]) =~ s!::!/!g;
          $fn .= '.pm';
          return $fn;
      }
  }
  else {
      *_module_to_filename = sub {
          (my $fn = $_[0]) =~ s!::!/!g;
          $fn .= '.pm';
          utf8::encode($fn);
          return $fn;
      }
  }
  
  
  sub import {
      my $class = shift;
  
      return SUCCESS unless @_;
  
      # List of base classes from which we will inherit %FIELDS.
      my $fields_base;
  
      my $inheritor = caller(0);
  
      my @bases;
      foreach my $base (@_) {
          if ( $inheritor eq $base ) {
              warn "Class '$inheritor' tried to inherit from itself\n";
          }
  
          next if grep $_->isa($base), ($inheritor, @bases);
  
          # Following blocks help isolate $SIG{__DIE__} changes
          {
              my $sigdie;
              {
                  local $SIG{__DIE__};
                  my $fn = _module_to_filename($base);
                  eval { require $fn };
                  # Only ignore "Can't locate" errors from our eval require.
                  # Other fatal errors (syntax etc) must be reported.
                  #
                  # changing the check here is fragile - if the check
                  # here isn't catching every error you want, you should
                  # probably be using parent.pm, which doesn't try to
                  # guess whether require is needed or failed,
                  # see [perl #118561]
                  die if $@ && $@ !~ /^Can't locate \Q$fn\E .*? at .* line [0-9]+(?:, <[^>]*> (?:line|chunk) [0-9]+)?\.\n\z/s
                            || $@ =~ /Compilation failed in require at .* line [0-9]+(?:, <[^>]*> (?:line|chunk) [0-9]+)?\.\n\z/;
                  unless (%{"$base\::"}) {
                      require Carp;
                      local $" = " ";
                      Carp::croak(<<ERROR);
  Base class package "$base" is empty.
      (Perhaps you need to 'use' the module which defines that package first,
      or make that module available in \@INC (\@INC contains: @INC).
  ERROR
                  }
                  $sigdie = $SIG{__DIE__} || undef;
              }
              # Make sure a global $SIG{__DIE__} makes it out of the localization.
              $SIG{__DIE__} = $sigdie if defined $sigdie;
          }
          push @bases, $base;
  
          if ( has_fields($base) || has_attr($base) ) {
              # No multiple fields inheritance *suck*
              if ($fields_base) {
                  require Carp;
                  Carp::croak("Can't multiply inherit fields");
              } else {
                  $fields_base = $base;
              }
          }
      }
      # Save this until the end so it's all or nothing if the above loop croaks.
      push @{"$inheritor\::ISA"}, @bases;
  
      if( defined $fields_base ) {
          inherit_fields($inheritor, $fields_base);
      }
  }
  
  
  sub inherit_fields {
      my($derived, $base) = @_;
  
      return SUCCESS unless $base;
  
      my $battr = get_attr($base);
      my $dattr = get_attr($derived);
      my $dfields = get_fields($derived);
      my $bfields = get_fields($base);
  
      $dattr->[0] = @$battr;
  
      if( keys %$dfields ) {
          warn <<"END";
  $derived is inheriting from $base but already has its own fields!
  This will cause problems.  Be sure you use base BEFORE declaring fields.
  END
  
      }
  
      # Iterate through the base's fields adding all the non-private
      # ones to the derived class.  Hang on to the original attribute
      # (Public, Private, etc...) and add Inherited.
      # This is all too complicated to do efficiently with add_fields().
      while (my($k,$v) = each %$bfields) {
          my $fno;
          if ($fno = $dfields->{$k} and $fno != $v) {
              require Carp;
              Carp::croak ("Inherited fields can't override existing fields");
          }
  
          if( $battr->[$v] & PRIVATE ) {
              $dattr->[$v] = PRIVATE | INHERITED;
          }
          else {
              $dattr->[$v] = INHERITED | $battr->[$v];
              $dfields->{$k} = $v;
          }
      }
  
      foreach my $idx (1..$#{$battr}) {
          next if defined $dattr->[$idx];
          $dattr->[$idx] = $battr->[$idx] & INHERITED;
      }
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  base - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use base qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Unless you are using the C<fields> pragma, consider this module discouraged
  in favor of the lighter-weight C<parent>.
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Roughly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  When C<base> tries to C<require> a module, it will not die if it cannot find
  the module's file, but will die on any other error.  After all this, should
  your base class be empty, containing no symbols, C<base> will die. This is
  useful for inheriting from classes in the same file as yourself but where
  the filename does not match the base module name, like so:
  
          # in Bar.pm
          package Foo;
          sub exclaim { "I can have such a thing?!" }
  
          package Bar;
          use base "Foo";
  
  There is no F<Foo.pm>, but because C<Foo> defines a symbol (the C<exclaim>
  subroutine), C<base> will not die when the C<require> fails to load F<Foo.pm>.
  
  C<base> will also initialize the fields if one of the base classes has it.
  Multiple inheritance of fields is B<NOT> supported, if two or more base classes
  each have inheritable fields the 'base' pragma will croak. See L<fields>
  for a description of this feature.
  
  The base class' C<import> method is B<not> called.
  
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Base class package "%s" is empty.
  
  base.pm was unable to require the base package, because it was not
  found in your path.
  
  =item Class 'Foo' tried to inherit from itself
  
  Attempting to inherit from yourself generates a warning.
  
      package Foo;
      use base 'Foo';
  
  =back
  
  =head1 HISTORY
  
  This module was introduced with Perl 5.004_04.
  
  =head1 CAVEATS
  
  Due to the limitations of the implementation, you must use
  base I<before> you declare any of your own fields.
  
  
  =head1 SEE ALSO
  
  L<fields>
  
  =cut
BASE

$fatpacked{"darwin-2level/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CWD';
  package Cwd;
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
        require XSLoader;
        XSLoader::load( __PACKAGE__, $xs_version);
      } else {
        require DynaLoader;
        push @ISA, 'DynaLoader';
        __PACKAGE__->bootstrap( $xs_version );
      }
    };
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      return $ENV{'PWD'} = EPOC::getcwd();
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
DARWIN-2LEVEL_CWD

$fatpacked{"darwin-2level/Data/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_DATA_DUMPER';
  #
  # Data/Dumper.pm
  #
  # convert perl data structures into perl syntax suitable for both printing
  # and eval
  #
  # Documentation at the __END__
  #
  
  package Data::Dumper;
  
  BEGIN {
      $VERSION = '2.161'; # Don't forget to set version and release
  }               # date in POD below!
  
  #$| = 1;
  
  use 5.006_001;
  require Exporter;
  require overload;
  
  use Carp;
  
  BEGIN {
      @ISA = qw(Exporter);
      @EXPORT = qw(Dumper);
      @EXPORT_OK = qw(DumperX);
  
      # if run under miniperl, or otherwise lacking dynamic loading,
      # XSLoader should be attempted to load, or the pure perl flag
      # toggled on load failure.
      eval {
          require XSLoader;
          XSLoader::load( 'Data::Dumper' );
          1
      }
      or $Useperl = 1;
  }
  
  my $IS_ASCII  = ord 'A' ==  65;
  
  # module vars and their defaults
  $Indent     = 2         unless defined $Indent;
  $Trailingcomma = 0      unless defined $Trailingcomma;
  $Purity     = 0         unless defined $Purity;
  $Pad        = ""        unless defined $Pad;
  $Varname    = "VAR"     unless defined $Varname;
  $Useqq      = 0         unless defined $Useqq;
  $Terse      = 0         unless defined $Terse;
  $Freezer    = ""        unless defined $Freezer;
  $Toaster    = ""        unless defined $Toaster;
  $Deepcopy   = 0         unless defined $Deepcopy;
  $Quotekeys  = 1         unless defined $Quotekeys;
  $Bless      = "bless"   unless defined $Bless;
  #$Expdepth   = 0         unless defined $Expdepth;
  $Maxdepth   = 0         unless defined $Maxdepth;
  $Pair       = ' => '    unless defined $Pair;
  $Useperl    = 0         unless defined $Useperl;
  $Sortkeys   = 0         unless defined $Sortkeys;
  $Deparse    = 0         unless defined $Deparse;
  $Sparseseen = 0         unless defined $Sparseseen;
  $Maxrecurse = 1000      unless defined $Maxrecurse;
  
  #
  # expects an arrayref of values to be dumped.
  # can optionally pass an arrayref of names for the values.
  # names must have leading $ sign stripped. begin the name with *
  # to cause output of arrays and hashes rather than refs.
  #
  sub new {
    my($c, $v, $n) = @_;
  
    croak "Usage:  PACKAGE->new(ARRAYREF, [ARRAYREF])"
      unless (defined($v) && (ref($v) eq 'ARRAY'));
    $n = [] unless (defined($n) && (ref($n) eq 'ARRAY'));
  
    my($s) = {
          level      => 0,           # current recursive depth
          indent     => $Indent,     # various styles of indenting
          trailingcomma => $Trailingcomma, # whether to add comma after last elem
          pad        => $Pad,        # all lines prefixed by this string
          xpad       => "",          # padding-per-level
          apad       => "",          # added padding for hash keys n such
          sep        => "",          # list separator
          pair       => $Pair,    # hash key/value separator: defaults to ' => '
          seen       => {},          # local (nested) refs (id => [name, val])
          todump     => $v,          # values to dump []
          names      => $n,          # optional names for values []
          varname    => $Varname,    # prefix to use for tagging nameless ones
          purity     => $Purity,     # degree to which output is evalable
          useqq      => $Useqq,      # use "" for strings (backslashitis ensues)
          terse      => $Terse,      # avoid name output (where feasible)
          freezer    => $Freezer,    # name of Freezer method for objects
          toaster    => $Toaster,    # name of method to revive objects
          deepcopy   => $Deepcopy,   # do not cross-ref, except to stop recursion
          quotekeys  => $Quotekeys,  # quote hash keys
          'bless'    => $Bless,    # keyword to use for "bless"
  #        expdepth   => $Expdepth,   # cutoff depth for explicit dumping
          maxdepth   => $Maxdepth,   # depth beyond which we give up
  	maxrecurse => $Maxrecurse, # depth beyond which we abort
          useperl    => $Useperl,    # use the pure Perl implementation
          sortkeys   => $Sortkeys,   # flag or filter for sorting hash keys
          deparse    => $Deparse,    # use B::Deparse for coderefs
          noseen     => $Sparseseen, # do not populate the seen hash unless necessary
         };
  
    if ($Indent > 0) {
      $s->{xpad} = "  ";
      $s->{sep} = "\n";
    }
    return bless($s, $c);
  }
  
  # Packed numeric addresses take less memory. Plus pack is faster than sprintf
  
  # Most users of current versions of Data::Dumper will be 5.008 or later.
  # Anyone on 5.6.1 and 5.6.2 upgrading will be rare (particularly judging by
  # the bug reports from users on those platforms), so for the common case avoid
  # complexity, and avoid even compiling the unneeded code.
  
  sub init_refaddr_format {
  }
  
  sub format_refaddr {
      require Scalar::Util;
      pack "J", Scalar::Util::refaddr(shift);
  };
  
  if ($] < 5.008) {
      eval <<'EOC' or die;
      no warnings 'redefine';
      my $refaddr_format;
      sub init_refaddr_format {
          require Config;
          my $f = $Config::Config{uvxformat};
          $f =~ tr/"//d;
          $refaddr_format = "0x%" . $f;
      }
  
      sub format_refaddr {
          require Scalar::Util;
          sprintf $refaddr_format, Scalar::Util::refaddr(shift);
      }
  
      1
  EOC
  }
  
  #
  # add-to or query the table of already seen references
  #
  sub Seen {
    my($s, $g) = @_;
    if (defined($g) && (ref($g) eq 'HASH'))  {
      init_refaddr_format();
      my($k, $v, $id);
      while (($k, $v) = each %$g) {
        if (defined $v) {
          if (ref $v) {
            $id = format_refaddr($v);
            if ($k =~ /^[*](.*)$/) {
              $k = (ref $v eq 'ARRAY') ? ( "\\\@" . $1 ) :
                   (ref $v eq 'HASH')  ? ( "\\\%" . $1 ) :
                   (ref $v eq 'CODE')  ? ( "\\\&" . $1 ) :
                   (   "\$" . $1 ) ;
            }
            elsif ($k !~ /^\$/) {
              $k = "\$" . $k;
            }
            $s->{seen}{$id} = [$k, $v];
          }
          else {
            carp "Only refs supported, ignoring non-ref item \$$k";
          }
        }
        else {
          carp "Value of ref must be defined; ignoring undefined item \$$k";
        }
      }
      return $s;
    }
    else {
      return map { @$_ } values %{$s->{seen}};
    }
  }
  
  #
  # set or query the values to be dumped
  #
  sub Values {
    my($s, $v) = @_;
    if (defined($v)) {
      if (ref($v) eq 'ARRAY')  {
        $s->{todump} = [@$v];        # make a copy
        return $s;
      }
      else {
        croak "Argument to Values, if provided, must be array ref";
      }
    }
    else {
      return @{$s->{todump}};
    }
  }
  
  #
  # set or query the names of the values to be dumped
  #
  sub Names {
    my($s, $n) = @_;
    if (defined($n)) {
      if (ref($n) eq 'ARRAY') {
        $s->{names} = [@$n];         # make a copy
        return $s;
      }
      else {
        croak "Argument to Names, if provided, must be array ref";
      }
    }
    else {
      return @{$s->{names}};
    }
  }
  
  sub DESTROY {}
  
  sub Dump {
      return &Dumpxs
      unless $Data::Dumper::Useperl || (ref($_[0]) && $_[0]->{useperl})
          || $Data::Dumper::Deparse || (ref($_[0]) && $_[0]->{deparse})
  
              # Use pure perl version on earlier releases on EBCDIC platforms
          || (! $IS_ASCII && $] lt 5.021_010);
      return &Dumpperl;
  }
  
  #
  # dump the refs in the current dumper object.
  # expects same args as new() if called via package name.
  #
  sub Dumpperl {
    my($s) = shift;
    my(@out, $val, $name);
    my($i) = 0;
    local(@post);
    init_refaddr_format();
  
    $s = $s->new(@_) unless ref $s;
  
    for $val (@{$s->{todump}}) {
      @post = ();
      $name = $s->{names}[$i++];
      $name = $s->_refine_name($name, $val, $i);
  
      my $valstr;
      {
        local($s->{apad}) = $s->{apad};
        $s->{apad} .= ' ' x (length($name) + 3) if $s->{indent} >= 2 and !$s->{terse};
        $valstr = $s->_dump($val, $name);
      }
  
      $valstr = "$name = " . $valstr . ';' if @post or !$s->{terse};
      my $out = $s->_compose_out($valstr, \@post);
  
      push @out, $out;
    }
    return wantarray ? @out : join('', @out);
  }
  
  # wrap string in single quotes (escaping if needed)
  sub _quote {
      my $val = shift;
      $val =~ s/([\\\'])/\\$1/g;
      return  "'" . $val .  "'";
  }
  
  # Old Perls (5.14-) have trouble resetting vstring magic when it is no
  # longer valid.
  use constant _bad_vsmg => defined &_vstring && (_vstring(~v0)||'') eq "v0";
  
  #
  # twist, toil and turn;
  # and recurse, of course.
  # sometimes sordidly;
  # and curse if no recourse.
  #
  sub _dump {
    my($s, $val, $name) = @_;
    my($out, $type, $id, $sname);
  
    $type = ref $val;
    $out = "";
  
    if ($type) {
  
      # Call the freezer method if it's specified and the object has the
      # method.  Trap errors and warn() instead of die()ing, like the XS
      # implementation.
      my $freezer = $s->{freezer};
      if ($freezer and UNIVERSAL::can($val, $freezer)) {
        eval { $val->$freezer() };
        warn "WARNING(Freezer method call failed): $@" if $@;
      }
  
      require Scalar::Util;
      my $realpack = Scalar::Util::blessed($val);
      my $realtype = $realpack ? Scalar::Util::reftype($val) : ref $val;
      $id = format_refaddr($val);
  
      # Note: By this point $name is always defined and of non-zero length.
      # Keep a tab on it so that we do not fall into recursive pit.
      if (exists $s->{seen}{$id}) {
        if ($s->{purity} and $s->{level} > 0) {
          $out = ($realtype eq 'HASH')  ? '{}' :
                 ($realtype eq 'ARRAY') ? '[]' :
                 'do{my $o}' ;
          push @post, $name . " = " . $s->{seen}{$id}[0];
        }
        else {
          $out = $s->{seen}{$id}[0];
          if ($name =~ /^([\@\%])/) {
            my $start = $1;
            if ($out =~ /^\\$start/) {
              $out = substr($out, 1);
            }
            else {
              $out = $start . '{' . $out . '}';
            }
          }
        }
        return $out;
      }
      else {
        # store our name
        $s->{seen}{$id} = [ (
            ($name =~ /^[@%]/)
              ? ('\\' . $name )
              : ($realtype eq 'CODE' and $name =~ /^[*](.*)$/)
                ? ('\\&' . $1 )
                : $name
          ), $val ];
      }
      my $no_bless = 0;
      my $is_regex = 0;
      if ( $realpack and ($] >= 5.009005 ? re::is_regexp($val) : $realpack eq 'Regexp') ) {
          $is_regex = 1;
          $no_bless = $realpack eq 'Regexp';
      }
  
      # If purity is not set and maxdepth is set, then check depth:
      # if we have reached maximum depth, return the string
      # representation of the thing we are currently examining
      # at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)').
      if (!$s->{purity}
        and defined($s->{maxdepth})
        and $s->{maxdepth} > 0
        and $s->{level} >= $s->{maxdepth})
      {
        return qq['$val'];
      }
  
      # avoid recursing infinitely [perl #122111]
      if ($s->{maxrecurse} > 0
          and $s->{level} >= $s->{maxrecurse}) {
          die "Recursion limit of $s->{maxrecurse} exceeded";
      }
  
      # we have a blessed ref
      my ($blesspad);
      if ($realpack and !$no_bless) {
        $out = $s->{'bless'} . '( ';
        $blesspad = $s->{apad};
        $s->{apad} .= '       ' if ($s->{indent} >= 2);
      }
  
      $s->{level}++;
      my $ipad = $s->{xpad} x $s->{level};
  
      if ($is_regex) {
          my $pat;
          my $flags = "";
          if (defined(*re::regexp_pattern{CODE})) {
            ($pat, $flags) = re::regexp_pattern($val);
          }
          else {
            $pat = "$val";
          }
          $pat =~ s <(\\.)|/> { $1 || '\\/' }ge;
          $out .= "qr/$pat/$flags";
      }
      elsif ($realtype eq 'SCALAR' || $realtype eq 'REF'
      || $realtype eq 'VSTRING') {
        if ($realpack) {
          $out .= 'do{\\(my $o = ' . $s->_dump($$val, "\${$name}") . ')}';
        }
        else {
          $out .= '\\' . $s->_dump($$val, "\${$name}");
        }
      }
      elsif ($realtype eq 'GLOB') {
        $out .= '\\' . $s->_dump($$val, "*{$name}");
      }
      elsif ($realtype eq 'ARRAY') {
        my($pad, $mname);
        my($i) = 0;
        $out .= ($name =~ /^\@/) ? '(' : '[';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        ($name =~ /^\@(.*)$/) ? ($mname = "\$" . $1) :
      # omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
          ($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
          ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        for my $v (@$val) {
          $sname = $mname . '[' . $i . ']';
          $out .= $pad . $ipad . '#' . $i
            if $s->{indent} >= 3;
          $out .= $pad . $ipad . $s->_dump($v, $sname);
          $out .= ","
              if $i++ < $#$val
              || ($s->{trailingcomma} && $s->{indent} >= 1);
        }
        $out .= $pad . ($s->{xpad} x ($s->{level} - 1)) if $i;
        $out .= ($name =~ /^\@/) ? ')' : ']';
      }
      elsif ($realtype eq 'HASH') {
        my ($k, $v, $pad, $lpad, $mname, $pair);
        $out .= ($name =~ /^\%/) ? '(' : '{';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        $lpad = $s->{apad};
        $pair = $s->{pair};
        ($name =~ /^\%(.*)$/) ? ($mname = "\$" . $1) :
      # omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
          ($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
          ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        my $sortkeys = defined($s->{sortkeys}) ? $s->{sortkeys} : '';
        my $keys = [];
        if ($sortkeys) {
          if (ref($s->{sortkeys}) eq 'CODE') {
            $keys = $s->{sortkeys}($val);
            unless (ref($keys) eq 'ARRAY') {
              carp "Sortkeys subroutine did not return ARRAYREF";
              $keys = [];
            }
          }
          else {
            $keys = [ sort keys %$val ];
          }
        }
  
        # Ensure hash iterator is reset
        keys(%$val);
  
        my $key;
        while (($k, $v) = ! $sortkeys ? (each %$val) :
           @$keys ? ($key = shift(@$keys), $val->{$key}) :
           () )
        {
          my $nk = $s->_dump($k, "");
  
          # _dump doesn't quote numbers of this form
          if ($s->{quotekeys} && $nk =~ /^(?:0|-?[1-9][0-9]{0,8})\z/) {
            $nk = $s->{useqq} ? qq("$nk") : qq('$nk');
          }
          elsif (!$s->{quotekeys} and $nk =~ /^[\"\']([A-Za-z_]\w*)[\"\']$/) {
            $nk = $1
          }
  
          $sname = $mname . '{' . $nk . '}';
          $out .= $pad . $ipad . $nk . $pair;
  
          # temporarily alter apad
          $s->{apad} .= (" " x (length($nk) + 4))
            if $s->{indent} >= 2;
          $out .= $s->_dump($val->{$k}, $sname) . ",";
          $s->{apad} = $lpad
            if $s->{indent} >= 2;
        }
        if (substr($out, -1) eq ',') {
          chop $out if !$s->{trailingcomma} || !$s->{indent};
          $out .= $pad . ($s->{xpad} x ($s->{level} - 1));
        }
        $out .= ($name =~ /^\%/) ? ')' : '}';
      }
      elsif ($realtype eq 'CODE') {
        if ($s->{deparse}) {
          require B::Deparse;
          my $sub =  'sub ' . (B::Deparse->new)->coderef2text($val);
          $pad    =  $s->{sep} . $s->{pad} . $s->{apad} . $s->{xpad} x ($s->{level} - 1);
          $sub    =~ s/\n/$pad/gse;
          $out   .=  $sub;
        }
        else {
          $out .= 'sub { "DUMMY" }';
          carp "Encountered CODE ref, using dummy placeholder" if $s->{purity};
        }
      }
      else {
        croak "Can't handle '$realtype' type";
      }
  
      if ($realpack and !$no_bless) { # we have a blessed ref
        $out .= ', ' . _quote($realpack) . ' )';
        $out .= '->' . $s->{toaster} . '()'
          if $s->{toaster} ne '';
        $s->{apad} = $blesspad;
      }
      $s->{level}--;
    }
    else {                                 # simple scalar
  
      my $ref = \$_[1];
      my $v;
      # first, catalog the scalar
      if ($name ne '') {
        $id = format_refaddr($ref);
        if (exists $s->{seen}{$id}) {
          if ($s->{seen}{$id}[2]) {
            $out = $s->{seen}{$id}[0];
            #warn "[<$out]\n";
            return "\${$out}";
          }
        }
        else {
          #warn "[>\\$name]\n";
          $s->{seen}{$id} = ["\\$name", $ref];
        }
      }
      $ref = \$val;
      if (ref($ref) eq 'GLOB') {  # glob
        my $name = substr($val, 1);
        if ($name =~ /^[A-Za-z_][\w:]*$/ && $name ne 'main::') {
          $name =~ s/^main::/::/;
          $sname = $name;
        }
        else {
          $sname = $s->_dump(
            $name eq 'main::' || $] < 5.007 && $name eq "main::\0"
              ? ''
              : $name,
            "",
          );
          $sname = '{' . $sname . '}';
        }
        if ($s->{purity}) {
          my $k;
          local ($s->{level}) = 0;
          for $k (qw(SCALAR ARRAY HASH)) {
            my $gval = *$val{$k};
            next unless defined $gval;
            next if $k eq "SCALAR" && ! defined $$gval;  # always there
  
            # _dump can push into @post, so we hold our place using $postlen
            my $postlen = scalar @post;
            $post[$postlen] = "\*$sname = ";
            local ($s->{apad}) = " " x length($post[$postlen]) if $s->{indent} >= 2;
            $post[$postlen] .= $s->_dump($gval, "\*$sname\{$k\}");
          }
        }
        $out .= '*' . $sname;
      }
      elsif (!defined($val)) {
        $out .= "undef";
      }
      elsif (defined &_vstring and $v = _vstring($val)
        and !_bad_vsmg || eval $v eq $val) {
        $out .= $v;
      }
      elsif (!defined &_vstring
         and ref $ref eq 'VSTRING' || eval{Scalar::Util::isvstring($val)}) {
        $out .= sprintf "%vd", $val;
      }
      # \d here would treat "1\x{660}" as a safe decimal number
      elsif ($val =~ /^(?:0|-?[1-9][0-9]{0,8})\z/) { # safe decimal number
        $out .= $val;
      }
      else {                 # string
        if ($s->{useqq} or $val =~ tr/\0-\377//c) {
          # Fall back to qq if there's Unicode
          $out .= qquote($val, $s->{useqq});
        }
        else {
          $out .= _quote($val);
        }
      }
    }
    if ($id) {
      # if we made it this far, $id was added to seen list at current
      # level, so remove it to get deep copies
      if ($s->{deepcopy}) {
        delete($s->{seen}{$id});
      }
      elsif ($name) {
        $s->{seen}{$id}[2] = 1;
      }
    }
    return $out;
  }
  
  #
  # non-OO style of earlier version
  #
  sub Dumper {
    return Data::Dumper->Dump([@_]);
  }
  
  # compat stub
  sub DumperX {
    return Data::Dumper->Dumpxs([@_], []);
  }
  
  #
  # reset the "seen" cache
  #
  sub Reset {
    my($s) = shift;
    $s->{seen} = {};
    return $s;
  }
  
  sub Indent {
    my($s, $v) = @_;
    if (defined($v)) {
      if ($v == 0) {
        $s->{xpad} = "";
        $s->{sep} = "";
      }
      else {
        $s->{xpad} = "  ";
        $s->{sep} = "\n";
      }
      $s->{indent} = $v;
      return $s;
    }
    else {
      return $s->{indent};
    }
  }
  
  sub Trailingcomma {
    my($s, $v) = @_;
    defined($v) ? (($s->{trailingcomma} = $v), return $s) : $s->{trailingcomma};
  }
  
  sub Pair {
      my($s, $v) = @_;
      defined($v) ? (($s->{pair} = $v), return $s) : $s->{pair};
  }
  
  sub Pad {
    my($s, $v) = @_;
    defined($v) ? (($s->{pad} = $v), return $s) : $s->{pad};
  }
  
  sub Varname {
    my($s, $v) = @_;
    defined($v) ? (($s->{varname} = $v), return $s) : $s->{varname};
  }
  
  sub Purity {
    my($s, $v) = @_;
    defined($v) ? (($s->{purity} = $v), return $s) : $s->{purity};
  }
  
  sub Useqq {
    my($s, $v) = @_;
    defined($v) ? (($s->{useqq} = $v), return $s) : $s->{useqq};
  }
  
  sub Terse {
    my($s, $v) = @_;
    defined($v) ? (($s->{terse} = $v), return $s) : $s->{terse};
  }
  
  sub Freezer {
    my($s, $v) = @_;
    defined($v) ? (($s->{freezer} = $v), return $s) : $s->{freezer};
  }
  
  sub Toaster {
    my($s, $v) = @_;
    defined($v) ? (($s->{toaster} = $v), return $s) : $s->{toaster};
  }
  
  sub Deepcopy {
    my($s, $v) = @_;
    defined($v) ? (($s->{deepcopy} = $v), return $s) : $s->{deepcopy};
  }
  
  sub Quotekeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{quotekeys} = $v), return $s) : $s->{quotekeys};
  }
  
  sub Bless {
    my($s, $v) = @_;
    defined($v) ? (($s->{'bless'} = $v), return $s) : $s->{'bless'};
  }
  
  sub Maxdepth {
    my($s, $v) = @_;
    defined($v) ? (($s->{'maxdepth'} = $v), return $s) : $s->{'maxdepth'};
  }
  
  sub Maxrecurse {
    my($s, $v) = @_;
    defined($v) ? (($s->{'maxrecurse'} = $v), return $s) : $s->{'maxrecurse'};
  }
  
  sub Useperl {
    my($s, $v) = @_;
    defined($v) ? (($s->{'useperl'} = $v), return $s) : $s->{'useperl'};
  }
  
  sub Sortkeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{'sortkeys'} = $v), return $s) : $s->{'sortkeys'};
  }
  
  sub Deparse {
    my($s, $v) = @_;
    defined($v) ? (($s->{'deparse'} = $v), return $s) : $s->{'deparse'};
  }
  
  sub Sparseseen {
    my($s, $v) = @_;
    defined($v) ? (($s->{'noseen'} = $v), return $s) : $s->{'noseen'};
  }
  
  # used by qquote below
  my %esc = (
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  my $low_controls = ($IS_ASCII)
  
                     # This includes \177, because traditionally it has been
                     # output as octal, even though it isn't really a "low"
                     # control
                     ? qr/[\0-\x1f\177]/
  
                       # EBCDIC low controls.
                     : qr/[\0-\x3f]/;
  
  # put a string value in double quotes
  sub qquote {
    local($_) = shift;
    s/([\\\"\@\$])/\\$1/g;
  
    # This efficiently changes the high ordinal characters to \x{} if the utf8
    # flag is on.  On ASCII platforms, the high ordinals are all the
    # non-ASCII's.  On EBCDIC platforms, we don't include in these the non-ASCII
    # controls whose ordinals are less than SPACE, excluded below by the range
    # \0-\x3f.  On ASCII platforms this range just compiles as part of :ascii:.
    # On EBCDIC platforms, there is just one outlier high ordinal control, and
    # it gets output as \x{}.
    my $bytes; { use bytes; $bytes = length }
    s/([^[:ascii:]\0-\x3f])/sprintf("\\x{%x}",ord($1))/ge
      if $bytes > length
  
         # The above doesn't get the EBCDIC outlier high ordinal control when
         # the string is UTF-8 but there are no UTF-8 variant characters in it.
         # We want that to come out as \x{} anyway.  We need is_utf8() to do
         # this.
         || (! $IS_ASCII && $] ge 5.008_001 && utf8::is_utf8($_));
  
    return qq("$_") unless /[[:^print:]]/;  # fast exit if only printables
  
    # Here, there is at least one non-printable to output.  First, translate the
    # escapes.
    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
    # no need for 3 digits in escape for octals not followed by a digit.
    s/($low_controls)(?!\d)/'\\'.sprintf('%o',ord($1))/eg;
  
    # But otherwise use 3 digits
    s/($low_controls)/'\\'.sprintf('%03o',ord($1))/eg;
  
      # all but last branch below not supported --BEHAVIOR SUBJECT TO CHANGE--
    my $high = shift || "";
      if ($high eq "iso8859") {   # Doesn't escape the Latin1 printables
        if ($IS_ASCII) {
          s/([\200-\240])/'\\'.sprintf('%o',ord($1))/eg;
        }
        elsif ($] ge 5.007_003) {
          my $high_control = utf8::unicode_to_native(0x9F);
          s/$high_control/sprintf('\\%o',ord($1))/eg;
        }
      } elsif ($high eq "utf8") {
  #     Some discussion of what to do here is in
  #       https://rt.perl.org/Ticket/Display.html?id=113088
  #     use utf8;
  #     $str =~ s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      } elsif ($high eq "8bit") {
          # leave it as it is
      } else {
        s/([[:^ascii:]])/'\\'.sprintf('%03o',ord($1))/eg;
        #s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      }
  
    return qq("$_");
  }
  
  # helper sub to sort hash keys in Perl < 5.8.0 where we don't have
  # access to sortsv() from XS
  sub _sortkeys { [ sort keys %{$_[0]} ] }
  
  sub _refine_name {
      my $s = shift;
      my ($name, $val, $i) = @_;
      if (defined $name) {
        if ($name =~ /^[*](.*)$/) {
          if (defined $val) {
              $name = (ref $val eq 'ARRAY') ? ( "\@" . $1 ) :
                (ref $val eq 'HASH')  ? ( "\%" . $1 ) :
                (ref $val eq 'CODE')  ? ( "\*" . $1 ) :
                ( "\$" . $1 ) ;
          }
          else {
            $name = "\$" . $1;
          }
        }
        elsif ($name !~ /^\$/) {
          $name = "\$" . $name;
        }
      }
      else { # no names provided
        $name = "\$" . $s->{varname} . $i;
      }
      return $name;
  }
  
  sub _compose_out {
      my $s = shift;
      my ($valstr, $postref) = @_;
      my $out = "";
      $out .= $s->{pad} . $valstr . $s->{sep};
      if (@{$postref}) {
          $out .= $s->{pad} .
              join(';' . $s->{sep} . $s->{pad}, @{$postref}) .
              ';' .
              $s->{sep};
      }
      return $out;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Dumper - stringified perl data structures, suitable for both printing and C<eval>
  
  =head1 SYNOPSIS
  
      use Data::Dumper;
  
      # simple procedural interface
      print Dumper($foo, $bar);
  
      # extended usage with names
      print Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
  
      # configuration variables
      {
        local $Data::Dumper::Purity = 1;
        eval Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
      }
  
      # OO usage
      $d = Data::Dumper->new([$foo, $bar], [qw(foo *ary)]);
         ...
      print $d->Dump;
         ...
      $d->Purity(1)->Terse(1)->Deepcopy(1);
      eval $d->Dump;
  
  
  =head1 DESCRIPTION
  
  Given a list of scalars or reference variables, writes out their contents in
  perl syntax. The references can also be objects.  The content of each
  variable is output in a single Perl statement.  Handles self-referential
  structures correctly.
  
  The return value can be C<eval>ed to get back an identical copy of the
  original reference structure.  (Please do consider the security implications
  of eval'ing code from untrusted sources!)
  
  Any references that are the same as one of those passed in will be named
  C<$VAR>I<n> (where I<n> is a numeric suffix), and other duplicate references
  to substructures within C<$VAR>I<n> will be appropriately labeled using arrow
  notation.  You can specify names for individual values to be dumped if you
  use the C<Dump()> method, or you can change the default C<$VAR> prefix to
  something else.  See C<$Data::Dumper::Varname> and C<$Data::Dumper::Terse>
  below.
  
  The default output of self-referential structures can be C<eval>ed, but the
  nested references to C<$VAR>I<n> will be undefined, since a recursive
  structure cannot be constructed using one Perl statement.  You should set the
  C<Purity> flag to 1 to get additional statements that will correctly fill in
  these references.  Moreover, if C<eval>ed when strictures are in effect,
  you need to ensure that any variables it accesses are previously declared.
  
  In the extended usage form, the references to be dumped can be given
  user-specified names.  If a name begins with a C<*>, the output will
  describe the dereferenced type of the supplied reference for hashes and
  arrays, and coderefs.  Output of names will be avoided where possible if
  the C<Terse> flag is set.
  
  In many cases, methods that are used to set the internal state of the
  object will return the object itself, so method calls can be conveniently
  chained together.
  
  Several styles of output are possible, all controlled by setting
  the C<Indent> flag.  See L<Configuration Variables or Methods> below
  for details.
  
  
  =head2 Methods
  
  =over 4
  
  =item I<PACKAGE>->new(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns a newly created C<Data::Dumper> object.  The first argument is an
  anonymous array of values to be dumped.  The optional second argument is an
  anonymous array of names for the values.  The names need not have a leading
  C<$> sign, and must be comprised of alphanumeric characters.  You can begin
  a name with a C<*> to specify that the dereferenced type must be dumped
  instead of the reference itself, for ARRAY and HASH references.
  
  The prefix specified by C<$Data::Dumper::Varname> will be used with a
  numeric suffix if the name for a value is undefined.
  
  Data::Dumper will catalog all references encountered while dumping the
  values. Cross-references (in the form of names of substructures in perl
  syntax) will be inserted at all possible points, preserving any structural
  interdependencies in the original set of values.  Structure traversal is
  depth-first,  and proceeds in order from the first supplied value to
  the last.
  
  =item I<$OBJ>->Dump  I<or>  I<PACKAGE>->Dump(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns the stringified form of the values stored in the object (preserving
  the order in which they were supplied to C<new>), subject to the
  configuration options below.  In a list context, it returns a list
  of strings corresponding to the supplied values.
  
  The second form, for convenience, simply calls the C<new> method on its
  arguments before dumping the object immediately.
  
  =item I<$OBJ>->Seen(I<[HASHREF]>)
  
  Queries or adds to the internal table of already encountered references.
  You must use C<Reset> to explicitly clear the table if needed.  Such
  references are not dumped; instead, their names are inserted wherever they
  are encountered subsequently.  This is useful especially for properly
  dumping subroutine references.
  
  Expects an anonymous hash of name => value pairs.  Same rules apply for names
  as in C<new>.  If no argument is supplied, will return the "seen" list of
  name => value pairs, in a list context.  Otherwise, returns the object
  itself.
  
  =item I<$OBJ>->Values(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of values that will be dumped.  When
  called without arguments, returns the values as a list.  When called with a
  reference to an array of replacement values, returns the object itself.  When
  called with any other type of argument, dies.
  
  =item I<$OBJ>->Names(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of user supplied names for the values
  that will be dumped.  When called without arguments, returns the names.  When
  called with an array of replacement names, returns the object itself.  If the
  number of replacement names exceeds the number of values to be named, the
  excess names will not be used.  If the number of replacement names falls short
  of the number of values to be named, the list of replacement names will be
  exhausted and remaining values will not be renamed.  When
  called with any other type of argument, dies.
  
  =item I<$OBJ>->Reset
  
  Clears the internal table of "seen" references and returns the object
  itself.
  
  =back
  
  =head2 Functions
  
  =over 4
  
  =item Dumper(I<LIST>)
  
  Returns the stringified form of the values in the list, subject to the
  configuration options below.  The values will be named C<$VAR>I<n> in the
  output, where I<n> is a numeric suffix.  Will return a list of strings
  in a list context.
  
  =back
  
  =head2 Configuration Variables or Methods
  
  Several configuration variables can be used to control the kind of output
  generated when using the procedural interface.  These variables are usually
  C<local>ized in a block so that other parts of the code are not affected by
  the change.
  
  These variables determine the default state of the object created by calling
  the C<new> method, but cannot be used to alter the state of the object
  thereafter.  The equivalent method names should be used instead to query
  or set the internal state of the object.
  
  The method forms return the object itself when called with arguments,
  so that they can be chained together nicely.
  
  =over 4
  
  =item *
  
  $Data::Dumper::Indent  I<or>  I<$OBJ>->Indent(I<[NEWVAL]>)
  
  Controls the style of indentation.  It can be set to 0, 1, 2 or 3.  Style 0
  spews output without any newlines, indentation, or spaces between list
  items.  It is the most compact format possible that can still be called
  valid perl.  Style 1 outputs a readable form with newlines but no fancy
  indentation (each level in the structure is simply indented by a fixed
  amount of whitespace).  Style 2 (the default) outputs a very readable form
  which takes into account the length of hash keys (so the hash value lines
  up).  Style 3 is like style 2, but also annotates the elements of arrays
  with their index (but the comment is on its own line, so array output
  consumes twice the number of lines).  Style 2 is the default.
  
  =item *
  
  $Data::Dumper::Trailingcomma  I<or>  I<$OBJ>->Trailingcomma(I<[NEWVAL]>)
  
  Controls whether a comma is added after the last element of an array or
  hash. Even when true, no comma is added between the last element of an array
  or hash and a closing bracket when they appear on the same line. The default
  is false.
  
  =item *
  
  $Data::Dumper::Purity  I<or>  I<$OBJ>->Purity(I<[NEWVAL]>)
  
  Controls the degree to which the output can be C<eval>ed to recreate the
  supplied reference structures.  Setting it to 1 will output additional perl
  statements that will correctly recreate nested references.  The default is
  0.
  
  =item *
  
  $Data::Dumper::Pad  I<or>  I<$OBJ>->Pad(I<[NEWVAL]>)
  
  Specifies the string that will be prefixed to every line of the output.
  Empty string by default.
  
  =item *
  
  $Data::Dumper::Varname  I<or>  I<$OBJ>->Varname(I<[NEWVAL]>)
  
  Contains the prefix to use for tagging variable names in the output. The
  default is "VAR".
  
  =item *
  
  $Data::Dumper::Useqq  I<or>  I<$OBJ>->Useqq(I<[NEWVAL]>)
  
  When set, enables the use of double quotes for representing string values.
  Whitespace other than space will be represented as C<[\n\t\r]>, "unsafe"
  characters will be backslashed, and unprintable characters will be output as
  quoted octal integers.  The default is 0.
  
  =item *
  
  $Data::Dumper::Terse  I<or>  I<$OBJ>->Terse(I<[NEWVAL]>)
  
  When set, Data::Dumper will emit single, non-self-referential values as
  atoms/terms rather than statements.  This means that the C<$VAR>I<n> names
  will be avoided where possible, but be advised that such output may not
  always be parseable by C<eval>.
  
  =item *
  
  $Data::Dumper::Freezer  I<or>  $I<OBJ>->Freezer(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will invoke that method via the object before attempting to
  stringify it.  This method can alter the contents of the object (if, for
  instance, it contains data allocated from C), and even rebless it in a
  different package.  The client is responsible for making sure the specified
  method can be called via the object, and that the object ends up containing
  only perl data types after the method has been called.  Defaults to an empty
  string.
  
  If an object does not support the method specified (determined using
  UNIVERSAL::can()) then the call will be skipped.  If the method dies a
  warning will be generated.
  
  =item *
  
  $Data::Dumper::Toaster  I<or>  $I<OBJ>->Toaster(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will emit a method call for any objects that are to be dumped
  using the syntax C<bless(DATA, CLASS)-E<gt>METHOD()>.  Note that this means that
  the method specified will have to perform any modifications required on the
  object (like creating new state within it, and/or reblessing it in a
  different package) and then return it.  The client is responsible for making
  sure the method can be called via the object, and that it returns a valid
  object.  Defaults to an empty string.
  
  =item *
  
  $Data::Dumper::Deepcopy  I<or>  $I<OBJ>->Deepcopy(I<[NEWVAL]>)
  
  Can be set to a boolean value to enable deep copies of structures.
  Cross-referencing will then only be done when absolutely essential
  (i.e., to break reference cycles).  Default is 0.
  
  =item *
  
  $Data::Dumper::Quotekeys  I<or>  $I<OBJ>->Quotekeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are quoted.
  A defined false value will avoid quoting hash keys when it looks like a simple
  string.  Default is 1, which will always enclose hash keys in quotes.
  
  =item *
  
  $Data::Dumper::Bless  I<or>  $I<OBJ>->Bless(I<[NEWVAL]>)
  
  Can be set to a string that specifies an alternative to the C<bless>
  builtin operator used to create objects.  A function with the specified
  name should exist, and should accept the same arguments as the builtin.
  Default is C<bless>.
  
  =item *
  
  $Data::Dumper::Pair  I<or>  $I<OBJ>->Pair(I<[NEWVAL]>)
  
  Can be set to a string that specifies the separator between hash keys
  and values. To dump nested hash, array and scalar values to JavaScript,
  use: C<$Data::Dumper::Pair = ' : ';>. Implementing C<bless> in JavaScript
  is left as an exercise for the reader.
  A function with the specified name exists, and accepts the same arguments
  as the builtin.
  
  Default is: C< =E<gt> >.
  
  =item *
  
  $Data::Dumper::Maxdepth  I<or>  $I<OBJ>->Maxdepth(I<[NEWVAL]>)
  
  Can be set to a positive integer that specifies the depth beyond which
  we don't venture into a structure.  Has no effect when
  C<Data::Dumper::Purity> is set.  (Useful in debugger when we often don't
  want to see more than enough).  Default is 0, which means there is
  no maximum depth.
  
  =item *
  
  $Data::Dumper::Maxrecurse  I<or>  $I<OBJ>->Maxrecurse(I<[NEWVAL]>)
  
  Can be set to a positive integer that specifies the depth beyond which
  recursion into a structure will throw an exception.  This is intended
  as a security measure to prevent perl running out of stack space when
  dumping an excessively deep structure.  Can be set to 0 to remove the
  limit.  Default is 1000.
  
  =item *
  
  $Data::Dumper::Useperl  I<or>  $I<OBJ>->Useperl(I<[NEWVAL]>)
  
  Can be set to a boolean value which controls whether the pure Perl
  implementation of C<Data::Dumper> is used. The C<Data::Dumper> module is
  a dual implementation, with almost all functionality written in both
  pure Perl and also in XS ('C'). Since the XS version is much faster, it
  will always be used if possible. This option lets you override the
  default behavior, usually for testing purposes only. Default is 0, which
  means the XS implementation will be used if possible.
  
  =item *
  
  $Data::Dumper::Sortkeys  I<or>  $I<OBJ>->Sortkeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are dumped in
  sorted order. A true value will cause the keys of all hashes to be
  dumped in Perl's default sort order. Can also be set to a subroutine
  reference which will be called for each hash that is dumped. In this
  case C<Data::Dumper> will call the subroutine once for each hash,
  passing it the reference of the hash. The purpose of the subroutine is
  to return a reference to an array of the keys that will be dumped, in
  the order that they should be dumped. Using this feature, you can
  control both the order of the keys, and which keys are actually used. In
  other words, this subroutine acts as a filter by which you can exclude
  certain keys from being dumped. Default is 0, which means that hash keys
  are not sorted.
  
  =item *
  
  $Data::Dumper::Deparse  I<or>  $I<OBJ>->Deparse(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether code references are
  turned into perl source code. If set to a true value, C<B::Deparse>
  will be used to get the source of the code reference. Using this option
  will force using the Perl implementation of the dumper, since the fast
  XSUB implementation doesn't support it.
  
  Caution : use this option only if you know that your coderefs will be
  properly reconstructed by C<B::Deparse>.
  
  =item *
  
  $Data::Dumper::Sparseseen I<or>  $I<OBJ>->Sparseseen(I<[NEWVAL]>)
  
  By default, Data::Dumper builds up the "seen" hash of scalars that
  it has encountered during serialization. This is very expensive.
  This seen hash is necessary to support and even just detect circular
  references. It is exposed to the user via the C<Seen()> call both
  for writing and reading.
  
  If you, as a user, do not need explicit access to the "seen" hash,
  then you can set the C<Sparseseen> option to allow Data::Dumper
  to eschew building the "seen" hash for scalars that are known not
  to possess more than one reference. This speeds up serialization
  considerably if you use the XS implementation.
  
  Note: If you turn on C<Sparseseen>, then you must not rely on the
  content of the seen hash since its contents will be an
  implementation detail!
  
  =back
  
  =head2 Exports
  
  =over 4
  
  =item Dumper
  
  =back
  
  =head1 EXAMPLES
  
  Run these code snippets to get a quick feel for the behavior of this
  module.  When you are through with these examples, you may want to
  add or change the various configuration variables described above,
  to see their behavior.  (See the testsuite in the Data::Dumper
  distribution for more examples.)
  
  
      use Data::Dumper;
  
      package Foo;
      sub new {bless {'a' => 1, 'b' => sub { return "foo" }}, $_[0]};
  
      package Fuz;                       # a weird REF-REF-SCALAR object
      sub new {bless \($_ = \ 'fu\'z'), $_[0]};
  
      package main;
      $foo = Foo->new;
      $fuz = Fuz->new;
      $boo = [ 1, [], "abcd", \*foo,
               {1 => 'a', 023 => 'b', 0x45 => 'c'},
               \\"p\q\'r", $foo, $fuz];
  
      ########
      # simple usage
      ########
  
      $bar = eval(Dumper($boo));
      print($@) if $@;
      print Dumper($boo), Dumper($bar);  # pretty print (no array indices)
  
      $Data::Dumper::Terse = 1;        # don't output names where feasible
      $Data::Dumper::Indent = 0;       # turn off all pretty print
      print Dumper($boo), "\n";
  
      $Data::Dumper::Indent = 1;       # mild pretty print
      print Dumper($boo);
  
      $Data::Dumper::Indent = 3;       # pretty print with array indices
      print Dumper($boo);
  
      $Data::Dumper::Useqq = 1;        # print strings in double quotes
      print Dumper($boo);
  
      $Data::Dumper::Pair = " : ";     # specify hash key/value separator
      print Dumper($boo);
  
  
      ########
      # recursive structures
      ########
  
      @c = ('c');
      $c = \@c;
      $b = {};
      $a = [1, $b, $c];
      $b->{a} = $a;
      $b->{b} = $a->[1];
      $b->{c} = $a->[2];
      print Data::Dumper->Dump([$a,$b,$c], [qw(a b c)]);
  
  
      $Data::Dumper::Purity = 1;         # fill in the holes for eval
      print Data::Dumper->Dump([$a, $b], [qw(*a b)]); # print as @a
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]); # print as %b
  
  
      $Data::Dumper::Deepcopy = 1;       # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
  
      $Data::Dumper::Purity = 0;         # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
      ########
      # deep structures
      ########
  
      $a = "pearl";
      $b = [ $a ];
      $c = { 'b' => $b };
      $d = [ $c ];
      $e = { 'd' => $d };
      $f = { 'e' => $e };
      print Data::Dumper->Dump([$f], [qw(f)]);
  
      $Data::Dumper::Maxdepth = 3;       # no deeper than 3 refs down
      print Data::Dumper->Dump([$f], [qw(f)]);
  
  
      ########
      # object-oriented usage
      ########
  
      $d = Data::Dumper->new([$a,$b], [qw(a b)]);
      $d->Seen({'*c' => $c});            # stash a ref without printing it
      $d->Indent(3);
      print $d->Dump;
      $d->Reset->Purity(0);              # empty the seen cache
      print join "----\n", $d->Dump;
  
  
      ########
      # persistence
      ########
  
      package Foo;
      sub new { bless { state => 'awake' }, shift }
      sub Freeze {
          my $s = shift;
          print STDERR "preparing to sleep\n";
          $s->{state} = 'asleep';
          return bless $s, 'Foo::ZZZ';
      }
  
      package Foo::ZZZ;
      sub Thaw {
          my $s = shift;
          print STDERR "waking up\n";
          $s->{state} = 'awake';
          return bless $s, 'Foo';
      }
  
      package main;
      use Data::Dumper;
      $a = Foo->new;
      $b = Data::Dumper->new([$a], ['c']);
      $b->Freezer('Freeze');
      $b->Toaster('Thaw');
      $c = $b->Dump;
      print $c;
      $d = eval $c;
      print Data::Dumper->Dump([$d], ['d']);
  
  
      ########
      # symbol substitution (useful for recreating CODE refs)
      ########
  
      sub foo { print "foo speaking\n" }
      *other = \&foo;
      $bar = [ \&other ];
      $d = Data::Dumper->new([\&other,$bar],['*other','bar']);
      $d->Seen({ '*foo' => \&foo });
      print $d->Dump;
  
  
      ########
      # sorting and filtering hash keys
      ########
  
      $Data::Dumper::Sortkeys = \&my_filter;
      my $foo = { map { (ord, "$_$_$_") } 'I'..'Q' };
      my $bar = { %$foo };
      my $baz = { reverse %$foo };
      print Dumper [ $foo, $bar, $baz ];
  
      sub my_filter {
          my ($hash) = @_;
          # return an array ref containing the hash keys to dump
          # in the order that you want them to be dumped
          return [
            # Sort the keys of %$foo in reverse numeric order
              $hash eq $foo ? (sort {$b <=> $a} keys %$hash) :
            # Only dump the odd number keys of %$bar
              $hash eq $bar ? (grep {$_ % 2} keys %$hash) :
            # Sort keys in default order for all other hashes
              (sort keys %$hash)
          ];
      }
  
  =head1 BUGS
  
  Due to limitations of Perl subroutine call semantics, you cannot pass an
  array or hash.  Prepend it with a C<\> to pass its reference instead.  This
  will be remedied in time, now that Perl has subroutine prototypes.
  For now, you need to use the extended usage form, and prepend the
  name with a C<*> to output it as a hash or array.
  
  C<Data::Dumper> cheats with CODE references.  If a code reference is
  encountered in the structure being processed (and if you haven't set
  the C<Deparse> flag), an anonymous subroutine that
  contains the string '"DUMMY"' will be inserted in its place, and a warning
  will be printed if C<Purity> is set.  You can C<eval> the result, but bear
  in mind that the anonymous sub that gets created is just a placeholder.
  Someday, perl will have a switch to cache-on-demand the string
  representation of a compiled piece of code, I hope.  If you have prior
  knowledge of all the code refs that your data structures are likely
  to have, you can use the C<Seen> method to pre-seed the internal reference
  table and make the dumped output point to them, instead.  See L</EXAMPLES>
  above.
  
  The C<Deparse> flag makes Dump() run slower, since the XSUB
  implementation does not support it.
  
  SCALAR objects have the weirdest looking C<bless> workaround.
  
  Pure Perl version of C<Data::Dumper> escapes UTF-8 strings correctly
  only in Perl 5.8.0 and later.
  
  =head2 NOTE
  
  Starting from Perl 5.8.1 different runs of Perl will have different
  ordering of hash keys.  The change was done for greater security,
  see L<perlsec/"Algorithmic Complexity Attacks">.  This means that
  different runs of Perl will have different Data::Dumper outputs if
  the data contains hashes.  If you need to have identical Data::Dumper
  outputs from different runs of Perl, use the environment variable
  PERL_HASH_SEED, see L<perlrun/PERL_HASH_SEED>.  Using this restores
  the old (platform-specific) ordering: an even prettier solution might
  be to use the C<Sortkeys> filter of Data::Dumper.
  
  =head1 AUTHOR
  
  Gurusamy Sarathy        gsar@activestate.com
  
  Copyright (c) 1996-2016 Gurusamy Sarathy. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 VERSION
  
  Version 2.161  (July 11 2016)
  
  =head1 SEE ALSO
  
  perl(1)
  
  =cut
DARWIN-2LEVEL_DATA_DUMPER

$fatpacked{"darwin-2level/Encode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE';
  #
  # $Id: Encode.pm,v 2.88 2016/11/29 23:30:30 dankogai Exp dankogai $
  #
  package Encode;
  use strict;
  use warnings;
  our $VERSION = sprintf "%d.%02d", q$Revision: 2.88 $ =~ /(\d+)/g;
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  use XSLoader ();
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Exporter 5.57 'import';
  
  # Public, encouraged API is exported by default
  
  our @EXPORT = qw(
    decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str
    encodings  find_encoding find_mime_encoding clone_encoding
  );
  our @FB_FLAGS = qw(
    DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
    PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL
  );
  our @FB_CONSTS = qw(
    FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
    FB_PERLQQ FB_HTMLCREF FB_XMLCREF
  );
  our @EXPORT_OK = (
      qw(
        _utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
        is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
        ),
      @FB_FLAGS, @FB_CONSTS,
  );
  
  our %EXPORT_TAGS = (
      all          => [ @EXPORT,    @EXPORT_OK ],
      default      => [ @EXPORT ],
      fallbacks    => [ @FB_CONSTS ],
      fallback_all => [ @FB_CONSTS, @FB_FLAGS ],
  );
  
  # Documentation moved after __END__ for speed - NI-S
  
  our $ON_EBCDIC = ( ord("A") == 193 );
  
  use Encode::Alias;
  
  # Make a %Encoding package variable to allow a certain amount of cheating
  our %Encoding;
  our %ExtModule;
  require Encode::Config;
  #  See
  #  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2
  #  to find why sig handlers inside eval{} are disabled.
  eval {
      local $SIG{__DIE__};
      local $SIG{__WARN__};
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      require Encode::ConfigLocal;
  };
  
  sub encodings {
      my %enc;
      my $arg  = $_[1] || '';
      if ( $arg eq ":all" ) {
          %enc = ( %Encoding, %ExtModule );
      }
      else {
          %enc = %Encoding;
          for my $mod ( map { m/::/ ? $_ : "Encode::$_" } @_ ) {
              DEBUG and warn $mod;
              for my $enc ( keys %ExtModule ) {
                  $ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
              }
          }
      }
      return sort { lc $a cmp lc $b }
        grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;
  }
  
  sub perlio_ok {
      my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );
      $obj->can("perlio_ok") and return $obj->perlio_ok();
      return 0;    # safety net
  }
  
  sub define_encoding {
      my $obj  = shift;
      my $name = shift;
      $Encoding{$name} = $obj;
      my $lc = lc($name);
      define_alias( $lc => $obj ) unless $lc eq $name;
      while (@_) {
          my $alias = shift;
          define_alias( $alias, $obj );
      }
      return $obj;
  }
  
  sub getEncoding {
      my ( $class, $name, $skip_external ) = @_;
  
      defined($name) or return;
  
      $name =~ s/\s+//g; # https://rt.cpan.org/Ticket/Display.html?id=65796
  
      ref($name) && $name->can('renew') and return $name;
      exists $Encoding{$name} and return $Encoding{$name};
      my $lc = lc $name;
      exists $Encoding{$lc} and return $Encoding{$lc};
  
      my $oc = $class->find_alias($name);
      defined($oc) and return $oc;
      $lc ne $name and $oc = $class->find_alias($lc);
      defined($oc) and return $oc;
  
      unless ($skip_external) {
          if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {
              $mod =~ s,::,/,g;
              $mod .= '.pm';
              eval { require $mod; };
              exists $Encoding{$name} and return $Encoding{$name};
          }
      }
      return;
  }
  
  sub find_encoding($;$) {
      my ( $name, $skip_external ) = @_;
      return __PACKAGE__->getEncoding( $name, $skip_external );
  }
  
  sub find_mime_encoding($;$) {
      my ( $mime_name, $skip_external ) = @_;
      eval { require Encode::MIME::Name; };
      $@ and return;
      my $name = Encode::MIME::Name::get_encode_name( $mime_name );
      return find_encoding( $name, $skip_external );
  }
  
  sub resolve_alias($) {
      my $obj = find_encoding(shift);
      defined $obj and return $obj->name;
      return;
  }
  
  sub clone_encoding($) {
      my $obj = find_encoding(shift);
      ref $obj or return;
      eval { require Storable };
      $@ and return;
      return Storable::dclone($obj);
  }
  
  sub encode($$;$) {
      my ( $name, $string, $check ) = @_;
      return undef unless defined $string;
      $string .= '';    # stringify;
      $check ||= 0;
      unless ( defined $name ) {
          require Carp;
          Carp::croak("Encoding name should not be undef");
      }
      my $enc = find_encoding($name);
      unless ( defined $enc ) {
          require Carp;
          Carp::croak("Unknown encoding '$name'");
      }
      # For Unicode, warnings need to be caught and re-issued at this level
      # so that callers can disable utf8 warnings lexically.
      my $octets;
      if ( ref($enc) eq 'Encode::Unicode' ) {
          my $warn = '';
          {
              local $SIG{__WARN__} = sub { $warn = shift };
              $octets = $enc->encode( $string, $check );
          }
          warnings::warnif('utf8', $warn) if length $warn;
      }
      else {
          $octets = $enc->encode( $string, $check );
      }
      $_[1] = $string if $check and !ref $check and !( $check & LEAVE_SRC() );
      return $octets;
  }
  *str2bytes = \&encode;
  
  sub decode($$;$) {
      my ( $name, $octets, $check ) = @_;
      return undef unless defined $octets;
      $octets .= '';
      $check ||= 0;
      my $enc = find_encoding($name);
      unless ( defined $enc ) {
          require Carp;
          Carp::croak("Unknown encoding '$name'");
      }
      # For Unicode, warnings need to be caught and re-issued at this level
      # so that callers can disable utf8 warnings lexically.
      my $string;
      if ( ref($enc) eq 'Encode::Unicode' ) {
          my $warn = '';
          {
              local $SIG{__WARN__} = sub { $warn = shift };
              $string = $enc->decode( $octets, $check );
          }
          warnings::warnif('utf8', $warn) if length $warn;
      }
      else {
          $string = $enc->decode( $octets, $check );
      }
      $_[1] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
      return $string;
  }
  *bytes2str = \&decode;
  
  sub from_to($$$;$) {
      my ( $string, $from, $to, $check ) = @_;
      return undef unless defined $string;
      $check ||= 0;
      my $f = find_encoding($from);
      unless ( defined $f ) {
          require Carp;
          Carp::croak("Unknown encoding '$from'");
      }
      my $t = find_encoding($to);
      unless ( defined $t ) {
          require Carp;
          Carp::croak("Unknown encoding '$to'");
      }
  
      # For Unicode, warnings need to be caught and re-issued at this level
      # so that callers can disable utf8 warnings lexically.
      my $uni;
      if ( ref($f) eq 'Encode::Unicode' ) {
          my $warn = '';
          {
              local $SIG{__WARN__} = sub { $warn = shift };
              $uni = $f->decode($string);
          }
          warnings::warnif('utf8', $warn) if length $warn;
      }
      else {
          $uni = $f->decode($string);
      }
  
      if ( ref($t) eq 'Encode::Unicode' ) {
          my $warn = '';
          {
              local $SIG{__WARN__} = sub { $warn = shift };
              $_[0] = $string = $t->encode( $uni, $check );
          }
          warnings::warnif('utf8', $warn) if length $warn;
      }
      else {
          $_[0] = $string = $t->encode( $uni, $check );
      }
  
      return undef if ( $check && length($uni) );
      return defined( $_[0] ) ? length($string) : undef;
  }
  
  sub encode_utf8($) {
      my ($str) = @_;
      return undef unless defined $str;
      utf8::encode($str);
      return $str;
  }
  
  my $utf8enc;
  
  sub decode_utf8($;$) {
      my ( $octets, $check ) = @_;
      return undef unless defined $octets;
      $octets .= '';
      $check   ||= 0;
      $utf8enc ||= find_encoding('utf8');
      my $string = $utf8enc->decode( $octets, $check );
      $_[0] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
      return $string;
  }
  
  # sub decode_utf8($;$) {
  #     my ( $str, $check ) = @_;
  #     return $str if is_utf8($str);
  #     if ($check) {
  #         return decode( "utf8", $str, $check );
  #     }
  #     else {
  #         return decode( "utf8", $str );
  #         return $str;
  #     }
  # }
  
  predefine_encodings(1);
  
  #
  # This is to restore %Encoding if really needed;
  #
  
  sub predefine_encodings {
      require Encode::Encoding;
      no warnings 'redefine';
      my $use_xs = shift;
      if ($ON_EBCDIC) {
  
          # was in Encode::UTF_EBCDIC
          package Encode::UTF_EBCDIC;
          push @Encode::UTF_EBCDIC::ISA, 'Encode::Encoding';
          *decode = sub {
              my ( undef, $str, $chk ) = @_;
              my $res = '';
              for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                  $res .=
                    chr(
                      utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )
                    );
              }
              $_[1] = '' if $chk;
              return $res;
          };
          *encode = sub {
              my ( undef, $str, $chk ) = @_;
              my $res = '';
              for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                  $res .=
                    chr(
                      utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )
                    );
              }
              $_[1] = '' if $chk;
              return $res;
          };
          $Encode::Encoding{Unicode} =
            bless { Name => "UTF_EBCDIC" } => "Encode::UTF_EBCDIC";
      }
      else {
  
          package Encode::Internal;
          push @Encode::Internal::ISA, 'Encode::Encoding';
          *decode = sub {
              my ( undef, $str, $chk ) = @_;
              utf8::upgrade($str);
              $_[1] = '' if $chk;
              return $str;
          };
          *encode = \&decode;
          $Encode::Encoding{Unicode} =
            bless { Name => "Internal" } => "Encode::Internal";
      }
      {
          # https://rt.cpan.org/Public/Bug/Display.html?id=103253
          package Encode::XS;
          push @Encode::XS::ISA, 'Encode::Encoding';
      }
      {
  
          # was in Encode::utf8
          package Encode::utf8;
          push @Encode::utf8::ISA, 'Encode::Encoding';
  
          #
          if ($use_xs) {
              Encode::DEBUG and warn __PACKAGE__, " XS on";
              *decode = \&decode_xs;
              *encode = \&encode_xs;
          }
          else {
              Encode::DEBUG and warn __PACKAGE__, " XS off";
              *decode = sub {
                  my ( undef, $octets, $chk ) = @_;
                  my $str = Encode::decode_utf8($octets);
                  if ( defined $str ) {
                      $_[1] = '' if $chk;
                      return $str;
                  }
                  return undef;
              };
              *encode = sub {
                  my ( undef, $string, $chk ) = @_;
                  my $octets = Encode::encode_utf8($string);
                  $_[1] = '' if $chk;
                  return $octets;
              };
          }
          *cat_decode = sub {    # ($obj, $dst, $src, $pos, $trm, $chk)
                                 # currently ignores $chk
              my ( undef, undef, undef, $pos, $trm ) = @_;
              my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
              use bytes;
              if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {
                  $$rdst .=
                    substr( $$rsrc, $pos, $npos - $pos + length($trm) );
                  $$rpos = $npos + length($trm);
                  return 1;
              }
              $$rdst .= substr( $$rsrc, $pos );
              $$rpos = length($$rsrc);
              return '';
          };
          $Encode::Encoding{utf8} =
            bless { Name => "utf8" } => "Encode::utf8";
          $Encode::Encoding{"utf-8-strict"} =
            bless { Name => "utf-8-strict", strict_utf8 => 1 } 
              => "Encode::utf8";
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Encode - character encodings in Perl
  
  =head1 SYNOPSIS
  
      use Encode qw(decode encode);
      $characters = decode('UTF-8', $octets,     Encode::FB_CROAK);
      $octets     = encode('UTF-8', $characters, Encode::FB_CROAK);
  
  =head2 Table of Contents
  
  Encode consists of a collection of modules whose details are too extensive
  to fit in one document.  This one itself explains the top-level APIs
  and general topics at a glance.  For other topics and more details,
  see the documentation for these modules:
  
  =over 2
  
  =item L<Encode::Alias> - Alias definitions to encodings
  
  =item L<Encode::Encoding> - Encode Implementation Base Class
  
  =item L<Encode::Supported> - List of Supported Encodings
  
  =item L<Encode::CN> - Simplified Chinese Encodings
  
  =item L<Encode::JP> - Japanese Encodings
  
  =item L<Encode::KR> - Korean Encodings
  
  =item L<Encode::TW> - Traditional Chinese Encodings
  
  =back
  
  =head1 DESCRIPTION
  
  The C<Encode> module provides the interface between Perl strings
  and the rest of the system.  Perl strings are sequences of
  I<characters>.
  
  The repertoire of characters that Perl can represent is a superset of those
  defined by the Unicode Consortium. On most platforms the ordinal
  values of a character as returned by C<ord(I<S>)> is the I<Unicode
  codepoint> for that character. The exceptions are platforms where
  the legacy encoding is some variant of EBCDIC rather than a superset
  of ASCII; see L<perlebcdic>.
  
  During recent history, data is moved around a computer in 8-bit chunks,
  often called "bytes" but also known as "octets" in standards documents.
  Perl is widely used to manipulate data of many types: not only strings of
  characters representing human or computer languages, but also "binary"
  data, being the machine's representation of numbers, pixels in an image, or
  just about anything.
  
  When Perl is processing "binary data", the programmer wants Perl to
  process "sequences of bytes". This is not a problem for Perl: because a
  byte has 256 possible values, it easily fits in Perl's much larger
  "logical character".
  
  This document mostly explains the I<how>. L<perlunitut> and L<perlunifaq>
  explain the I<why>.
  
  =head2 TERMINOLOGY
  
  =head3 character
  
  A character in the range 0 .. 2**32-1 (or more);
  what Perl's strings are made of.
  
  =head3 byte
  
  A character in the range 0..255;
  a special case of a Perl character.
  
  =head3 octet
  
  8 bits of data, with ordinal values 0..255;
  term for bytes passed to or from a non-Perl context, such as a disk file,
  standard I/O stream, database, command-line argument, environment variable,
  socket etc.
  
  =head1 THE PERL ENCODING API
  
  =head2 Basic methods
  
  =head3 encode
  
    $octets  = encode(ENCODING, STRING[, CHECK])
  
  Encodes the scalar value I<STRING> from Perl's internal form into
  I<ENCODING> and returns a sequence of octets.  I<ENCODING> can be either a
  canonical name or an alias.  For encoding names and aliases, see
  L</"Defining Aliases">.  For CHECK, see L</"Handling Malformed Data">.
  
  B<CAVEAT>: the input scalar I<STRING> might be modified in-place depending
  on what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  For example, to convert a string from Perl's internal format into
  ISO-8859-1, also known as Latin1:
  
    $octets = encode("iso-8859-1", $string);
  
  B<CAVEAT>: When you run C<$octets = encode("utf8", $string)>, then
  $octets I<might not be equal to> $string.  Though both contain the
  same data, the UTF8 flag for $octets is I<always> off.  When you
  encode anything, the UTF8 flag on the result is always off, even when it
  contains a completely valid utf8 string. See L</"The UTF8 flag"> below.
  
  If the $string is C<undef>, then C<undef> is returned.
  
  =head3 decode
  
    $string = decode(ENCODING, OCTETS[, CHECK])
  
  This function returns the string that results from decoding the scalar
  value I<OCTETS>, assumed to be a sequence of octets in I<ENCODING>, into
  Perl's internal form.  As with encode(),
  I<ENCODING> can be either a canonical name or an alias. For encoding names
  and aliases, see L</"Defining Aliases">; for I<CHECK>, see L</"Handling
  Malformed Data">.
  
  B<CAVEAT>: the input scalar I<OCTETS> might be modified in-place depending
  on what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  For example, to convert ISO-8859-1 data into a string in Perl's
  internal format:
  
    $string = decode("iso-8859-1", $octets);
  
  B<CAVEAT>: When you run C<$string = decode("utf8", $octets)>, then $string
  I<might not be equal to> $octets.  Though both contain the same data, the
  UTF8 flag for $string is on.  See L</"The UTF8 flag">
  below.
  
  If the $string is C<undef>, then C<undef> is returned.
  
  =head3 find_encoding
  
    [$obj =] find_encoding(ENCODING)
  
  Returns the I<encoding object> corresponding to I<ENCODING>.  Returns
  C<undef> if no matching I<ENCODING> is find.  The returned object is
  what does the actual encoding or decoding.
  
    $utf8 = decode($name, $bytes);
  
  is in fact
  
      $utf8 = do {
          $obj = find_encoding($name);
          croak qq(encoding "$name" not found) unless ref $obj;
          $obj->decode($bytes);
      };
  
  with more error checking.
  
  You can therefore save time by reusing this object as follows;
  
      my $enc = find_encoding("iso-8859-1");
      while(<>) {
          my $utf8 = $enc->decode($_);
          ... # now do something with $utf8;
      }
  
  Besides L</decode> and L</encode>, other methods are
  available as well.  For instance, C<name()> returns the canonical
  name of the encoding object.
  
    find_encoding("latin1")->name; # iso-8859-1
  
  See L<Encode::Encoding> for details.
  
  =head3 find_mime_encoding
  
    [$obj =] find_mime_encoding(MIME_ENCODING)
  
  Returns the I<encoding object> corresponding to I<MIME_ENCODING>.  Acts
  same as C<find_encoding()> but C<mime_name()> of returned object must
  match to I<MIME_ENCODING>.  So as opposite of C<find_encoding()>
  canonical names and aliases are not used when searching for object.
  
      find_mime_encoding("utf8"); # returns undef because "utf8" is not valid I<MIME_ENCODING>
      find_mime_encoding("utf-8"); # returns encode object "utf-8-strict"
      find_mime_encoding("UTF-8"); # same as "utf-8" because I<MIME_ENCODING> is case insensitive
      find_mime_encoding("utf-8-strict"); returns undef because "utf-8-strict" is not valid I<MIME_ENCODING>
  
  =head3 from_to
  
    [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])
  
  Converts I<in-place> data between two encodings. The data in $octets
  must be encoded as octets and I<not> as characters in Perl's internal
  format. For example, to convert ISO-8859-1 data into Microsoft's CP1250
  encoding:
  
    from_to($octets, "iso-8859-1", "cp1250");
  
  and to convert it back:
  
    from_to($octets, "cp1250", "iso-8859-1");
  
  Because the conversion happens in place, the data to be
  converted cannot be a string constant: it must be a scalar variable.
  
  C<from_to()> returns the length of the converted string in octets on success,
  and C<undef> on error.
  
  B<CAVEAT>: The following operations may look the same, but are not:
  
    from_to($data, "iso-8859-1", "utf8"); #1
    $data = decode("iso-8859-1", $data);  #2
  
  Both #1 and #2 make $data consist of a completely valid UTF-8 string,
  but only #2 turns the UTF8 flag on.  #1 is equivalent to:
  
    $data = encode("utf8", decode("iso-8859-1", $data));
  
  See L</"The UTF8 flag"> below.
  
  Also note that:
  
    from_to($octets, $from, $to, $check);
  
  is equivalent to:
  
    $octets = encode($to, decode($from, $octets), $check);
  
  Yes, it does I<not> respect the $check during decoding.  It is
  deliberately done that way.  If you need minute control, use C<decode>
  followed by C<encode> as follows:
  
    $octets = encode($to, decode($from, $octets, $check_from), $check_to);
  
  =head3 encode_utf8
  
    $octets = encode_utf8($string);
  
  Equivalent to C<$octets = encode("utf8", $string)>.  The characters in
  $string are encoded in Perl's internal format, and the result is returned
  as a sequence of octets.  Because all possible characters in Perl have a
  (loose, not strict) UTF-8 representation, this function cannot fail.
  
  =head3 decode_utf8
  
    $string = decode_utf8($octets [, CHECK]);
  
  Equivalent to C<$string = decode("utf8", $octets [, CHECK])>.
  The sequence of octets represented by $octets is decoded
  from UTF-8 into a sequence of logical characters.
  Because not all sequences of octets are valid UTF-8,
  it is quite possible for this function to fail.
  For CHECK, see L</"Handling Malformed Data">.
  
  B<CAVEAT>: the input I<$octets> might be modified in-place depending on
  what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  =head2 Listing available encodings
  
    use Encode;
    @list = Encode->encodings();
  
  Returns a list of canonical names of available encodings that have already
  been loaded.  To get a list of all available encodings including those that
  have not yet been loaded, say:
  
    @all_encodings = Encode->encodings(":all");
  
  Or you can give the name of a specific module:
  
    @with_jp = Encode->encodings("Encode::JP");
  
  When "C<::>" is not in the name, "C<Encode::>" is assumed.
  
    @ebcdic = Encode->encodings("EBCDIC");
  
  To find out in detail which encodings are supported by this package,
  see L<Encode::Supported>.
  
  =head2 Defining Aliases
  
  To add a new alias to a given encoding, use:
  
    use Encode;
    use Encode::Alias;
    define_alias(NEWNAME => ENCODING);
  
  After that, I<NEWNAME> can be used as an alias for I<ENCODING>.
  I<ENCODING> may be either the name of an encoding or an
  I<encoding object>.
  
  Before you do that, first make sure the alias is nonexistent using
  C<resolve_alias()>, which returns the canonical name thereof.
  For example:
  
    Encode::resolve_alias("latin1") eq "iso-8859-1" # true
    Encode::resolve_alias("iso-8859-12")   # false; nonexistent
    Encode::resolve_alias($name) eq $name  # true if $name is canonical
  
  C<resolve_alias()> does not need C<use Encode::Alias>; it can be
  imported via C<use Encode qw(resolve_alias)>.
  
  See L<Encode::Alias> for details.
  
  =head2 Finding IANA Character Set Registry names
  
  The canonical name of a given encoding does not necessarily agree with
  IANA Character Set Registry, commonly seen as C<< Content-Type:
  text/plain; charset=I<WHATEVER> >>.  For most cases, the canonical name
  works, but sometimes it does not, most notably with "utf-8-strict".
  
  As of C<Encode> version 2.21, a new method C<mime_name()> is therefore added.
  
    use Encode;
    my $enc = find_encoding("UTF-8");
    warn $enc->name;      # utf-8-strict
    warn $enc->mime_name; # UTF-8
  
  See also:  L<Encode::Encoding>
  
  =head1 Encoding via PerlIO
  
  If your perl supports C<PerlIO> (which is the default), you can use a
  C<PerlIO> layer to decode and encode directly via a filehandle.  The
  following two examples are fully identical in functionality:
  
    ### Version 1 via PerlIO
      open(INPUT,  "< :encoding(shiftjis)", $infile)
          || die "Can't open < $infile for reading: $!";
      open(OUTPUT, "> :encoding(euc-jp)",  $outfile)
          || die "Can't open > $output for writing: $!";
      while (<INPUT>) {   # auto decodes $_
          print OUTPUT;   # auto encodes $_
      }
      close(INPUT)   || die "can't close $infile: $!";
      close(OUTPUT)  || die "can't close $outfile: $!";
  
    ### Version 2 via from_to()
      open(INPUT,  "< :raw", $infile)
          || die "Can't open < $infile for reading: $!";
      open(OUTPUT, "> :raw",  $outfile)
          || die "Can't open > $output for writing: $!";
  
      while (<INPUT>) {
          from_to($_, "shiftjis", "euc-jp", 1);  # switch encoding
          print OUTPUT;   # emit raw (but properly encoded) data
      }
      close(INPUT)   || die "can't close $infile: $!";
      close(OUTPUT)  || die "can't close $outfile: $!";
  
  In the first version above, you let the appropriate encoding layer
  handle the conversion.  In the second, you explicitly translate
  from one encoding to the other.
  
  Unfortunately, it may be that encodings are not C<PerlIO>-savvy.  You can check
  to see whether your encoding is supported by C<PerlIO> by invoking the
  C<perlio_ok> method on it:
  
    Encode::perlio_ok("hz");             # false
    find_encoding("euc-cn")->perlio_ok;  # true wherever PerlIO is available
  
    use Encode qw(perlio_ok);            # imported upon request
    perlio_ok("euc-jp")
  
  Fortunately, all encodings that come with C<Encode> core are C<PerlIO>-savvy
  except for C<hz> and C<ISO-2022-kr>.  For the gory details, see
  L<Encode::Encoding> and L<Encode::PerlIO>.
  
  =head1 Handling Malformed Data
  
  The optional I<CHECK> argument tells C<Encode> what to do when
  encountering malformed data.  Without I<CHECK>, C<Encode::FB_DEFAULT>
  (== 0) is assumed.
  
  As of version 2.12, C<Encode> supports coderef values for C<CHECK>;
  see below.
  
  B<NOTE:> Not all encodings support this feature.
  Some encodings ignore the I<CHECK> argument.  For example,
  L<Encode::Unicode> ignores I<CHECK> and it always croaks on error.
  
  =head2 List of I<CHECK> values
  
  =head3 FB_DEFAULT
  
    I<CHECK> = Encode::FB_DEFAULT ( == 0)
  
  If I<CHECK> is 0, encoding and decoding replace any malformed character
  with a I<substitution character>.  When you encode, I<SUBCHAR> is used.
  When you decode, the Unicode REPLACEMENT CHARACTER, code point U+FFFD, is
  used.  If the data is supposed to be UTF-8, an optional lexical warning of
  warning category C<"utf8"> is given.
  
  =head3 FB_CROAK
  
    I<CHECK> = Encode::FB_CROAK ( == 1)
  
  If I<CHECK> is 1, methods immediately die with an error
  message.  Therefore, when I<CHECK> is 1, you should trap
  exceptions with C<eval{}>, unless you really want to let it C<die>.
  
  =head3 FB_QUIET
  
    I<CHECK> = Encode::FB_QUIET
  
  If I<CHECK> is set to C<Encode::FB_QUIET>, encoding and decoding immediately
  return the portion of the data that has been processed so far when an
  error occurs. The data argument is overwritten with everything
  after that point; that is, the unprocessed portion of the data.  This is
  handy when you have to call C<decode> repeatedly in the case where your
  source data may contain partial multi-byte character sequences,
  (that is, you are reading with a fixed-width buffer). Here's some sample
  code to do exactly that:
  
      my($buffer, $string) = ("", "");
      while (read($fh, $buffer, 256, length($buffer))) {
          $string .= decode($encoding, $buffer, Encode::FB_QUIET);
          # $buffer now contains the unprocessed partial character
      }
  
  =head3 FB_WARN
  
    I<CHECK> = Encode::FB_WARN
  
  This is the same as C<FB_QUIET> above, except that instead of being silent
  on errors, it issues a warning.  This is handy for when you are debugging.
  
  =head3 FB_PERLQQ FB_HTMLCREF FB_XMLCREF
  
  =over 2
  
  =item perlqq mode (I<CHECK> = Encode::FB_PERLQQ)
  
  =item HTML charref mode (I<CHECK> = Encode::FB_HTMLCREF)
  
  =item XML charref mode (I<CHECK> = Encode::FB_XMLCREF)
  
  =back
  
  For encodings that are implemented by the C<Encode::XS> module, C<CHECK> C<==>
  C<Encode::FB_PERLQQ> puts C<encode> and C<decode> into C<perlqq> fallback mode.
  
  When you decode, C<\xI<HH>> is inserted for a malformed character, where
  I<HH> is the hex representation of the octet that could not be decoded to
  utf8.  When you encode, C<\x{I<HHHH>}> will be inserted, where I<HHHH> is
  the Unicode code point (in any number of hex digits) of the character that
  cannot be found in the character repertoire of the encoding.
  
  The HTML/XML character reference modes are about the same. In place of
  C<\x{I<HHHH>}>, HTML uses C<&#I<NNN>;> where I<NNN> is a decimal number, and
  XML uses C<&#xI<HHHH>;> where I<HHHH> is the hexadecimal number.
  
  In C<Encode> 2.10 or later, C<LEAVE_SRC> is also implied.
  
  =head3 The bitmask
  
  These modes are all actually set via a bitmask.  Here is how the C<FB_I<XXX>>
  constants are laid out.  You can import the C<FB_I<XXX>> constants via
  C<use Encode qw(:fallbacks)>, and you can import the generic bitmask
  constants via C<use Encode qw(:fallback_all)>.
  
                       FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
   DIE_ON_ERR    0x0001             X
   WARN_ON_ERR   0x0002                               X
   RETURN_ON_ERR 0x0004                      X        X
   LEAVE_SRC     0x0008                                        X
   PERLQQ        0x0100                                        X
   HTMLCREF      0x0200
   XMLCREF       0x0400
  
  =head3 LEAVE_SRC
  
    Encode::LEAVE_SRC
  
  If the C<Encode::LEAVE_SRC> bit is I<not> set but I<CHECK> is set, then the
  source string to encode() or decode() will be overwritten in place.
  If you're not interested in this, then bitwise-OR it with the bitmask.
  
  =head2 coderef for CHECK
  
  As of C<Encode> 2.12, C<CHECK> can also be a code reference which takes the
  ordinal value of the unmapped character as an argument and returns
  octets that represent the fallback character.  For instance:
  
    $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });
  
  Acts like C<FB_PERLQQ> but U+I<XXXX> is used instead of C<\x{I<XXXX>}>.
  
  Even the fallback for C<decode> must return octets, which are
  then decoded with the character encoding that C<decode> accepts. So for
  example if you wish to decode octets as UTF-8, and use ISO-8859-15 as
  a fallback for bytes that are not valid UTF-8, you could write
  
      $str = decode 'UTF-8', $octets, sub {
          my $tmp = chr shift;
          from_to $tmp, 'ISO-8859-15', 'UTF-8';
          return $tmp;
      };
  
  =head1 Defining Encodings
  
  To define a new encoding, use:
  
      use Encode qw(define_encoding);
      define_encoding($object, CANONICAL_NAME [, alias...]);
  
  I<CANONICAL_NAME> will be associated with I<$object>.  The object
  should provide the interface described in L<Encode::Encoding>.
  If more than two arguments are provided, additional
  arguments are considered aliases for I<$object>.
  
  See L<Encode::Encoding> for details.
  
  =head1 The UTF8 flag
  
  Before the introduction of Unicode support in Perl, The C<eq> operator
  just compared the strings represented by two scalars. Beginning with
  Perl 5.8, C<eq> compares two strings with simultaneous consideration of
  I<the UTF8 flag>. To explain why we made it so, I quote from page 402 of
  I<Programming Perl, 3rd ed.>
  
  =over 2
  
  =item Goal #1:
  
  Old byte-oriented programs should not spontaneously break on the old
  byte-oriented data they used to work on.
  
  =item Goal #2:
  
  Old byte-oriented programs should magically start working on the new
  character-oriented data when appropriate.
  
  =item Goal #3:
  
  Programs should run just as fast in the new character-oriented mode
  as in the old byte-oriented mode.
  
  =item Goal #4:
  
  Perl should remain one language, rather than forking into a
  byte-oriented Perl and a character-oriented Perl.
  
  =back
  
  When I<Programming Perl, 3rd ed.> was written, not even Perl 5.6.0 had been
  born yet, many features documented in the book remained unimplemented for a
  long time.  Perl 5.8 corrected much of this, and the introduction of the
  UTF8 flag is one of them.  You can think of there being two fundamentally
  different kinds of strings and string-operations in Perl: one a
  byte-oriented mode  for when the internal UTF8 flag is off, and the other a
  character-oriented mode for when the internal UTF8 flag is on.
  
  Here is how C<Encode> handles the UTF8 flag.
  
  =over 2
  
  =item *
  
  When you I<encode>, the resulting UTF8 flag is always B<off>.
  
  =item *
  
  When you I<decode>, the resulting UTF8 flag is B<on>--I<unless> you can
  unambiguously represent data.  Here is what we mean by "unambiguously".
  After C<$utf8 = decode("foo", $octet)>,
  
    When $octet is...   The UTF8 flag in $utf8 is
    ---------------------------------------------
    In ASCII only (or EBCDIC only)            OFF
    In ISO-8859-1                              ON
    In any other Encoding                      ON
    ---------------------------------------------
  
  As you see, there is one exception: in ASCII.  That way you can assume
  Goal #1.  And with C<Encode>, Goal #2 is assumed but you still have to be
  careful in the cases mentioned in the B<CAVEAT> paragraphs above.
  
  This UTF8 flag is not visible in Perl scripts, exactly for the same reason
  you cannot (or rather, you I<don't have to>) see whether a scalar contains
  a string, an integer, or a floating-point number.   But you can still peek
  and poke these if you will.  See the next section.
  
  =back
  
  =head2 Messing with Perl's Internals
  
  The following API uses parts of Perl's internals in the current
  implementation.  As such, they are efficient but may change in a future
  release.
  
  =head3 is_utf8
  
    is_utf8(STRING [, CHECK])
  
  [INTERNAL] Tests whether the UTF8 flag is turned on in the I<STRING>.
  If I<CHECK> is true, also checks whether I<STRING> contains well-formed
  UTF-8.  Returns true if successful, false otherwise.
  
  As of Perl 5.8.1, L<utf8> also has the C<utf8::is_utf8> function.
  
  =head3 _utf8_on
  
    _utf8_on(STRING)
  
  [INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<on>.  The I<STRING>
  is I<not> checked for containing only well-formed UTF-8.  Do not use this
  unless you I<know with absolute certainty> that the STRING holds only
  well-formed UTF-8.  Returns the previous state of the UTF8 flag (so please
  don't treat the return value as indicating success or failure), or C<undef>
  if I<STRING> is not a string.
  
  B<NOTE>: For security reasons, this function does not work on tainted values.
  
  =head3 _utf8_off
  
    _utf8_off(STRING)
  
  [INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<off>.  Do not use
  frivolously.  Returns the previous state of the UTF8 flag, or C<undef> if
  I<STRING> is not a string.  Do not treat the return value as indicative of
  success or failure, because that isn't what it means: it is only the
  previous setting.
  
  B<NOTE>: For security reasons, this function does not work on tainted values.
  
  =head1 UTF-8 vs. utf8 vs. UTF8
  
    ....We now view strings not as sequences of bytes, but as sequences
    of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
    computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.
  
  That has historically been Perl's notion of UTF-8, as that is how UTF-8 was
  first conceived by Ken Thompson when he invented it. However, thanks to
  later revisions to the applicable standards, official UTF-8 is now rather
  stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF
  to cover only 21 bits instead of 32 or 64 bits) and some sequences
  are not allowed, like those used in surrogate pairs, the 31 non-character
  code points 0xFDD0 .. 0xFDEF, the last two code points in I<any> plane
  (0xI<XX>_FFFE and 0xI<XX>_FFFF), all non-shortest encodings, etc.
  
  The former default in which Perl would always use a loose interpretation of
  UTF-8 has now been overruled:
  
    From: Larry Wall <larry@wall.org>
    Date: December 04, 2004 11:51:58 JST
    To: perl-unicode@perl.org
    Subject: Re: Make Encode.pm support the real UTF-8
    Message-Id: <20041204025158.GA28754@wall.org>
  
    On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
    : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
    : but "UTF-8" is the name of the standard and should give the
    : corresponding behaviour.
  
    For what it's worth, that's how I've always kept them straight in my
    head.
  
    Also for what it's worth, Perl 6 will mostly default to strict but
    make it easy to switch back to lax.
  
    Larry
  
  Got that?  As of Perl 5.8.7, B<"UTF-8"> means UTF-8 in its current
  sense, which is conservative and strict and security-conscious, whereas
  B<"utf8"> means UTF-8 in its former sense, which was liberal and loose and
  lax.  C<Encode> version 2.10 or later thus groks this subtle but critically
  important distinction between C<"UTF-8"> and C<"utf8">.
  
    encode("utf8",  "\x{FFFF_FFFF}", 1); # okay
    encode("UTF-8", "\x{FFFF_FFFF}", 1); # croaks
  
  In the C<Encode> module, C<"UTF-8"> is actually a canonical name for
  C<"utf-8-strict">.  That hyphen between the C<"UTF"> and the C<"8"> is
  critical; without it, C<Encode> goes "liberal" and (perhaps overly-)permissive:
  
    find_encoding("UTF-8")->name # is 'utf-8-strict'
    find_encoding("utf-8")->name # ditto. names are case insensitive
    find_encoding("utf_8")->name # ditto. "_" are treated as "-"
    find_encoding("UTF8")->name  # is 'utf8'.
  
  Perl's internal UTF8 flag is called "UTF8", without a hyphen. It indicates
  whether a string is internally encoded as "utf8", also without a hyphen.
  
  =head1 SEE ALSO
  
  L<Encode::Encoding>,
  L<Encode::Supported>,
  L<Encode::PerlIO>,
  L<encoding>,
  L<perlebcdic>,
  L<perlfunc/open>,
  L<perlunicode>, L<perluniintro>, L<perlunifaq>, L<perlunitut>
  L<utf8>,
  the Perl Unicode Mailing List L<http://lists.perl.org/list/perl-unicode.html>
  
  =head1 MAINTAINER
  
  This project was originated by the late Nick Ing-Simmons and later
  maintained by Dan Kogai I<< <dankogai@cpan.org> >>.  See AUTHORS
  for a full list of people involved.  For any questions, send mail to
  I<< <perl-unicode@perl.org> >> so that we can all share.
  
  While Dan Kogai retains the copyright as a maintainer, credit
  should go to all those involved.  See AUTHORS for a list of those
  who submitted code to the project.
  
  =head1 COPYRIGHT
  
  Copyright 2002-2014 Dan Kogai I<< <dankogai@cpan.org> >>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_ENCODE

$fatpacked{"darwin-2level/Encode/Alias.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_ALIAS';
  package Encode::Alias;
  use strict;
  use warnings;
  no warnings 'redefine';
  our $VERSION = do { my @r = ( q$Revision: 2.21 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  
  use Exporter 'import';
  
  # Public, encouraged API is exported by default
  
  our @EXPORT =
    qw (
    define_alias
    find_alias
  );
  
  our @Alias;    # ordered matching list
  our %Alias;    # cached known aliases
  
  sub find_alias {
      require Encode;
      my $class = shift;
      my $find  = shift;
      unless ( exists $Alias{$find} ) {
          $Alias{$find} = undef;    # Recursion guard
          for ( my $i = 0 ; $i < @Alias ; $i += 2 ) {
              my $alias = $Alias[$i];
              my $val   = $Alias[ $i + 1 ];
              my $new;
              if ( ref($alias) eq 'Regexp' && $find =~ $alias ) {
                  DEBUG and warn "eval $val";
                  $new = eval $val;
                  DEBUG and $@ and warn "$val, $@";
              }
              elsif ( ref($alias) eq 'CODE' ) {
                  DEBUG and warn "$alias", "->", "($find)";
                  $new = $alias->($find);
              }
              elsif ( lc($find) eq lc($alias) ) {
                  $new = $val;
              }
              if ( defined($new) ) {
                  next if $new eq $find;    # avoid (direct) recursion on bugs
                  DEBUG and warn "$alias, $new";
                  my $enc =
                    ( ref($new) ) ? $new : Encode::find_encoding($new);
                  if ($enc) {
                      $Alias{$find} = $enc;
                      last;
                  }
              }
          }
  
          # case insensitive search when canonical is not in all lowercase
          # RT ticket #7835
          unless ( $Alias{$find} ) {
              my $lcfind = lc($find);
              for my $name ( keys %Encode::Encoding, keys %Encode::ExtModule )
              {
                  $lcfind eq lc($name) or next;
                  $Alias{$find} = Encode::find_encoding($name);
                  DEBUG and warn "$find => $name";
              }
          }
      }
      if (DEBUG) {
          my $name;
          if ( my $e = $Alias{$find} ) {
              $name = $e->name;
          }
          else {
              $name = "";
          }
          warn "find_alias($class, $find)->name = $name";
      }
      return $Alias{$find};
  }
  
  sub define_alias {
      while (@_) {
          my $alias = shift;
          my $name = shift;
          unshift( @Alias, $alias => $name )    # newer one has precedence
              if defined $alias;
          if ( ref($alias) ) {
  
              # clear %Alias cache to allow overrides
              my @a = keys %Alias;
              for my $k (@a) {
                  if ( ref($alias) eq 'Regexp' && $k =~ $alias ) {
                      DEBUG and warn "delete \$Alias\{$k\}";
                      delete $Alias{$k};
                  }
                  elsif ( ref($alias) eq 'CODE' && $alias->($k) ) {
                      DEBUG and warn "delete \$Alias\{$k\}";
                      delete $Alias{$k};
                  }
              }
          }
          elsif (defined $alias) {
              DEBUG and warn "delete \$Alias\{$alias\}";
              delete $Alias{$alias};
          }
          elsif (DEBUG) {
              require Carp;
              Carp::croak("undef \$alias");
          }
      }
  }
  
  # Allow latin-1 style names as well
  # 0  1  2  3  4  5   6   7   8   9  10
  our @Latin2iso = ( 0, 1, 2, 3, 4, 9, 10, 13, 14, 15, 16 );
  
  # Allow winlatin1 style names as well
  our %Winlatin2cp = (
      'latin1'     => 1252,
      'latin2'     => 1250,
      'cyrillic'   => 1251,
      'greek'      => 1253,
      'turkish'    => 1254,
      'hebrew'     => 1255,
      'arabic'     => 1256,
      'baltic'     => 1257,
      'vietnamese' => 1258,
  );
  
  init_aliases();
  
  sub undef_aliases {
      @Alias = ();
      %Alias = ();
  }
  
  sub init_aliases {
      require Encode;
      undef_aliases();
  
      # Try all-lower-case version should all else fails
      define_alias( qr/^(.*)$/ => '"\L$1"' );
  
      # UTF/UCS stuff
      define_alias( qr/^(unicode-1-1-)?UTF-?7$/i     => '"UTF-7"' );
      define_alias( qr/^UCS-?2-?LE$/i => '"UCS-2LE"' );
      define_alias(
          qr/^UCS-?2-?(BE)?$/i    => '"UCS-2BE"',
          qr/^UCS-?4-?(BE|LE|)?$/i => 'uc("UTF-32$1")',
          qr/^iso-10646-1$/i      => '"UCS-2BE"'
      );
      define_alias(
          qr/^UTF-?(16|32)-?BE$/i => '"UTF-$1BE"',
          qr/^UTF-?(16|32)-?LE$/i => '"UTF-$1LE"',
          qr/^UTF-?(16|32)$/i     => '"UTF-$1"',
      );
  
      # ASCII
      define_alias( qr/^(?:US-?)ascii$/i       => '"ascii"' );
      define_alias( 'C'                        => 'ascii' );
      define_alias( qr/\b(?:ISO[-_]?)?646(?:[-_]?US)?$/i => '"ascii"' );
  
      # Allow variants of iso-8859-1 etc.
      define_alias( qr/\biso[-_]?(\d+)[-_](\d+)$/i => '"iso-$1-$2"' );
  
      # At least HP-UX has these.
      define_alias( qr/\biso8859(\d+)$/i => '"iso-8859-$1"' );
  
      # More HP stuff.
      define_alias(
          qr/\b(?:hp-)?(arabic|greek|hebrew|kana|roman|thai|turkish)8$/i =>
            '"${1}8"' );
  
      # The Official name of ASCII.
      define_alias( qr/\bANSI[-_]?X3\.4[-_]?1968$/i => '"ascii"' );
  
      # This is a font issue, not an encoding issue.
      # (The currency symbol of the Latin 1 upper half
      #  has been redefined as the euro symbol.)
      define_alias( qr/^(.+)\@euro$/i => '"$1"' );
  
      define_alias( qr/\b(?:iso[-_]?)?latin[-_]?(\d+)$/i =>
  'defined $Encode::Alias::Latin2iso[$1] ? "iso-8859-$Encode::Alias::Latin2iso[$1]" : undef'
      );
  
      define_alias(
          qr/\bwin(latin[12]|cyrillic|baltic|greek|turkish|
               hebrew|arabic|baltic|vietnamese)$/ix =>
            '"cp" . $Encode::Alias::Winlatin2cp{lc($1)}'
      );
  
      # Common names for non-latin preferred MIME names
      define_alias(
          'ascii'    => 'US-ascii',
          'cyrillic' => 'iso-8859-5',
          'arabic'   => 'iso-8859-6',
          'greek'    => 'iso-8859-7',
          'hebrew'   => 'iso-8859-8',
          'thai'     => 'iso-8859-11',
      );
      # RT #20781
      define_alias(qr/\btis-?620\b/i  => '"iso-8859-11"');
  
      # At least AIX has IBM-NNN (surprisingly...) instead of cpNNN.
      # And Microsoft has their own naming (again, surprisingly).
      # And windows-* is registered in IANA!
      define_alias(
          qr/\b(?:cp|ibm|ms|windows)[-_ ]?(\d{2,4})$/i => '"cp$1"' );
  
      # Sometimes seen with a leading zero.
      # define_alias( qr/\bcp037\b/i => '"cp37"');
  
      # Mac Mappings
      # predefined in *.ucm; unneeded
      # define_alias( qr/\bmacIcelandic$/i => '"macIceland"');
      define_alias( qr/^(?:x[_-])?mac[_-](.*)$/i => '"mac$1"' );
      # http://rt.cpan.org/Ticket/Display.html?id=36326
      define_alias( qr/^macintosh$/i => '"MacRoman"' );
      # https://rt.cpan.org/Ticket/Display.html?id=78125
      define_alias( qr/^macce$/i => '"MacCentralEurRoman"' );
      # Ououououou. gone.  They are different!
      # define_alias( qr/\bmacRomanian$/i => '"macRumanian"');
  
      # Standardize on the dashed versions.
      define_alias( qr/\bkoi8[\s\-_]*([ru])$/i => '"koi8-$1"' );
  
      unless ($Encode::ON_EBCDIC) {
  
          # for Encode::CN
          define_alias( qr/\beuc.*cn$/i => '"euc-cn"' );
          define_alias( qr/\bcn.*euc$/i => '"euc-cn"' );
  
          # define_alias( qr/\bGB[- ]?(\d+)$/i => '"euc-cn"' )
          # CP936 doesn't have vendor-addon for GBK, so they're identical.
          define_alias( qr/^gbk$/i => '"cp936"' );
  
          # This fixes gb2312 vs. euc-cn confusion, practically
          define_alias( qr/\bGB[-_ ]?2312(?!-?raw)/i => '"euc-cn"' );
  
          # for Encode::JP
          define_alias( qr/\bjis$/i         => '"7bit-jis"' );
          define_alias( qr/\beuc.*jp$/i     => '"euc-jp"' );
          define_alias( qr/\bjp.*euc$/i     => '"euc-jp"' );
          define_alias( qr/\bujis$/i        => '"euc-jp"' );
          define_alias( qr/\bshift.*jis$/i  => '"shiftjis"' );
          define_alias( qr/\bsjis$/i        => '"shiftjis"' );
          define_alias( qr/\bwindows-31j$/i => '"cp932"' );
  
          # for Encode::KR
          define_alias( qr/\beuc.*kr$/i => '"euc-kr"' );
          define_alias( qr/\bkr.*euc$/i => '"euc-kr"' );
  
          # This fixes ksc5601 vs. euc-kr confusion, practically
          define_alias( qr/(?:x-)?uhc$/i         => '"cp949"' );
          define_alias( qr/(?:x-)?windows-949$/i => '"cp949"' );
          define_alias( qr/\bks_c_5601-1987$/i   => '"cp949"' );
  
          # for Encode::TW
          define_alias( qr/\bbig-?5$/i              => '"big5-eten"' );
          define_alias( qr/\bbig5-?et(?:en)?$/i     => '"big5-eten"' );
          define_alias( qr/\btca[-_]?big5$/i        => '"big5-eten"' );
          define_alias( qr/\bbig5-?hk(?:scs)?$/i    => '"big5-hkscs"' );
          define_alias( qr/\bhk(?:scs)?[-_]?big5$/i => '"big5-hkscs"' );
      }
  
      # https://github.com/dankogai/p5-encode/issues/37
      define_alias(qr/cp65000/i => '"UTF-7"');
      define_alias(qr/cp65001/i => '"utf-8-strict"');
  
      # utf8 is blessed :)
      define_alias( qr/\bUTF-8$/i => '"utf-8-strict"' );
  
      # At last, Map white space and _ to '-'
      define_alias( qr/^(\S+)[\s_]+(.*)$/i => '"$1-$2"' );
  }
  
  1;
  __END__
  
  # TODO: HP-UX '8' encodings arabic8 greek8 hebrew8 kana8 thai8 turkish8
  # TODO: HP-UX '15' encodings japanese15 korean15 roi15
  # TODO: Cyrillic encoding ISO-IR-111 (useful?)
  # TODO: Armenian encoding ARMSCII-8
  # TODO: Hebrew encoding ISO-8859-8-1
  # TODO: Thai encoding TCVN
  # TODO: Vietnamese encodings VPS
  # TODO: Mac Asian+African encodings: Arabic Armenian Bengali Burmese
  #       ChineseSimp ChineseTrad Devanagari Ethiopic ExtArabic
  #       Farsi Georgian Gujarati Gurmukhi Hebrew Japanese
  #       Kannada Khmer Korean Laotian Malayalam Mongolian
  #       Oriya Sinhalese Symbol Tamil Telugu Tibetan Vietnamese
  
  =head1 NAME
  
  Encode::Alias - alias definitions to encodings
  
  =head1 SYNOPSIS
  
    use Encode;
    use Encode::Alias;
    define_alias( "newName" => ENCODING);
    define_alias( qr/.../ => ENCODING);
    define_alias( sub { return ENCODING if ...; } );
  
  =head1 DESCRIPTION
  
  Allows newName to be used as an alias for ENCODING. ENCODING may be
  either the name of an encoding or an encoding object (as described 
  in L<Encode>).
  
  Currently the first argument to define_alias() can be specified in the
  following ways:
  
  =over 4
  
  =item As a simple string.
  
  =item As a qr// compiled regular expression, e.g.:
  
    define_alias( qr/^iso8859-(\d+)$/i => '"iso-8859-$1"' );
  
  In this case, if I<ENCODING> is not a reference, it is C<eval>-ed
  in order to allow C<$1> etc. to be substituted.  The example is one
  way to alias names as used in X11 fonts to the MIME names for the
  iso-8859-* family.  Note the double quotes inside the single quotes.
  
  (or, you don't have to do this yourself because this example is predefined)
  
  If you are using a regex here, you have to use the quotes as shown or
  it won't work.  Also note that regex handling is tricky even for the
  experienced.  Use this feature with caution.
  
  =item As a code reference, e.g.:
  
    define_alias( sub {shift =~ /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );
  
  The same effect as the example above in a different way.  The coderef
  takes the alias name as an argument and returns a canonical name on
  success or undef if not.  Note the second argument is ignored if provided.
  Use this with even more caution than the regex version.
  
  =back
  
  =head3 Changes in code reference aliasing
  
  As of Encode 1.87, the older form
  
    define_alias( sub { return  /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );
  
  no longer works. 
  
  Encode up to 1.86 internally used "local $_" to implement this older
  form.  But consider the code below;
  
    use Encode;
    $_ = "eeeee" ;
    while (/(e)/g) {
      my $utf = decode('aliased-encoding-name', $1);
      print "position:",pos,"\n";
    }
  
  Prior to Encode 1.86 this fails because of "local $_".
  
  =head2 Alias overloading
  
  You can override predefined aliases by simply applying define_alias().
  The new alias is always evaluated first, and when necessary,
  define_alias() flushes the internal cache to make the new definition
  available.
  
    # redirect SHIFT_JIS to MS/IBM Code Page 932, which is a
    # superset of SHIFT_JIS
  
    define_alias( qr/shift.*jis$/i  => '"cp932"' );
    define_alias( qr/sjis$/i        => '"cp932"' );
  
  If you want to zap all predefined aliases, you can use
  
    Encode::Alias->undef_aliases;
  
  to do so.  And
  
    Encode::Alias->init_aliases;
  
  gets the factory settings back.
  
  Note that define_alias() will not be able to override the canonical name
  of encodings. Encodings are first looked up by canonical name before
  potential aliases are tried.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Supported>
  
  =cut
  
DARWIN-2LEVEL_ENCODE_ALIAS

$fatpacked{"darwin-2level/Encode/Byte.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_BYTE';
  package Encode::Byte;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Byte - Single Byte Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $greek = encode("iso-8859-7", $utf8);  # loads Encode::Byte implicitly
      $utf8  = decode("iso-8859-7", $greek); # ditto
  
  =head1 ABSTRACT
  
  This module implements various single byte encodings.  For most cases it uses
  \x80-\xff (upper half) to map non-ASCII characters.  Encodings
  supported are as follows.   
  
    Canonical      Alias		                      Description
    --------------------------------------------------------------------
    # ISO 8859 series
    (iso-8859-1	is in built-in)
    iso-8859-2	latin2					     [ISO]
    iso-8859-3	latin3					     [ISO]
    iso-8859-4	latin4					     [ISO]
    iso-8859-5						     [ISO]
    iso-8859-6						     [ISO]
    iso-8859-7						     [ISO]
    iso-8859-8						     [ISO]
    iso-8859-9	latin5					     [ISO]
    iso-8859-10	latin6					     [ISO]
    iso-8859-11
    (iso-8859-12 is nonexistent)
    iso-8859-13   latin7					     [ISO]
    iso-8859-14	latin8					     [ISO]
    iso-8859-15	latin9					     [ISO]
    iso-8859-16	latin10					     [ISO]
  
    # Cyrillic
    koi8-f					
    koi8-r        cp878					 [RFC1489]
    koi8-u						 [RFC2319]
  
    # Vietnamese
    viscii
  
    # all cp* are also available as ibm-*, ms-*, and windows-*
    # also see L<http://msdn.microsoft.com/en-us/library/aa752010%28VS.85%29.aspx>
  
    cp424  
    cp437  
    cp737  
    cp775  
    cp850  
    cp852  
    cp855  
    cp856  
    cp857  
    cp860  
    cp861  
    cp862  
    cp863  
    cp864  
    cp865  
    cp866  
    cp869  
    cp874  
    cp1006  
    cp1250	WinLatin2
    cp1251	WinCyrillic
    cp1252	WinLatin1
    cp1253	WinGreek
    cp1254	WinTurkish
    cp1255	WinHebrew
    cp1256	WinArabic
    cp1257	WinBaltic
    cp1258	WinVietnamese
  
    # Macintosh
    # Also see L<http://developer.apple.com/technotes/tn/tn1150.html>
    MacArabic  
    MacCentralEurRoman  
    MacCroatian  
    MacCyrillic  
    MacFarsi  
    MacGreek  
    MacHebrew  
    MacIcelandic  
    MacRoman  
    MacRomanian  
    MacRumanian  
    MacSami  
    MacThai  
    MacTurkish  
    MacUkrainian  
  
    # More vendor encodings
    AdobeStandardEncoding
    nextstep
    hp-roman8
  
  =head1 DESCRIPTION
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
DARWIN-2LEVEL_ENCODE_BYTE

$fatpacked{"darwin-2level/Encode/CJKConstants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_CJKCONSTANTS';
  #
  # $Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
  #
  
  package Encode::CJKConstants;
  
  use strict;
  use warnings;
  our $RCSID = q$Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Carp;
  
  require Exporter;
  our @ISA         = qw(Exporter);
  our @EXPORT      = qw();
  our @EXPORT_OK   = qw(%CHARCODE %ESC %RE);
  our %EXPORT_TAGS = ( 'all' => [ @EXPORT_OK, @EXPORT ] );
  
  my %_0208 = (
      1978 => '\e\$\@',
      1983 => '\e\$B',
      1990 => '\e&\@\e\$B',
  );
  
  our %CHARCODE = (
      UNDEF_EUC     => "\xa2\xae",    #  in EUC
      UNDEF_SJIS    => "\x81\xac",    #  in SJIS
      UNDEF_JIS     => "\xa2\xf7",    #  -- used in unicode
      UNDEF_UNICODE => "\x20\x20",    #  -- used in unicode
  );
  
  our %ESC = (
      GB_2312   => "\e\$A",
      JIS_0208  => "\e\$B",
      JIS_0212  => "\e\$(D",
      KSC_5601  => "\e\$(C",
      ASC       => "\e\(B",
      KANA      => "\e\(I",
      '2022_KR' => "\e\$)C",
  );
  
  our %RE = (
      ASCII     => '[\x00-\x7f]',
      BIN       => '[\x00-\x06\x7f\xff]',
      EUC_0212  => '\x8f[\xa1-\xfe][\xa1-\xfe]',
      EUC_C     => '[\xa1-\xfe][\xa1-\xfe]',
      EUC_KANA  => '\x8e[\xa1-\xdf]',
      JIS_0208  => "$_0208{1978}|$_0208{1983}|$_0208{1990}",
      JIS_0212  => "\e" . '\$\(D',
      ISO_ASC   => "\e" . '\([BJ]',
      JIS_KANA  => "\e" . '\(I',
      '2022_KR' => "\e" . '\$\)C',
      SJIS_C    => '[\x81-\x9f\xe0-\xfc][\x40-\x7e\x80-\xfc]',
      SJIS_KANA => '[\xa1-\xdf]',
      UTF8      => '[\xc0-\xdf][\x80-\xbf]|[\xe0-\xef][\x80-\xbf][\x80-\xbf]'
  );
  
  1;
  
  =head1 NAME
  
  Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*
  
  =cut
  
DARWIN-2LEVEL_ENCODE_CJKCONSTANTS

$fatpacked{"darwin-2level/Encode/CN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_CN';
  package Encode::CN;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::CN not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  # Relocated from Encode.pm
  
  use Encode::CN::HZ;
  
  # use Encode::CN::2022_CN;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::CN - China-based Chinese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_cn = encode("euc-cn", $utf8);   # loads Encode::CN implicitly
      $utf8   = decode("euc-cn", $euc_cn); # ditto
  
  =head1 DESCRIPTION
  
  This module implements China-based Chinese charset encodings.
  Encodings supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-cn      /\beuc.*cn$/i	EUC (Extended Unix Character)
            /\bcn.*euc$/i
                /\bGB[-_ ]?2312(?:\D.*$|$)/i (see below)
    gb2312-raw			The raw (low-bit) GB2312 character map
    gb12345-raw			Traditional chinese counterpart to 
                  GB2312 (raw)
    iso-ir-165			GB2312 + GB6345 + GB8565 + additions
    MacChineseSimp                GB2312 + Apple Additions
    cp936				Code Page 936, also known as GBK 
                  (Extended GuoBiao)
    hz				7-bit escaped GB2312 encoding
    --------------------------------------------------------------------
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 NOTES
  
  Due to size concerns, C<GB 18030> (an extension to C<GBK>) is distributed
  separately on CPAN, under the name L<Encode::HanExtra>. That module
  also contains extra Taiwan-based encodings.
  
  =head1 BUGS
  
  When you see C<charset=gb2312> on mails and web pages, they really
  mean C<euc-cn> encodings.  To fix that, C<gb2312> is aliased to C<euc-cn>.
  Use C<gb2312-raw> when you really mean it.
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even though
  this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
DARWIN-2LEVEL_ENCODE_CN

$fatpacked{"darwin-2level/Encode/CN/HZ.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_CN_HZ';
  package Encode::CN::HZ;
  
  use strict;
  use warnings;
  use utf8 ();
  
  use vars qw($VERSION);
  $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('hz');
  
  # HZ is a combination of ASCII and escaped GB, so we implement it
  # with the GB2312(raw) encoding here. Cf. RFCs 1842 & 1843.
  
  # not ported for EBCDIC.  Which should be used, "~" or "\x7E"?
  
  sub needs_lines { 1 }
  
  sub decode ($$;$) {
      my ( $obj, $str, $chk ) = @_;
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = substr($str, 0, 0); # to propagate taintedness
      my $in_ascii = 1;    # default mode is ASCII.
  
      while ( length $str ) {
          if ($in_ascii) {    # ASCII mode
              if ( $str =~ s/^([\x00-\x7D\x7F]+)// ) {    # no '~' => ASCII
                  $ret .= $1;
  
                  # EBCDIC should need ascii2native, but not ported.
              }
              elsif ( $str =~ s/^\x7E\x7E// ) {           # escaped tilde
                  $ret .= '~';
              }
              elsif ( $str =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                  1;                              # no-op
              }
              elsif ( $str =~ s/^\x7E\x7B// ) {    # '~{'
                  $in_ascii = 0;                   # to GB
              }
              else {    # encounters an invalid escape, \x80 or greater
                  last;
              }
          }
          else {        # GB mode; the byte ranges are as in RFC 1843.
              no warnings 'uninitialized';
              if ( $str =~ s/^((?:[\x21-\x77][\x21-\x7E])+)// ) {
                  my $prefix = $1;
                  $ret .= $GB->decode( $prefix, $chk );
              }
              elsif ( $str =~ s/^\x7E\x7D// ) {    # '~}'
                  $in_ascii = 1;
              }
              else {                               # invalid
                  last;
              }
          }
      }
      $_[1] = '' if $chk;    # needs_lines guarantees no partial character
      return $ret;
  }
  
  sub cat_decode {
      my ( $obj, undef, $src, $pos, $trm, $chk ) = @_;
      my ( $rdst, $rsrc, $rpos ) = \@_[ 1 .. 3 ];
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = '';
      my $in_ascii = 1;      # default mode is ASCII.
  
      my $ini_pos = pos($$rsrc);
  
      substr( $src, 0, $pos ) = '';
  
      my $ini_len = bytes::length($src);
  
      # $trm is the first of the pair '~~', then 2nd tilde is to be removed.
      # XXX: Is better C<$src =~ s/^\x7E// or die if ...>?
      $src =~ s/^\x7E// if $trm eq "\x7E";
  
      while ( length $src ) {
          my $now;
          if ($in_ascii) {    # ASCII mode
              if ( $src =~ s/^([\x00-\x7D\x7F])// ) {    # no '~' => ASCII
                  $now = $1;
              }
              elsif ( $src =~ s/^\x7E\x7E// ) {          # escaped tilde
                  $now = '~';
              }
              elsif ( $src =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                  next;
              }
              elsif ( $src =~ s/^\x7E\x7B// ) {    # '~{'
                  $in_ascii = 0;                   # to GB
                  next;
              }
              else {    # encounters an invalid escape, \x80 or greater
                  last;
              }
          }
          else {        # GB mode; the byte ranges are as in RFC 1843.
              if ( $src =~ s/^((?:[\x21-\x77][\x21-\x7F])+)// ) {
                  $now = $GB->decode( $1, $chk );
              }
              elsif ( $src =~ s/^\x7E\x7D// ) {    # '~}'
                  $in_ascii = 1;
                  next;
              }
              else {                               # invalid
                  last;
              }
          }
  
          next if !defined $now;
  
          $ret .= $now;
  
          if ( $now eq $trm ) {
              $$rdst .= $ret;
              $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
              pos($$rsrc) = $ini_pos;
              return 1;
          }
      }
  
      $$rdst .= $ret;
      $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
      pos($$rsrc) = $ini_pos;
      return '';    # terminator not found
  }
  
  sub encode($$;$) {
       my ( $obj, $str, $chk ) = @_;
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = substr($str, 0, 0); # to propagate taintedness;
      my $in_ascii = 1;    # default mode is ASCII.
  
      no warnings 'utf8';  # $str may be malformed UTF8 at the end of a chunk.
  
      while ( length $str ) {
          if ( $str =~ s/^([[:ascii:]]+)// ) {
              my $tmp = $1;
              $tmp =~ s/~/~~/g;    # escapes tildes
              if ( !$in_ascii ) {
                  $ret .= "\x7E\x7D";    # '~}'
                  $in_ascii = 1;
              }
              $ret .= pack 'a*', $tmp;    # remove UTF8 flag.
          }
          elsif ( $str =~ s/(.)// ) {
              my $s = $1;
              my $tmp = $GB->encode( $s, $chk );
              last if !defined $tmp;
              if ( length $tmp == 2 ) {    # maybe a valid GB char (XXX)
                  if ($in_ascii) {
                      $ret .= "\x7E\x7B";    # '~{'
                      $in_ascii = 0;
                  }
                  $ret .= $tmp;
              }
              elsif ( length $tmp ) {        # maybe FALLBACK in ASCII (XXX)
                  if ( !$in_ascii ) {
                      $ret .= "\x7E\x7D";    # '~}'
                      $in_ascii = 1;
                  }
                  $ret .= $tmp;
              }
          }
          else {    # if $str is malformed UTF8 *and* if length $str != 0.
              last;
          }
      }
      $_[1] = $str if $chk;
  
      # The state at the end of the chunk is discarded, even if in GB mode.
      # That results in the combination of GB-OUT and GB-IN, i.e. "~}~{".
      # Parhaps it is harmless, but further investigations may be required...
  
      if ( !$in_ascii ) {
          $ret .= "\x7E\x7D";    # '~}'
          $in_ascii = 1;
      }
      utf8::encode($ret); # https://rt.cpan.org/Ticket/Display.html?id=35120
      return $ret;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::CN::HZ -- internally used by Encode::CN
  
  =cut
DARWIN-2LEVEL_ENCODE_CN_HZ

$fatpacked{"darwin-2level/Encode/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_CONFIG';
  #
  # Demand-load module list
  #
  package Encode::Config;
  our $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use strict;
  use warnings;
  
  our %ExtModule = (
  
      # Encode::Byte
      #iso-8859-1 is in Encode.pm itself
      'iso-8859-2'            => 'Encode::Byte',
      'iso-8859-3'            => 'Encode::Byte',
      'iso-8859-4'            => 'Encode::Byte',
      'iso-8859-5'            => 'Encode::Byte',
      'iso-8859-6'            => 'Encode::Byte',
      'iso-8859-7'            => 'Encode::Byte',
      'iso-8859-8'            => 'Encode::Byte',
      'iso-8859-9'            => 'Encode::Byte',
      'iso-8859-10'           => 'Encode::Byte',
      'iso-8859-11'           => 'Encode::Byte',
      'iso-8859-13'           => 'Encode::Byte',
      'iso-8859-14'           => 'Encode::Byte',
      'iso-8859-15'           => 'Encode::Byte',
      'iso-8859-16'           => 'Encode::Byte',
      'koi8-f'                => 'Encode::Byte',
      'koi8-r'                => 'Encode::Byte',
      'koi8-u'                => 'Encode::Byte',
      'viscii'                => 'Encode::Byte',
      'cp424'                 => 'Encode::Byte',
      'cp437'                 => 'Encode::Byte',
      'cp737'                 => 'Encode::Byte',
      'cp775'                 => 'Encode::Byte',
      'cp850'                 => 'Encode::Byte',
      'cp852'                 => 'Encode::Byte',
      'cp855'                 => 'Encode::Byte',
      'cp856'                 => 'Encode::Byte',
      'cp857'                 => 'Encode::Byte',
      'cp858'                 => 'Encode::Byte',
      'cp860'                 => 'Encode::Byte',
      'cp861'                 => 'Encode::Byte',
      'cp862'                 => 'Encode::Byte',
      'cp863'                 => 'Encode::Byte',
      'cp864'                 => 'Encode::Byte',
      'cp865'                 => 'Encode::Byte',
      'cp866'                 => 'Encode::Byte',
      'cp869'                 => 'Encode::Byte',
      'cp874'                 => 'Encode::Byte',
      'cp1006'                => 'Encode::Byte',
      'cp1250'                => 'Encode::Byte',
      'cp1251'                => 'Encode::Byte',
      'cp1252'                => 'Encode::Byte',
      'cp1253'                => 'Encode::Byte',
      'cp1254'                => 'Encode::Byte',
      'cp1255'                => 'Encode::Byte',
      'cp1256'                => 'Encode::Byte',
      'cp1257'                => 'Encode::Byte',
      'cp1258'                => 'Encode::Byte',
      'AdobeStandardEncoding' => 'Encode::Byte',
      'MacArabic'             => 'Encode::Byte',
      'MacCentralEurRoman'    => 'Encode::Byte',
      'MacCroatian'           => 'Encode::Byte',
      'MacCyrillic'           => 'Encode::Byte',
      'MacFarsi'              => 'Encode::Byte',
      'MacGreek'              => 'Encode::Byte',
      'MacHebrew'             => 'Encode::Byte',
      'MacIcelandic'          => 'Encode::Byte',
      'MacRoman'              => 'Encode::Byte',
      'MacRomanian'           => 'Encode::Byte',
      'MacRumanian'           => 'Encode::Byte',
      'MacSami'               => 'Encode::Byte',
      'MacThai'               => 'Encode::Byte',
      'MacTurkish'            => 'Encode::Byte',
      'MacUkrainian'          => 'Encode::Byte',
      'nextstep'              => 'Encode::Byte',
      'hp-roman8'             => 'Encode::Byte',
      #'gsm0338'               => 'Encode::Byte',
      'gsm0338'               => 'Encode::GSM0338',
  
      # Encode::EBCDIC
      'cp37'     => 'Encode::EBCDIC',
      'cp500'    => 'Encode::EBCDIC',
      'cp875'    => 'Encode::EBCDIC',
      'cp1026'   => 'Encode::EBCDIC',
      'cp1047'   => 'Encode::EBCDIC',
      'posix-bc' => 'Encode::EBCDIC',
  
      # Encode::Symbol
      'dingbats'      => 'Encode::Symbol',
      'symbol'        => 'Encode::Symbol',
      'AdobeSymbol'   => 'Encode::Symbol',
      'AdobeZdingbat' => 'Encode::Symbol',
      'MacDingbats'   => 'Encode::Symbol',
      'MacSymbol'     => 'Encode::Symbol',
  
      # Encode::Unicode
      'UCS-2BE'  => 'Encode::Unicode',
      'UCS-2LE'  => 'Encode::Unicode',
      'UTF-16'   => 'Encode::Unicode',
      'UTF-16BE' => 'Encode::Unicode',
      'UTF-16LE' => 'Encode::Unicode',
      'UTF-32'   => 'Encode::Unicode',
      'UTF-32BE' => 'Encode::Unicode',
      'UTF-32LE' => 'Encode::Unicode',
      'UTF-7'    => 'Encode::Unicode::UTF7',
  );
  
  unless ( ord("A") == 193 ) {
      %ExtModule = (
          %ExtModule,
          'euc-cn'         => 'Encode::CN',
          'gb12345-raw'    => 'Encode::CN',
          'gb2312-raw'     => 'Encode::CN',
          'hz'             => 'Encode::CN',
          'iso-ir-165'     => 'Encode::CN',
          'cp936'          => 'Encode::CN',
          'MacChineseSimp' => 'Encode::CN',
  
          '7bit-jis'      => 'Encode::JP',
          'euc-jp'        => 'Encode::JP',
          'iso-2022-jp'   => 'Encode::JP',
          'iso-2022-jp-1' => 'Encode::JP',
          'jis0201-raw'   => 'Encode::JP',
          'jis0208-raw'   => 'Encode::JP',
          'jis0212-raw'   => 'Encode::JP',
          'cp932'         => 'Encode::JP',
          'MacJapanese'   => 'Encode::JP',
          'shiftjis'      => 'Encode::JP',
  
          'euc-kr'      => 'Encode::KR',
          'iso-2022-kr' => 'Encode::KR',
          'johab'       => 'Encode::KR',
          'ksc5601-raw' => 'Encode::KR',
          'cp949'       => 'Encode::KR',
          'MacKorean'   => 'Encode::KR',
  
          'big5-eten'      => 'Encode::TW',
          'big5-hkscs'     => 'Encode::TW',
          'cp950'          => 'Encode::TW',
          'MacChineseTrad' => 'Encode::TW',
  
          #'big5plus'           => 'Encode::HanExtra',
          #'euc-tw'             => 'Encode::HanExtra',
          #'gb18030'            => 'Encode::HanExtra',
  
          'MIME-Header' => 'Encode::MIME::Header',
          'MIME-B'      => 'Encode::MIME::Header',
          'MIME-Q'      => 'Encode::MIME::Header',
  
          'MIME-Header-ISO_2022_JP' => 'Encode::MIME::Header::ISO_2022_JP',
      );
  }
  
  #
  # Why not export ? to keep ConfigLocal Happy!
  #
  while ( my ( $enc, $mod ) = each %ExtModule ) {
      $Encode::ExtModule{$enc} = $mod;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Config -- internally used by Encode
  
  =cut
DARWIN-2LEVEL_ENCODE_CONFIG

$fatpacked{"darwin-2level/Encode/EBCDIC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_EBCDIC';
  package Encode::EBCDIC;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::EBCDIC - EBCDIC Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $posix_bc  = encode("posix-bc", $utf8); # loads Encode::EBCDIC implicitly
      $utf8 = decode("", $posix_bc);          # ditto
  
  =head1 ABSTRACT
  
  This module implements various EBCDIC-Based encodings.  Encodings
  supported are as follows.   
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    cp37  
    cp500  
    cp875  
    cp1026  
    cp1047  
    posix-bc
  
  =head1 DESCRIPTION
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>, L<perlebcdic>
  
  =cut
DARWIN-2LEVEL_ENCODE_EBCDIC

$fatpacked{"darwin-2level/Encode/Encoder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_ENCODER';
  #
  # $Id: Encoder.pm,v 2.3 2013/09/14 07:51:59 dankogai Exp $
  #
  package Encode::Encoder;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw ( encoder );
  
  our $AUTOLOAD;
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  use Encode qw(encode decode find_encoding from_to);
  use Carp;
  
  sub new {
      my ( $class, $data, $encname ) = @_;
      unless ($encname) {
          $encname = Encode::is_utf8($data) ? 'utf8' : '';
      }
      else {
          my $obj = find_encoding($encname)
            or croak __PACKAGE__, ": unknown encoding: $encname";
          $encname = $obj->name;
      }
      my $self = {
          data     => $data,
          encoding => $encname,
      };
      bless $self => $class;
  }
  
  sub encoder { __PACKAGE__->new(@_) }
  
  sub data {
      my ( $self, $data ) = @_;
      if ( defined $data ) {
          $self->{data} = $data;
          return $data;
      }
      else {
          return $self->{data};
      }
  }
  
  sub encoding {
      my ( $self, $encname ) = @_;
      if ($encname) {
          my $obj = find_encoding($encname)
            or confess __PACKAGE__, ": unknown encoding: $encname";
          $self->{encoding} = $obj->name;
          return $self;
      }
      else {
          return $self->{encoding};
      }
  }
  
  sub bytes {
      my ( $self, $encname ) = @_;
      $encname ||= $self->{encoding};
      my $obj = find_encoding($encname)
        or confess __PACKAGE__, ": unknown encoding: $encname";
      $self->{data} = $obj->decode( $self->{data}, 1 );
      $self->{encoding} = '';
      return $self;
  }
  
  sub DESTROY {    # defined so it won't autoload.
      DEBUG and warn shift;
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $type = ref($self)
        or confess "$self is not an object";
      my $myname = $AUTOLOAD;
      $myname =~ s/.*://;    # strip fully-qualified portion
      my $obj = find_encoding($myname)
        or confess __PACKAGE__, ": unknown encoding: $myname";
      DEBUG and warn $self->{encoding}, " => ", $obj->name;
      if ( $self->{encoding} ) {
          from_to( $self->{data}, $self->{encoding}, $obj->name, 1 );
      }
      else {
          $self->{data} = $obj->encode( $self->{data}, 1 );
      }
      $self->{encoding} = $obj->name;
      return $self;
  }
  
  use overload
    q("") => sub { $_[0]->{data} },
    q(0+) => sub { use bytes(); bytes::length( $_[0]->{data} ) },
    fallback => 1,
    ;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Encoder -- Object Oriented Encoder
  
  =head1 SYNOPSIS
  
    use Encode::Encoder;
    # Encode::encode("ISO-8859-1", $data); 
    Encode::Encoder->new($data)->iso_8859_1; # OOP way
    # shortcut
    use Encode::Encoder qw(encoder);
    encoder($data)->iso_8859_1;
    # you can stack them!
    encoder($data)->iso_8859_1->base64;  # provided base64() is defined
    # you can use it as a decoder as well
    encoder($base64)->bytes('base64')->latin1;
    # stringified
    print encoder($data)->utf8->latin1;  # prints the string in latin1
    # numified
    encoder("\x{abcd}\x{ef}g")->utf8 == 6; # true. bytes::length($data)
  
  =head1 ABSTRACT
  
  B<Encode::Encoder> allows you to use Encode in an object-oriented
  style.  This is not only more intuitive than a functional approach,
  but also handier when you want to stack encodings.  Suppose you want
  your UTF-8 string converted to Latin1 then Base64: you can simply say
  
    my $base64 = encoder($utf8)->latin1->base64;
  
  instead of
  
    my $latin1 = encode("latin1", $utf8);
    my $base64 = encode_base64($utf8);
  
  or the lazier and more convoluted
  
    my $base64 = encode_base64(encode("latin1", $utf8));
  
  =head1 Description
  
  Here is how to use this module.
  
  =over 4
  
  =item *
  
  There are at least two instance variables stored in a hash reference,
  {data} and {encoding}.
  
  =item *
  
  When there is no method, it takes the method name as the name of the
  encoding and encodes the instance I<data> with I<encoding>.  If successful,
  the instance I<encoding> is set accordingly.
  
  =item *
  
  You can retrieve the result via -E<gt>data but usually you don't have to 
  because the stringify operator ("") is overridden to do exactly that.
  
  =back
  
  =head2 Predefined Methods
  
  This module predefines the methods below:
  
  =over 4
  
  =item $e = Encode::Encoder-E<gt>new([$data, $encoding]);
  
  returns an encoder object.  Its data is initialized with $data if
  present, and its encoding is set to $encoding if present.
  
  When $encoding is omitted, it defaults to utf8 if $data is already in
  utf8 or "" (empty string) otherwise.
  
  =item encoder()
  
  is an alias of Encode::Encoder-E<gt>new().  This one is exported on demand.
  
  =item $e-E<gt>data([$data])
  
  When $data is present, sets the instance data to $data and returns the
  object itself.  Otherwise, the current instance data is returned.
  
  =item $e-E<gt>encoding([$encoding])
  
  When $encoding is present, sets the instance encoding to $encoding and
  returns the object itself.  Otherwise, the current instance encoding is
  returned.
  
  =item $e-E<gt>bytes([$encoding])
  
  decodes instance data from $encoding, or the instance encoding if
  omitted.  If the conversion is successful, the instance encoding
  will be set to "".
  
  The name I<bytes> was deliberately picked to avoid namespace tainting
  -- this module may be used as a base class so method names that appear
  in Encode::Encoding are avoided.
  
  =back
  
  =head2 Example: base64 transcoder
  
  This module is designed to work with L<Encode::Encoding>.
  To make the Base64 transcoder example above really work, you could
  write a module like this:
  
    package Encode::Base64;
    use parent 'Encode::Encoding';
    __PACKAGE__->Define('base64');
    use MIME::Base64;
    sub encode{ 
        my ($obj, $data) = @_; 
        return encode_base64($data);
    }
    sub decode{
        my ($obj, $data) = @_; 
        return decode_base64($data);
    }
    1;
    __END__
  
  And your caller module would be something like this:
  
    use Encode::Encoder;
    use Encode::Base64;
  
    # now you can really do the following
  
    encoder($data)->iso_8859_1->base64;
    encoder($base64)->bytes('base64')->latin1;
  
  =head2 Operator Overloading
  
  This module overloads two operators, stringify ("") and numify (0+).
  
  Stringify dumps the data inside the object.
  
  Numify returns the number of bytes in the instance data.
  
  They come in handy when you want to print or find the size of data.
  
  =head1 SEE ALSO
  
  L<Encode>,
  L<Encode::Encoding>
  
  =cut
DARWIN-2LEVEL_ENCODE_ENCODER

$fatpacked{"darwin-2level/Encode/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_ENCODING';
  package Encode::Encoding;
  
  # Base class for classes which implement encodings
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.7 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  require Encode;
  
  sub DEBUG { 0 }
  
  sub Define {
      my $obj       = shift;
      my $canonical = shift;
      $obj = bless { Name => $canonical }, $obj unless ref $obj;
  
      # warn "$canonical => $obj\n";
      Encode::define_encoding( $obj, $canonical, @_ );
  }
  
  sub name { return shift->{'Name'} }
  
  sub mime_name{
      require Encode::MIME::Name;
      return Encode::MIME::Name::get_mime_name(shift->name);
  }
  
  # sub renew { return $_[0] }
  
  sub renew {
      my $self = shift;
      my $clone = bless {%$self} => ref($self);
      $clone->{renewed}++;    # so the caller can see it
      DEBUG and warn $clone->{renewed};
      return $clone;
  }
  
  sub renewed { return $_[0]->{renewed} || 0 }
  
  *new_sequence = \&renew;
  
  sub needs_lines { 0 }
  
  sub perlio_ok {
      eval { require PerlIO::encoding };
      return $@ ? 0 : 1;
  }
  
  # (Temporary|legacy) methods
  
  sub toUnicode   { shift->decode(@_) }
  sub fromUnicode { shift->encode(@_) }
  
  #
  # Needs to be overloaded or just croak
  #
  
  sub encode {
      require Carp;
      my $obj = shift;
      my $class = ref($obj) ? ref($obj) : $obj;
      Carp::croak( $class . "->encode() not defined!" );
  }
  
  sub decode {
      require Carp;
      my $obj = shift;
      my $class = ref($obj) ? ref($obj) : $obj;
      Carp::croak( $class . "->encode() not defined!" );
  }
  
  sub DESTROY { }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Encoding - Encode Implementation Base Class
  
  =head1 SYNOPSIS
  
    package Encode::MyEncoding;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define(qw(myCanonical myAlias));
  
  =head1 DESCRIPTION
  
  As mentioned in L<Encode>, encodings are (in the current
  implementation at least) defined as objects. The mapping of encoding
  name to object is via the C<%Encode::Encoding> hash.  Though you can
  directly manipulate this hash, it is strongly encouraged to use this
  base class module and add encode() and decode() methods.
  
  =head2 Methods you should implement
  
  You are strongly encouraged to implement methods below, at least
  either encode() or decode().
  
  =over 4
  
  =item -E<gt>encode($string [,$check])
  
  MUST return the octet sequence representing I<$string>. 
  
  =over 2
  
  =item *
  
  If I<$check> is true, it SHOULD modify I<$string> in place to remove
  the converted part (i.e.  the whole string unless there is an error).
  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If an error occurs, it SHOULD return the octet sequence for the
  fragment of string that has been converted and modify $string in-place
  to remove the converted part leaving it starting with the problem
  fragment.  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If I<$check> is false then C<encode> MUST  make a "best effort" to
  convert the string - for example, by using a replacement character.
  
  =back
  
  =item -E<gt>decode($octets [,$check])
  
  MUST return the string that I<$octets> represents.
  
  =over 2
  
  =item *
  
  If I<$check> is true, it SHOULD modify I<$octets> in place to remove
  the converted part (i.e.  the whole sequence unless there is an
  error).  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If an error occurs, it SHOULD return the fragment of string that has
  been converted and modify $octets in-place to remove the converted
  part leaving it starting with the problem fragment.  If perlio_ok() is
  true, SHOULD becomes MUST.
  
  =item *
  
  If I<$check> is false then C<decode> should make a "best effort" to
  convert the string - for example by using Unicode's "\x{FFFD}" as a
  replacement character.
  
  =back
  
  =back
  
  If you want your encoding to work with L<encoding> pragma, you should
  also implement the method below.
  
  =over 4
  
  =item -E<gt>cat_decode($destination, $octets, $offset, $terminator [,$check])
  
  MUST decode I<$octets> with I<$offset> and concatenate it to I<$destination>.
  Decoding will terminate when $terminator (a string) appears in output.
  I<$offset> will be modified to the last $octets position at end of decode.
  Returns true if $terminator appears output, else returns false.
  
  =back
  
  =head2 Other methods defined in Encode::Encodings
  
  You do not have to override methods shown below unless you have to.
  
  =over 4
  
  =item -E<gt>name
  
  Predefined As:
  
    sub name  { return shift->{'Name'} }
  
  MUST return the string representing the canonical name of the encoding.
  
  =item -E<gt>mime_name
  
  Predefined As:
  
    sub mime_name{
      require Encode::MIME::Name;
      return Encode::MIME::Name::get_mime_name(shift->name);
    }
  
  MUST return the string representing the IANA charset name of the encoding.
  
  =item -E<gt>renew
  
  Predefined As:
  
    sub renew {
      my $self = shift;
      my $clone = bless { %$self } => ref($self);
      $clone->{renewed}++;
      return $clone;
    }
  
  This method reconstructs the encoding object if necessary.  If you need
  to store the state during encoding, this is where you clone your object.
  
  PerlIO ALWAYS calls this method to make sure it has its own private
  encoding object.
  
  =item -E<gt>renewed
  
  Predefined As:
  
    sub renewed { $_[0]->{renewed} || 0 }
  
  Tells whether the object is renewed (and how many times).  Some
  modules emit C<Use of uninitialized value in null operation> warning
  unless the value is numeric so return 0 for false.
  
  =item -E<gt>perlio_ok()
  
  Predefined As:
  
    sub perlio_ok { 
        eval{ require PerlIO::encoding };
        return $@ ? 0 : 1;
    }
  
  If your encoding does not support PerlIO for some reasons, just;
  
   sub perlio_ok { 0 }
  
  =item -E<gt>needs_lines()
  
  Predefined As:
  
    sub needs_lines { 0 };
  
  If your encoding can work with PerlIO but needs line buffering, you
  MUST define this method so it returns true.  7bit ISO-2022 encodings
  are one example that needs this.  When this method is missing, false
  is assumed.
  
  =back
  
  =head2 Example: Encode::ROT13
  
    package Encode::ROT13;
    use strict;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define('rot13');
  
    sub encode($$;$){
        my ($obj, $str, $chk) = @_;
        $str =~ tr/A-Za-z/N-ZA-Mn-za-m/;
        $_[1] = '' if $chk; # this is what in-place edit means
        return $str;
    }
  
    # Jr pna or ynml yvxr guvf;
    *decode = \&encode;
  
    1;
  
  =head1 Why the heck Encode API is different?
  
  It should be noted that the I<$check> behaviour is different from the
  outer public API. The logic is that the "unchecked" case is useful
  when the encoding is part of a stream which may be reporting errors
  (e.g. STDERR).  In such cases, it is desirable to get everything
  through somehow without causing additional errors which obscure the
  original one. Also, the encoding is best placed to know what the
  correct replacement character is, so if that is the desired behaviour
  then letting low level code do it is the most efficient.
  
  By contrast, if I<$check> is true, the scheme above allows the
  encoding to do as much as it can and tell the layer above how much
  that was. What is lacking at present is a mechanism to report what
  went wrong. The most likely interface will be an additional method
  call to the object, or perhaps (to avoid forcing per-stream objects
  on otherwise stateless encodings) an additional parameter.
  
  It is also highly desirable that encoding classes inherit from
  C<Encode::Encoding> as a base class. This allows that class to define
  additional behaviour for all encoding objects.
  
    package Encode::MyEncoding;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define(qw(myCanonical myAlias));
  
  to create an object with C<< bless {Name => ...}, $class >>, and call
  define_encoding.  They inherit their C<name> method from
  C<Encode::Encoding>.
  
  =head2 Compiled Encodings
  
  For the sake of speed and efficiency, most of the encodings are now
  supported via a I<compiled form>: XS modules generated from UCM
  files.   Encode provides the enc2xs tool to achieve that.  Please see
  L<enc2xs> for more details.
  
  =head1 SEE ALSO
  
  L<perlmod>, L<enc2xs>
  
  =begin future
  
  =over 4
  
  =item Scheme 1
  
  The fixup routine gets passed the remaining fragment of string being
  processed.  It modifies it in place to remove bytes/characters it can
  understand and returns a string used to represent them.  For example:
  
   sub fixup {
     my $ch = substr($_[0],0,1,'');
     return sprintf("\x{%02X}",ord($ch);
   }
  
  This scheme is close to how the underlying C code for Encode works,
  but gives the fixup routine very little context.
  
  =item Scheme 2
  
  The fixup routine gets passed the original string, an index into
  it of the problem area, and the output string so far.  It appends
  what it wants to the output string and returns a new index into the
  original string.  For example:
  
   sub fixup {
     # my ($s,$i,$d) = @_;
     my $ch = substr($_[0],$_[1],1);
     $_[2] .= sprintf("\x{%02X}",ord($ch);
     return $_[1]+1;
   }
  
  This scheme gives maximal control to the fixup routine but is more
  complicated to code, and may require that the internals of Encode be tweaked to
  keep the original string intact.
  
  =item Other Schemes
  
  Hybrids of the above.
  
  Multiple return values rather than in-place modifications.
  
  Index into the string could be C<pos($str)> allowing C<s/\G...//>.
  
  =back
  
  =end future
  
  =cut
DARWIN-2LEVEL_ENCODE_ENCODING

$fatpacked{"darwin-2level/Encode/GSM0338.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_GSM0338';
  #
  # $Id: GSM0338.pm,v 2.5 2013/09/14 07:51:59 dankogai Exp $
  #
  package Encode::GSM0338;
  
  use strict;
  use warnings;
  use Carp;
  
  use vars qw($VERSION);
  $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('gsm0338');
  
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  use utf8;
  our %UNI2GSM = (
      "\x{0040}" => "\x00",        # COMMERCIAL AT
      "\x{000A}" => "\x0A",        # LINE FEED
      "\x{000C}" => "\x1B\x0A",    # FORM FEED
      "\x{000D}" => "\x0D",        # CARRIAGE RETURN
      "\x{0020}" => "\x20",        # SPACE
      "\x{0021}" => "\x21",        # EXCLAMATION MARK
      "\x{0022}" => "\x22",        # QUOTATION MARK
      "\x{0023}" => "\x23",        # NUMBER SIGN
      "\x{0024}" => "\x02",        # DOLLAR SIGN
      "\x{0025}" => "\x25",        # PERCENT SIGN
      "\x{0026}" => "\x26",        # AMPERSAND
      "\x{0027}" => "\x27",        # APOSTROPHE
      "\x{0028}" => "\x28",        # LEFT PARENTHESIS
      "\x{0029}" => "\x29",        # RIGHT PARENTHESIS
      "\x{002A}" => "\x2A",        # ASTERISK
      "\x{002B}" => "\x2B",        # PLUS SIGN
      "\x{002C}" => "\x2C",        # COMMA
      "\x{002D}" => "\x2D",        # HYPHEN-MINUS
      "\x{002E}" => "\x2E",        # FULL STOP
      "\x{002F}" => "\x2F",        # SOLIDUS
      "\x{0030}" => "\x30",        # DIGIT ZERO
      "\x{0031}" => "\x31",        # DIGIT ONE
      "\x{0032}" => "\x32",        # DIGIT TWO
      "\x{0033}" => "\x33",        # DIGIT THREE
      "\x{0034}" => "\x34",        # DIGIT FOUR
      "\x{0035}" => "\x35",        # DIGIT FIVE
      "\x{0036}" => "\x36",        # DIGIT SIX
      "\x{0037}" => "\x37",        # DIGIT SEVEN
      "\x{0038}" => "\x38",        # DIGIT EIGHT
      "\x{0039}" => "\x39",        # DIGIT NINE
      "\x{003A}" => "\x3A",        # COLON
      "\x{003B}" => "\x3B",        # SEMICOLON
      "\x{003C}" => "\x3C",        # LESS-THAN SIGN
      "\x{003D}" => "\x3D",        # EQUALS SIGN
      "\x{003E}" => "\x3E",        # GREATER-THAN SIGN
      "\x{003F}" => "\x3F",        # QUESTION MARK
      "\x{0041}" => "\x41",        # LATIN CAPITAL LETTER A
      "\x{0042}" => "\x42",        # LATIN CAPITAL LETTER B
      "\x{0043}" => "\x43",        # LATIN CAPITAL LETTER C
      "\x{0044}" => "\x44",        # LATIN CAPITAL LETTER D
      "\x{0045}" => "\x45",        # LATIN CAPITAL LETTER E
      "\x{0046}" => "\x46",        # LATIN CAPITAL LETTER F
      "\x{0047}" => "\x47",        # LATIN CAPITAL LETTER G
      "\x{0048}" => "\x48",        # LATIN CAPITAL LETTER H
      "\x{0049}" => "\x49",        # LATIN CAPITAL LETTER I
      "\x{004A}" => "\x4A",        # LATIN CAPITAL LETTER J
      "\x{004B}" => "\x4B",        # LATIN CAPITAL LETTER K
      "\x{004C}" => "\x4C",        # LATIN CAPITAL LETTER L
      "\x{004D}" => "\x4D",        # LATIN CAPITAL LETTER M
      "\x{004E}" => "\x4E",        # LATIN CAPITAL LETTER N
      "\x{004F}" => "\x4F",        # LATIN CAPITAL LETTER O
      "\x{0050}" => "\x50",        # LATIN CAPITAL LETTER P
      "\x{0051}" => "\x51",        # LATIN CAPITAL LETTER Q
      "\x{0052}" => "\x52",        # LATIN CAPITAL LETTER R
      "\x{0053}" => "\x53",        # LATIN CAPITAL LETTER S
      "\x{0054}" => "\x54",        # LATIN CAPITAL LETTER T
      "\x{0055}" => "\x55",        # LATIN CAPITAL LETTER U
      "\x{0056}" => "\x56",        # LATIN CAPITAL LETTER V
      "\x{0057}" => "\x57",        # LATIN CAPITAL LETTER W
      "\x{0058}" => "\x58",        # LATIN CAPITAL LETTER X
      "\x{0059}" => "\x59",        # LATIN CAPITAL LETTER Y
      "\x{005A}" => "\x5A",        # LATIN CAPITAL LETTER Z
      "\x{005F}" => "\x11",        # LOW LINE
      "\x{0061}" => "\x61",        # LATIN SMALL LETTER A
      "\x{0062}" => "\x62",        # LATIN SMALL LETTER B
      "\x{0063}" => "\x63",        # LATIN SMALL LETTER C
      "\x{0064}" => "\x64",        # LATIN SMALL LETTER D
      "\x{0065}" => "\x65",        # LATIN SMALL LETTER E
      "\x{0066}" => "\x66",        # LATIN SMALL LETTER F
      "\x{0067}" => "\x67",        # LATIN SMALL LETTER G
      "\x{0068}" => "\x68",        # LATIN SMALL LETTER H
      "\x{0069}" => "\x69",        # LATIN SMALL LETTER I
      "\x{006A}" => "\x6A",        # LATIN SMALL LETTER J
      "\x{006B}" => "\x6B",        # LATIN SMALL LETTER K
      "\x{006C}" => "\x6C",        # LATIN SMALL LETTER L
      "\x{006D}" => "\x6D",        # LATIN SMALL LETTER M
      "\x{006E}" => "\x6E",        # LATIN SMALL LETTER N
      "\x{006F}" => "\x6F",        # LATIN SMALL LETTER O
      "\x{0070}" => "\x70",        # LATIN SMALL LETTER P
      "\x{0071}" => "\x71",        # LATIN SMALL LETTER Q
      "\x{0072}" => "\x72",        # LATIN SMALL LETTER R
      "\x{0073}" => "\x73",        # LATIN SMALL LETTER S
      "\x{0074}" => "\x74",        # LATIN SMALL LETTER T
      "\x{0075}" => "\x75",        # LATIN SMALL LETTER U
      "\x{0076}" => "\x76",        # LATIN SMALL LETTER V
      "\x{0077}" => "\x77",        # LATIN SMALL LETTER W
      "\x{0078}" => "\x78",        # LATIN SMALL LETTER X
      "\x{0079}" => "\x79",        # LATIN SMALL LETTER Y
      "\x{007A}" => "\x7A",        # LATIN SMALL LETTER Z
      "\x{000C}" => "\x1B\x0A",    # FORM FEED
      "\x{005B}" => "\x1B\x3C",    # LEFT SQUARE BRACKET
      "\x{005C}" => "\x1B\x2F",    # REVERSE SOLIDUS
      "\x{005D}" => "\x1B\x3E",    # RIGHT SQUARE BRACKET
      "\x{005E}" => "\x1B\x14",    # CIRCUMFLEX ACCENT
      "\x{007B}" => "\x1B\x28",    # LEFT CURLY BRACKET
      "\x{007C}" => "\x1B\x40",    # VERTICAL LINE
      "\x{007D}" => "\x1B\x29",    # RIGHT CURLY BRACKET
      "\x{007E}" => "\x1B\x3D",    # TILDE
      "\x{00A0}" => "\x1B",        # NO-BREAK SPACE
      "\x{00A1}" => "\x40",        # INVERTED EXCLAMATION MARK
      "\x{00A3}" => "\x01",        # POUND SIGN
      "\x{00A4}" => "\x24",        # CURRENCY SIGN
      "\x{00A5}" => "\x03",        # YEN SIGN
      "\x{00A7}" => "\x5F",        # SECTION SIGN
      "\x{00BF}" => "\x60",        # INVERTED QUESTION MARK
      "\x{00C4}" => "\x5B",        # LATIN CAPITAL LETTER A WITH DIAERESIS
      "\x{00C5}" => "\x0E",        # LATIN CAPITAL LETTER A WITH RING ABOVE
      "\x{00C6}" => "\x1C",        # LATIN CAPITAL LETTER AE
      "\x{00C9}" => "\x1F",        # LATIN CAPITAL LETTER E WITH ACUTE
      "\x{00D1}" => "\x5D",        # LATIN CAPITAL LETTER N WITH TILDE
      "\x{00D6}" => "\x5C",        # LATIN CAPITAL LETTER O WITH DIAERESIS
      "\x{00D8}" => "\x0B",        # LATIN CAPITAL LETTER O WITH STROKE
      "\x{00DC}" => "\x5E",        # LATIN CAPITAL LETTER U WITH DIAERESIS
      "\x{00DF}" => "\x1E",        # LATIN SMALL LETTER SHARP S
      "\x{00E0}" => "\x7F",        # LATIN SMALL LETTER A WITH GRAVE
      "\x{00E4}" => "\x7B",        # LATIN SMALL LETTER A WITH DIAERESIS
      "\x{00E5}" => "\x0F",        # LATIN SMALL LETTER A WITH RING ABOVE
      "\x{00E6}" => "\x1D",        # LATIN SMALL LETTER AE
      #"\x{00E7}" => "\x09",        # LATIN SMALL LETTER C WITH CEDILLA
      "\x{00C7}" => "\x09",        # LATIN CAPITAL LETTER C WITH CEDILLA
      "\x{00E8}" => "\x04",        # LATIN SMALL LETTER E WITH GRAVE
      "\x{00E9}" => "\x05",        # LATIN SMALL LETTER E WITH ACUTE
      "\x{00EC}" => "\x07",        # LATIN SMALL LETTER I WITH GRAVE
      "\x{00F1}" => "\x7D",        # LATIN SMALL LETTER N WITH TILDE
      "\x{00F2}" => "\x08",        # LATIN SMALL LETTER O WITH GRAVE
      "\x{00F6}" => "\x7C",        # LATIN SMALL LETTER O WITH DIAERESIS
      "\x{00F8}" => "\x0C",        # LATIN SMALL LETTER O WITH STROKE
      "\x{00F9}" => "\x06",        # LATIN SMALL LETTER U WITH GRAVE
      "\x{00FC}" => "\x7E",        # LATIN SMALL LETTER U WITH DIAERESIS
      "\x{0393}" => "\x13",        # GREEK CAPITAL LETTER GAMMA
      "\x{0394}" => "\x10",        # GREEK CAPITAL LETTER DELTA
      "\x{0398}" => "\x19",        # GREEK CAPITAL LETTER THETA
      "\x{039B}" => "\x14",        # GREEK CAPITAL LETTER LAMDA
      "\x{039E}" => "\x1A",        # GREEK CAPITAL LETTER XI
      "\x{03A0}" => "\x16",        # GREEK CAPITAL LETTER PI
      "\x{03A3}" => "\x18",        # GREEK CAPITAL LETTER SIGMA
      "\x{03A6}" => "\x12",        # GREEK CAPITAL LETTER PHI
      "\x{03A8}" => "\x17",        # GREEK CAPITAL LETTER PSI
      "\x{03A9}" => "\x15",        # GREEK CAPITAL LETTER OMEGA
      "\x{20AC}" => "\x1B\x65",    # EURO SIGN
  );
  our %GSM2UNI = reverse %UNI2GSM;
  our $ESC    = "\x1b";
  our $ATMARK = "\x40";
  our $FBCHAR = "\x3F";
  our $NBSP   = "\x{00A0}";
  
  #define ERR_DECODE_NOMAP "%s \"\\x%02" UVXf "\" does not map to Unicode"
  
  sub decode ($$;$) {
      my ( $obj, $bytes, $chk ) = @_;
      my $str = substr($bytes, 0, 0); # to propagate taintedness;
      while ( length $bytes ) {
          my $c = substr( $bytes, 0, 1, '' );
          my $u;
          if ( $c eq "\x00" ) {
              my $c2 = substr( $bytes, 0, 1, '' );
              $u =
                  !length $c2 ? $ATMARK
                : $c2 eq "\x00" ? "\x{0000}"
                : exists $GSM2UNI{$c2} ? $ATMARK . $GSM2UNI{$c2}
                : $chk
                ? croak sprintf( "\\x%02X\\x%02X does not map to Unicode",
  			       ord($c), ord($c2) )
                : $ATMARK . $FBCHAR;
  
          }
          elsif ( $c eq $ESC ) {
              my $c2 = substr( $bytes, 0, 1, '' );
              $u =
                  exists $GSM2UNI{ $c . $c2 } ? $GSM2UNI{ $c . $c2 }
                : exists $GSM2UNI{$c2}        ? $NBSP . $GSM2UNI{$c2}
                : $chk
                ? croak sprintf( "\\x%02X\\x%02X does not map to Unicode",
  			       ord($c), ord($c2) )
                : $NBSP . $FBCHAR;
          }
          else {
              $u =
                exists $GSM2UNI{$c}
                ? $GSM2UNI{$c}
                : $chk ? ref $chk eq 'CODE'
                    ? $chk->( ord $c )
                    : croak sprintf( "\\x%02X does not map to Unicode", ord($c) )
                : $FBCHAR;
          }
          $str .= $u;
      }
      $_[1] = $bytes if $chk;
      return $str;
  }
  
  #define ERR_ENCODE_NOMAP "\"\\x{%04" UVxf "}\" does not map to %s"
  
  sub encode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      my $bytes = substr($str, 0, 0); # to propagate taintedness
      while ( length $str ) {
          my $u = substr( $str, 0, 1, '' );
          my $c;
          $bytes .=
            exists $UNI2GSM{$u}
            ? $UNI2GSM{$u}
            : $chk ? ref $chk eq 'CODE'
                ? $chk->( ord($u) )
                : croak sprintf( "\\x{%04x} does not map to %s", 
  			       ord($u), $obj->name )
            : $FBCHAR;
      }
      $_[1] = $str if $chk;
      return $bytes;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::GSM0338 -- ESTI GSM 03.38 Encoding
  
  =head1 SYNOPSIS
  
    use Encode qw/encode decode/; 
    $gsm0338 = encode("gsm0338", $utf8);    # loads Encode::GSM0338 implicitly
    $utf8    = decode("gsm0338", $gsm0338); # ditto
  
  =head1 DESCRIPTION
  
  GSM0338 is for GSM handsets. Though it shares alphanumerals with ASCII,
  control character ranges and other parts are mapped very differently,
  mainly to store Greek characters.  There are also escape sequences
  (starting with 0x1B) to cover e.g. the Euro sign.
  
  This was once handled by L<Encode::Bytes> but because of all those
  unusual specifications, Encode 2.20 has relocated the support to
  this module.
  
  =head1 NOTES
  
  Unlike most other encodings,  the following always croaks on error
  for any $chk that evaluates to true.
  
    $gsm0338 = encode("gsm0338", $utf8      $chk);
    $utf8    = decode("gsm0338", $gsm0338,  $chk);
  
  So if you want to check the validity of the encoding, surround the
  expression with C<eval {}> block as follows;
  
    eval {
      $utf8    = decode("gsm0338", $gsm0338,  $chk);
    };
    if ($@){
      # handle exception here
    }
  
  =head1 BUGS
  
  ESTI GSM 03.38 Encoding itself.
  
  Mapping \x00 to '@' causes too much pain everywhere.
  
  Its use of \x1b (escape) is also very questionable.  
  
  Because of those two, the code paging approach used use in ucm-based
  Encoding SOMETIMES fails so this module was written.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
DARWIN-2LEVEL_ENCODE_GSM0338

$fatpacked{"darwin-2level/Encode/Guess.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_GUESS';
  package Encode::Guess;
  use strict;
  use warnings;
  use Encode qw(:fallbacks find_encoding);
  our $VERSION = do { my @r = ( q$Revision: 2.6 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  my $Canon = 'Guess';
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  our %DEF_SUSPECTS = map { $_ => find_encoding($_) } qw(ascii utf8);
  $Encode::Encoding{$Canon} = bless {
      Name     => $Canon,
      Suspects => {%DEF_SUSPECTS},
  } => __PACKAGE__;
  
  use parent qw(Encode::Encoding);
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  our @EXPORT         = qw(guess_encoding);
  our $NoUTFAutoGuess = 0;
  our $UTF8_BOM       = pack( "C3", 0xef, 0xbb, 0xbf );
  
  sub import {    # Exporter not used so we do it on our own
      my $callpkg = caller;
      for my $item (@EXPORT) {
          no strict 'refs';
          *{"$callpkg\::$item"} = \&{"$item"};
      }
      set_suspects(@_);
  }
  
  sub set_suspects {
      my $class = shift;
      my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
      $self->{Suspects} = {%DEF_SUSPECTS};
      $self->add_suspects(@_);
  }
  
  sub add_suspects {
      my $class = shift;
      my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
      for my $c (@_) {
          my $e = find_encoding($c) or die "Unknown encoding: $c";
          $self->{Suspects}{ $e->name } = $e;
          DEBUG and warn "Added: ", $e->name;
      }
  }
  
  sub decode($$;$) {
      my ( $obj, $octet, $chk ) = @_;
      my $guessed = guess( $obj, $octet );
      unless ( ref($guessed) ) {
          require Carp;
          Carp::croak($guessed);
      }
      my $utf8 = $guessed->decode( $octet, $chk || 0 );
      $_[1] = $octet if $chk;
      return $utf8;
  }
  
  sub guess_encoding {
      guess( $Encode::Encoding{$Canon}, @_ );
  }
  
  sub guess {
      my $class = shift;
      my $obj   = ref($class) ? $class : $Encode::Encoding{$Canon};
      my $octet = shift;
  
      # sanity check
      return "Empty string, empty guess" unless defined $octet and length $octet;
  
      # cheat 0: utf8 flag;
      if ( Encode::is_utf8($octet) ) {
          return find_encoding('utf8') unless $NoUTFAutoGuess;
          Encode::_utf8_off($octet);
      }
  
      # cheat 1: BOM
      use Encode::Unicode;
      unless ($NoUTFAutoGuess) {
          my $BOM = pack( 'C3', unpack( "C3", $octet ) );
          return find_encoding('utf8')
            if ( defined $BOM and $BOM eq $UTF8_BOM );
          $BOM = unpack( 'N', $octet );
          return find_encoding('UTF-32')
            if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe0000 ) );
          $BOM = unpack( 'n', $octet );
          return find_encoding('UTF-16')
            if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe ) );
          if ( $octet =~ /\x00/o )
          {    # if \x00 found, we assume UTF-(16|32)(BE|LE)
              my $utf;
              my ( $be, $le ) = ( 0, 0 );
              if ( $octet =~ /\x00\x00/o ) {    # UTF-32(BE|LE) assumed
                  $utf = "UTF-32";
                  for my $char ( unpack( 'N*', $octet ) ) {
                      $char & 0x0000ffff and $be++;
                      $char & 0xffff0000 and $le++;
                  }
              }
              else {                            # UTF-16(BE|LE) assumed
                  $utf = "UTF-16";
                  for my $char ( unpack( 'n*', $octet ) ) {
                      $char & 0x00ff and $be++;
                      $char & 0xff00 and $le++;
                  }
              }
              DEBUG and warn "$utf, be == $be, le == $le";
              $be == $le
                and return
                "Encodings ambiguous between $utf BE and LE ($be, $le)";
              $utf .= ( $be > $le ) ? 'BE' : 'LE';
              return find_encoding($utf);
          }
      }
      my %try = %{ $obj->{Suspects} };
      for my $c (@_) {
          my $e = find_encoding($c) or die "Unknown encoding: $c";
          $try{ $e->name } = $e;
          DEBUG and warn "Added: ", $e->name;
      }
      my $nline = 1;
      for my $line ( split /\r\n?|\n/, $octet ) {
  
          # cheat 2 -- \e in the string
          if ( $line =~ /\e/o ) {
              my @keys = keys %try;
              delete @try{qw/utf8 ascii/};
              for my $k (@keys) {
                  ref( $try{$k} ) eq 'Encode::XS' and delete $try{$k};
              }
          }
          my %ok = %try;
  
          # warn join(",", keys %try);
          for my $k ( keys %try ) {
              my $scratch = $line;
              $try{$k}->decode( $scratch, FB_QUIET );
              if ( $scratch eq '' ) {
                  DEBUG and warn sprintf( "%4d:%-24s ok\n", $nline, $k );
              }
              else {
                  use bytes ();
                  DEBUG
                    and warn sprintf( "%4d:%-24s not ok; %d bytes left\n",
                      $nline, $k, bytes::length($scratch) );
                  delete $ok{$k};
              }
          }
          %ok or return "No appropriate encodings found!";
          if ( scalar( keys(%ok) ) == 1 ) {
              my ($retval) = values(%ok);
              return $retval;
          }
          %try = %ok;
          $nline++;
      }
      $try{ascii}
        or return "Encodings too ambiguous: ", join( " or ", keys %try );
      return $try{ascii};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Guess -- Guesses encoding from data
  
  =head1 SYNOPSIS
  
    # if you are sure $data won't contain anything bogus
  
    use Encode;
    use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
    my $utf8 = decode("Guess", $data);
    my $data = encode("Guess", $utf8);   # this doesn't work!
  
    # more elaborate way
    use Encode::Guess;
    my $enc = guess_encoding($data, qw/euc-jp shiftjis 7bit-jis/);
    ref($enc) or die "Can't guess: $enc"; # trap error this way
    $utf8 = $enc->decode($data);
    # or
    $utf8 = decode($enc->name, $data)
  
  =head1 ABSTRACT
  
  Encode::Guess enables you to guess in what encoding a given data is
  encoded, or at least tries to.  
  
  =head1 DESCRIPTION
  
  By default, it checks only ascii, utf8 and UTF-16/32 with BOM.
  
    use Encode::Guess; # ascii/utf8/BOMed UTF
  
  To use it more practically, you have to give the names of encodings to
  check (I<suspects> as follows).  The name of suspects can either be
  canonical names or aliases.
  
  CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.
  
   # tries all major Japanese Encodings as well
    use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
  
  If the C<$Encode::Guess::NoUTFAutoGuess> variable is set to a true
  value, no heuristics will be applied to UTF8/16/32, and the result
  will be limited to the suspects and C<ascii>.
  
  =over 4
  
  =item Encode::Guess->set_suspects
  
  You can also change the internal suspects list via C<set_suspects>
  method. 
  
    use Encode::Guess;
    Encode::Guess->set_suspects(qw/euc-jp shiftjis 7bit-jis/);
  
  =item Encode::Guess->add_suspects
  
  Or you can use C<add_suspects> method.  The difference is that
  C<set_suspects> flushes the current suspects list while
  C<add_suspects> adds.
  
    use Encode::Guess;
    Encode::Guess->add_suspects(qw/euc-jp shiftjis 7bit-jis/);
    # now the suspects are euc-jp,shiftjis,7bit-jis, AND
    # euc-kr,euc-cn, and big5-eten
    Encode::Guess->add_suspects(qw/euc-kr euc-cn big5-eten/);
  
  =item Encode::decode("Guess" ...)
  
  When you are content with suspects list, you can now
  
    my $utf8 = Encode::decode("Guess", $data);
  
  =item Encode::Guess->guess($data)
  
  But it will croak if:
  
  =over
  
  =item *
  
  Two or more suspects remain
  
  =item *
  
  No suspects left
  
  =back
  
  So you should instead try this;
  
    my $decoder = Encode::Guess->guess($data);
  
  On success, $decoder is an object that is documented in
  L<Encode::Encoding>.  So you can now do this;
  
    my $utf8 = $decoder->decode($data);
  
  On failure, $decoder now contains an error message so the whole thing
  would be as follows;
  
    my $decoder = Encode::Guess->guess($data);
    die $decoder unless ref($decoder);
    my $utf8 = $decoder->decode($data);
  
  =item guess_encoding($data, [, I<list of suspects>])
  
  You can also try C<guess_encoding> function which is exported by
  default.  It takes $data to check and it also takes the list of
  suspects by option.  The optional suspect list is I<not reflected> to
  the internal suspects list.
  
    my $decoder = guess_encoding($data, qw/euc-jp euc-kr euc-cn/);
    die $decoder unless ref($decoder);
    my $utf8 = $decoder->decode($data);
    # check only ascii, utf8 and UTF-(16|32) with BOM
    my $decoder = guess_encoding($data);
  
  =back
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  Because of the algorithm used, ISO-8859 series and other single-byte
  encodings do not work well unless either one of ISO-8859 is the only
  one suspect (besides ascii and utf8).
  
    use Encode::Guess;
    # perhaps ok
    my $decoder = guess_encoding($data, 'latin1');
    # definitely NOT ok
    my $decoder = guess_encoding($data, qw/latin1 greek/);
  
  The reason is that Encode::Guess guesses encoding by trial and error.
  It first splits $data into lines and tries to decode the line for each
  suspect.  It keeps it going until all but one encoding is eliminated
  out of suspects list.  ISO-8859 series is just too successful for most
  cases (because it fills almost all code points in \x00-\xff).
  
  =item *
  
  Do not mix national standard encodings and the corresponding vendor
  encodings.
  
    # a very bad idea
    my $decoder
       = guess_encoding($data, qw/shiftjis MacJapanese cp932/);
  
  The reason is that vendor encoding is usually a superset of national
  standard so it becomes too ambiguous for most cases.
  
  =item *
  
  On the other hand, mixing various national standard encodings
  automagically works unless $data is too short to allow for guessing.
  
   # This is ok if $data is long enough
   my $decoder =  
    guess_encoding($data, qw/euc-cn
                             euc-jp shiftjis 7bit-jis
                             euc-kr
                             big5-eten/);
  
  =item *
  
  DO NOT PUT TOO MANY SUSPECTS!  Don't you try something like this!
  
    my $decoder = guess_encoding($data, 
                                 Encode->encodings(":all"));
  
  =back
  
  It is, after all, just a guess.  You should alway be explicit when it
  comes to encodings.  But there are some, especially Japanese,
  environment that guess-coding is a must.  Use this module with care. 
  
  =head1 TO DO
  
  Encode::Guess does not work on EBCDIC platforms.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Encoding>
  
  =cut
  
DARWIN-2LEVEL_ENCODE_GUESS

$fatpacked{"darwin-2level/Encode/JP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_JP';
  package Encode::JP;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::JP not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Encode::JP::JIS7;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::JP - Japanese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_jp = encode("euc-jp", $utf8);   # loads Encode::JP implicitly
      $utf8   = decode("euc-jp", $euc_jp); # ditto
  
  =head1 ABSTRACT
  
  This module implements Japanese charset encodings.  Encodings
  supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-jp      /\beuc.*jp$/i	EUC (Extended Unix Character)
                /\bjp.*euc/i   
            /\bujis$/i
    shiftjis    /\bshift.*jis$/i	Shift JIS (aka MS Kanji)
            /\bsjis$/i
    7bit-jis    /\bjis$/i		7bit JIS
    iso-2022-jp			ISO-2022-JP                  [RFC1468]
                  = 7bit JIS with all Halfwidth Kana 
                    converted to Fullwidth
    iso-2022-jp-1			ISO-2022-JP-1                [RFC2237]
                                  = ISO-2022-JP with JIS X 0212-1990
                    support.  See below
    MacJapanese	                Shift JIS + Apple vendor mappings
    cp932       /\bwindows-31j$/i Code Page 932
                                  = Shift JIS + MS/IBM vendor mappings
    jis0201-raw                   JIS0201, raw format
    jis0208-raw                   JIS0201, raw format
    jis0212-raw                   JIS0201, raw format
    --------------------------------------------------------------------
  
  =head1 DESCRIPTION
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 Note on ISO-2022-JP(-1)?
  
  ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which
  adds support for JIS X 0212-1990.  That means you can use the same
  code to decode to utf8 but not vice versa.
  
    $utf8 = decode('iso-2022-jp-1', $stream);
  
  and
  
    $utf8 = decode('iso-2022-jp',   $stream);
  
  yield the same result but
  
    $with_0212 = encode('iso-2022-jp-1', $utf8);
  
  is now different from
  
    $without_0212 = encode('iso-2022-jp', $utf8 );
  
  In the latter case, characters that map to 0212 are first converted
  to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or
  'geta mark') then fed to the decoding engine.  U+FFFD is not used,
  in order to preserve text layout as much as possible.
  
  =head1 BUGS
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
DARWIN-2LEVEL_ENCODE_JP

$fatpacked{"darwin-2level/Encode/JP/H2Z.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_JP_H2Z';
  #
  # $Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
  #
  
  package Encode::JP::H2Z;
  
  use strict;
  use warnings;
  
  our $RCSID = q$Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode::CJKConstants qw(:all);
  
  use vars qw(%_D2Z  $_PAT_D2Z
    %_Z2D  $_PAT_Z2D
    %_H2Z  $_PAT_H2Z
    %_Z2H  $_PAT_Z2H);
  
  %_H2Z = (
      "\x8e\xa1" => "\xa1\xa3",    #
      "\x8e\xa2" => "\xa1\xd6",    #
      "\x8e\xa3" => "\xa1\xd7",    #
      "\x8e\xa4" => "\xa1\xa2",    #
      "\x8e\xa5" => "\xa1\xa6",    #
      "\x8e\xa6" => "\xa5\xf2",    #
      "\x8e\xa7" => "\xa5\xa1",    #
      "\x8e\xa8" => "\xa5\xa3",    #
      "\x8e\xa9" => "\xa5\xa5",    #
      "\x8e\xaa" => "\xa5\xa7",    #
      "\x8e\xab" => "\xa5\xa9",    #
      "\x8e\xac" => "\xa5\xe3",    #
      "\x8e\xad" => "\xa5\xe5",    #
      "\x8e\xae" => "\xa5\xe7",    #
      "\x8e\xaf" => "\xa5\xc3",    #
      "\x8e\xb0" => "\xa1\xbc",    #
      "\x8e\xb1" => "\xa5\xa2",    #
      "\x8e\xb2" => "\xa5\xa4",    #
      "\x8e\xb3" => "\xa5\xa6",    #
      "\x8e\xb4" => "\xa5\xa8",    #
      "\x8e\xb5" => "\xa5\xaa",    #
      "\x8e\xb6" => "\xa5\xab",    #
      "\x8e\xb7" => "\xa5\xad",    #
      "\x8e\xb8" => "\xa5\xaf",    #
      "\x8e\xb9" => "\xa5\xb1",    #
      "\x8e\xba" => "\xa5\xb3",    #
      "\x8e\xbb" => "\xa5\xb5",    #
      "\x8e\xbc" => "\xa5\xb7",    #
      "\x8e\xbd" => "\xa5\xb9",    #
      "\x8e\xbe" => "\xa5\xbb",    #
      "\x8e\xbf" => "\xa5\xbd",    #
      "\x8e\xc0" => "\xa5\xbf",    #
      "\x8e\xc1" => "\xa5\xc1",    #
      "\x8e\xc2" => "\xa5\xc4",    #
      "\x8e\xc3" => "\xa5\xc6",    #
      "\x8e\xc4" => "\xa5\xc8",    #
      "\x8e\xc5" => "\xa5\xca",    #
      "\x8e\xc6" => "\xa5\xcb",    #
      "\x8e\xc7" => "\xa5\xcc",    #
      "\x8e\xc8" => "\xa5\xcd",    #
      "\x8e\xc9" => "\xa5\xce",    #
      "\x8e\xca" => "\xa5\xcf",    #
      "\x8e\xcb" => "\xa5\xd2",    #
      "\x8e\xcc" => "\xa5\xd5",    #
      "\x8e\xcd" => "\xa5\xd8",    #
      "\x8e\xce" => "\xa5\xdb",    #
      "\x8e\xcf" => "\xa5\xde",    #
      "\x8e\xd0" => "\xa5\xdf",    #
      "\x8e\xd1" => "\xa5\xe0",    #
      "\x8e\xd2" => "\xa5\xe1",    #
      "\x8e\xd3" => "\xa5\xe2",    #
      "\x8e\xd4" => "\xa5\xe4",    #
      "\x8e\xd5" => "\xa5\xe6",    #
      "\x8e\xd6" => "\xa5\xe8",    #
      "\x8e\xd7" => "\xa5\xe9",    #
      "\x8e\xd8" => "\xa5\xea",    #
      "\x8e\xd9" => "\xa5\xeb",    #
      "\x8e\xda" => "\xa5\xec",    #
      "\x8e\xdb" => "\xa5\xed",    #
      "\x8e\xdc" => "\xa5\xef",    #
      "\x8e\xdd" => "\xa5\xf3",    #
      "\x8e\xde" => "\xa1\xab",    #
      "\x8e\xdf" => "\xa1\xac",    #
  );
  
  %_D2Z = (
      "\x8e\xb6\x8e\xde" => "\xa5\xac",    #
      "\x8e\xb7\x8e\xde" => "\xa5\xae",    #
      "\x8e\xb8\x8e\xde" => "\xa5\xb0",    #
      "\x8e\xb9\x8e\xde" => "\xa5\xb2",    #
      "\x8e\xba\x8e\xde" => "\xa5\xb4",    #
      "\x8e\xbb\x8e\xde" => "\xa5\xb6",    #
      "\x8e\xbc\x8e\xde" => "\xa5\xb8",    #
      "\x8e\xbd\x8e\xde" => "\xa5\xba",    #
      "\x8e\xbe\x8e\xde" => "\xa5\xbc",    #
      "\x8e\xbf\x8e\xde" => "\xa5\xbe",    #
      "\x8e\xc0\x8e\xde" => "\xa5\xc0",    #
      "\x8e\xc1\x8e\xde" => "\xa5\xc2",    #
      "\x8e\xc2\x8e\xde" => "\xa5\xc5",    #
      "\x8e\xc3\x8e\xde" => "\xa5\xc7",    #
      "\x8e\xc4\x8e\xde" => "\xa5\xc9",    #
      "\x8e\xca\x8e\xde" => "\xa5\xd0",    #
      "\x8e\xcb\x8e\xde" => "\xa5\xd3",    #
      "\x8e\xcc\x8e\xde" => "\xa5\xd6",    #
      "\x8e\xcd\x8e\xde" => "\xa5\xd9",    #
      "\x8e\xce\x8e\xde" => "\xa5\xdc",    #
      "\x8e\xca\x8e\xdf" => "\xa5\xd1",    #
      "\x8e\xcb\x8e\xdf" => "\xa5\xd4",    #
      "\x8e\xcc\x8e\xdf" => "\xa5\xd7",    #
      "\x8e\xcd\x8e\xdf" => "\xa5\xda",    #
      "\x8e\xce\x8e\xdf" => "\xa5\xdd",    #
      "\x8e\xb3\x8e\xde" => "\xa5\xf4",    #
  );
  
  # init only once;
  
  #$_PAT_D2Z = join("|", keys %_D2Z);
  #$_PAT_H2Z = join("|", keys %_H2Z);
  
  %_Z2H = reverse %_H2Z;
  %_Z2D = reverse %_D2Z;
  
  #$_PAT_Z2H    = join("|", keys %_Z2H);
  #$_PAT_Z2D    = join("|", keys %_Z2D);
  
  sub h2z {
      no warnings qw(uninitialized);
      my $r_str          = shift;
      my ($keep_dakuten) = @_;
      my $n              = 0;
      unless ($keep_dakuten) {
          $n = (
              $$r_str =~ s(
                 ($RE{EUC_KANA}
                  (?:\x8e[\xde\xdf])?)
                 ){
            my $str = $1;
            $_D2Z{$str} || $_H2Z{$str} || 
                # in case dakuten and handakuten are side-by-side!
                $_H2Z{substr($str,0,2)} . $_H2Z{substr($str,2,2)};
            }eogx
          );
      }
      else {
          $n = (
              $$r_str =~ s(
                 ($RE{EUC_KANA})
                 ){
            $_H2Z{$1};
            }eogx
          );
      }
      $n;
  }
  
  sub z2h {
      my $r_str = shift;
      my $n     = (
          $$r_str =~ s(
                ($RE{EUC_C}|$RE{EUC_0212}|$RE{EUC_KANA})
                ){
           $_Z2D{$1} || $_Z2H{$1} || $1;
           }eogx
      );
      $n;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*
  
  =cut
DARWIN-2LEVEL_ENCODE_JP_H2Z

$fatpacked{"darwin-2level/Encode/JP/JIS7.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_JP_JIS7';
  package Encode::JP::JIS7;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  for my $name ( '7bit-jis', 'iso-2022-jp', 'iso-2022-jp-1' ) {
      my $h2z     = ( $name eq '7bit-jis' )    ? 0 : 1;
      my $jis0212 = ( $name eq 'iso-2022-jp' ) ? 0 : 1;
  
      $Encode::Encoding{$name} = bless {
          Name    => $name,
          h2z     => $h2z,
          jis0212 => $jis0212,
      } => __PACKAGE__;
  }
  
  use parent qw(Encode::Encoding);
  
  # we override this to 1 so PerlIO works
  sub needs_lines { 1 }
  
  use Encode::CJKConstants qw(:all);
  
  #
  # decode is identical for all 2022 variants
  #
  
  sub decode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      my $residue = '';
      if ($chk) {
          $str =~ s/([^\x00-\x7f].*)$//so and $residue = $1;
      }
      $residue .= jis_euc( \$str );
      $_[1] = $residue if $chk;
      return Encode::decode( 'euc-jp', $str, FB_PERLQQ );
  }
  
  #
  # encode is different
  #
  
  sub encode($$;$) {
      require Encode::JP::H2Z;
      my ( $obj, $utf8, $chk ) = @_;
  
      # empty the input string in the stack so perlio is ok
      $_[1] = '' if $chk;
      my ( $h2z, $jis0212 ) = @$obj{qw(h2z jis0212)};
      my $octet = Encode::encode( 'euc-jp', $utf8, $chk );
      $h2z and &Encode::JP::H2Z::h2z( \$octet );
      euc_jis( \$octet, $jis0212 );
      return $octet;
  }
  
  #
  # cat_decode
  #
  my $re_scan_jis_g = qr{
     \G ( ($RE{JIS_0212}) |  $RE{JIS_0208}  |
          ($RE{ISO_ASC})  | ($RE{JIS_KANA}) | )
        ([^\e]*)
  }x;
  
  sub cat_decode {    # ($obj, $dst, $src, $pos, $trm, $chk)
      my ( $obj, undef, undef, $pos, $trm ) = @_;    # currently ignores $chk
      my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
      local ${^ENCODING};
      use bytes;
      my $opos = pos($$rsrc);
      pos($$rsrc) = $pos;
      while ( $$rsrc =~ /$re_scan_jis_g/gc ) {
          my ( $esc, $esc_0212, $esc_asc, $esc_kana, $chunk ) =
            ( $1, $2, $3, $4, $5 );
  
          unless ($chunk) { $esc or last; next; }
  
          if ( $esc && !$esc_asc ) {
              $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
              if ($esc_kana) {
                  $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
              }
              elsif ($esc_0212) {
                  $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
              }
              $chunk = Encode::decode( 'euc-jp', $chunk, 0 );
          }
          elsif ( ( my $npos = index( $chunk, $trm ) ) >= 0 ) {
              $$rdst .= substr( $chunk, 0, $npos + length($trm) );
              $$rpos += length($esc) + $npos + length($trm);
              pos($$rsrc) = $opos;
              return 1;
          }
          $$rdst .= $chunk;
          $$rpos = pos($$rsrc);
      }
      $$rpos = pos($$rsrc);
      pos($$rsrc) = $opos;
      return '';
  }
  
  # JIS<->EUC
  my $re_scan_jis = qr{
     (?:($RE{JIS_0212})|$RE{JIS_0208}|($RE{ISO_ASC})|($RE{JIS_KANA}))([^\e]*)
  }x;
  
  sub jis_euc {
      local ${^ENCODING};
      my $r_str = shift;
      $$r_str =~ s($re_scan_jis)
      {
      my ($esc_0212, $esc_asc, $esc_kana, $chunk) =
         ($1, $2, $3, $4);
      if (!$esc_asc) {
          $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
          if ($esc_kana) {
          $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
          }
          elsif ($esc_0212) {
          $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
          }
      }
      $chunk;
      }geox;
      my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
      return $residue;
  }
  
  sub euc_jis {
      no warnings qw(uninitialized);
      local ${^ENCODING};
      my $r_str   = shift;
      my $jis0212 = shift;
      $$r_str =~ s{
      ((?:$RE{EUC_C})+|(?:$RE{EUC_KANA})+|(?:$RE{EUC_0212})+)
      }{
          my $chunk = $1;
          my $esc =
          ( $chunk =~ tr/\x8E//d ) ? $ESC{KANA} :
              ( $chunk =~ tr/\x8F//d ) ? $ESC{JIS_0212} :
              $ESC{JIS_0208};
          if ($esc eq $ESC{JIS_0212} && !$jis0212){
          # fallback to '?'
          $chunk =~ tr/\xA1-\xFE/\x3F/;
          }else{
          $chunk =~ tr/\xA1-\xFE/\x21-\x7E/;
          }
          $esc . $chunk . $ESC{ASC};
      }geox;
      $$r_str =~ s/\Q$ESC{ASC}\E
          (\Q$ESC{KANA}\E|\Q$ESC{JIS_0212}\E|\Q$ESC{JIS_0208}\E)/$1/gox;
      $$r_str;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Encode::JP::JIS7 -- internally used by Encode::JP
  
  =cut
DARWIN-2LEVEL_ENCODE_JP_JIS7

$fatpacked{"darwin-2level/Encode/KR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_KR';
  package Encode::KR;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::KR not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Encode::KR::2022_KR;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::KR - Korean Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_kr = encode("euc-kr", $utf8);   # loads Encode::KR implicitly
      $utf8   = decode("euc-kr", $euc_kr); # ditto
  
  =head1 DESCRIPTION
  
  This module implements Korean charset encodings.  Encodings supported
  are as follows.
  
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-kr      /\beuc.*kr$/i	EUC (Extended Unix Character)
            /\bkr.*euc$/i
    ksc5601-raw			Korean standard code set (as is)
    cp949	      /(?:x-)?uhc$/i
                /(?:x-)?windows-949$/i
                /\bks_c_5601-1987$/i
                                  Code Page 949 (EUC-KR + 8,822 
                                  (additional Hangul syllables)
    MacKorean			EUC-KR + Apple Vendor Mappings
    johab       JOHAB             A supplementary encoding defined in 
                                               Annex 3 of KS X 1001:1998
    iso-2022-kr                   iso-2022-kr                  [RFC1557]
    --------------------------------------------------------------------
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 BUGS
  
  When you see C<charset=ks_c_5601-1987> on mails and web pages, they really
  mean "cp949" encodings.  To fix that, the following aliases are set;
  
    qr/(?:x-)?uhc$/i         => '"cp949"'
    qr/(?:x-)?windows-949$/i => '"cp949"'
    qr/ks_c_5601-1987$/i     => '"cp949"'
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
DARWIN-2LEVEL_ENCODE_KR

$fatpacked{"darwin-2level/Encode/KR/2022_KR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_KR_2022_KR';
  package Encode::KR::2022_KR;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('iso-2022-kr');
  
  sub needs_lines { 1 }
  
  sub perlio_ok {
      return 0;    # for the time being
  }
  
  sub decode {
      my ( $obj, $str, $chk ) = @_;
      my $res     = $str;
      my $residue = iso_euc( \$res );
  
      # This is for PerlIO
      $_[1] = $residue if $chk;
      return Encode::decode( 'euc-kr', $res, FB_PERLQQ );
  }
  
  sub encode {
      my ( $obj, $utf8, $chk ) = @_;
  
      # empty the input string in the stack so perlio is ok
      $_[1] = '' if $chk;
      my $octet = Encode::encode( 'euc-kr', $utf8, FB_PERLQQ );
      euc_iso( \$octet );
      return $octet;
  }
  
  use Encode::CJKConstants qw(:all);
  
  # ISO<->EUC
  
  sub iso_euc {
      my $r_str = shift;
      $$r_str =~ s/$RE{'2022_KR'}//gox;    # remove the designator
      $$r_str =~ s{                      # replace characters in GL
       \x0e                              # between SO(\x0e) and SI(\x0f)
       ([^\x0f]*)                        # with characters in GR
       \x0f
          }
      {
                          my $out= $1;
        $out =~ tr/\x21-\x7e/\xa1-\xfe/;
        $out;
      }geox;
      my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
      return $residue;
  }
  
  sub euc_iso {
      no warnings qw(uninitialized);
      my $r_str = shift;
      substr( $$r_str, 0, 0 ) =
        $ESC{'2022_KR'};    # put the designator at the beg.
      $$r_str =~
        s{                         # move KS X 1001 characters in GR to GL
          ($RE{EUC_C}+)                     # and enclose them with SO and SI
          }{
              my $str = $1;
              $str =~ tr/\xA1-\xFE/\x21-\x7E/;
              "\x0e" . $str . "\x0f";
          }geox;
      $$r_str;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::KR::2022_KR -- internally used by Encode::KR
  
  =cut
DARWIN-2LEVEL_ENCODE_KR_2022_KR

$fatpacked{"darwin-2level/Encode/MIME/Header.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_MIME_HEADER';
  package Encode::MIME::Header;
  use strict;
  use warnings;
  
  our $VERSION = do { my @r = ( q$Revision: 2.24 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Carp ();
  use Encode ();
  use MIME::Base64 ();
  
  my %seed = (
      decode_b => 1,       # decodes 'B' encoding ?
      decode_q => 1,       # decodes 'Q' encoding ?
      encode   => 'B',     # encode with 'B' or 'Q' ?
      charset  => 'UTF-8', # encode charset
      bpl      => 75,      # bytes per line
  );
  
  $Encode::Encoding{'MIME-Header'} = bless {
      %seed,
      Name     => 'MIME-Header',
  } => __PACKAGE__;
  
  $Encode::Encoding{'MIME-B'} = bless {
      %seed,
      decode_q => 0,
      Name     => 'MIME-B',
  } => __PACKAGE__;
  
  $Encode::Encoding{'MIME-Q'} = bless {
      %seed,
      decode_b => 0,
      encode   => 'Q',
      Name     => 'MIME-Q',
  } => __PACKAGE__;
  
  use parent qw(Encode::Encoding);
  
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  # RFC 2047 and RFC 2231 grammar
  my $re_charset = qr/[!"#\$%&'+\-0-9A-Z\\\^_`a-z\{\|\}~]+/;
  my $re_language = qr/[A-Za-z]{1,8}(?:-[0-9A-Za-z]{1,8})*/;
  my $re_encoding = qr/[QqBb]/;
  my $re_encoded_text = qr/[^\?]*/;
  my $re_encoded_word = qr/=\?$re_charset(?:\*$re_language)?\?$re_encoding\?$re_encoded_text\?=/;
  my $re_capture_encoded_word = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding\?$re_encoded_text)\?=/;
  my $re_capture_encoded_word_split = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding)\?($re_encoded_text)\?=/;
  
  # in strict mode check also for valid base64 characters and also for valid quoted printable codes
  my $re_encoding_strict_b = qr/[Bb]/;
  my $re_encoding_strict_q = qr/[Qq]/;
  my $re_encoded_text_strict_b = qr/[0-9A-Za-z\+\/]*={0,2}/;
  my $re_encoded_text_strict_q = qr/(?:[^\?\s=]|=[0-9A-Fa-f]{2})*/;
  my $re_encoded_word_strict = qr/=\?$re_charset(?:\*$re_language)?\?(?:$re_encoding_strict_b\?$re_encoded_text_strict_b|$re_encoding_strict_q\?$re_encoded_text_strict_q)\?=/;
  my $re_capture_encoded_word_strict = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding_strict_b\?$re_encoded_text_strict_b|$re_encoding_strict_q\?$re_encoded_text_strict_q)\?=/;
  
  my $re_newline = qr/(?:\r\n|[\r\n])/;
  
  # in strict mode encoded words must be always separated by spaces or tabs (or folded newline)
  # except in comments when separator between words and comment round brackets can be omitted
  my $re_word_begin_strict = qr/(?:(?:[ \t]|\A)\(?|(?:[^\\]|\A)\)\()/;
  my $re_word_sep_strict = qr/(?:$re_newline?[ \t])+/;
  my $re_word_end_strict = qr/(?:\)\(|\)?(?:$re_newline?[ \t]|\z))/;
  
  my $re_match = qr/()((?:$re_encoded_word\s*)*$re_encoded_word)()/;
  my $re_match_strict = qr/($re_word_begin_strict)((?:$re_encoded_word_strict$re_word_sep_strict)*$re_encoded_word_strict)(?=$re_word_end_strict)/;
  
  my $re_capture = qr/$re_capture_encoded_word(?:\s*)?/;
  my $re_capture_strict = qr/$re_capture_encoded_word_strict$re_word_sep_strict?/;
  
  our $STRICT_DECODE = 0;
  
  sub decode($$;$) {
      my ($obj, $str, $chk) = @_;
  
      my $re_match_decode = $STRICT_DECODE ? $re_match_strict : $re_match;
      my $re_capture_decode = $STRICT_DECODE ? $re_capture_strict : $re_capture;
  
      my $stop = 0;
      my $output = substr($str, 0, 0); # to propagate taintedness
  
      # decode each line separately, match whole continuous folded line at one call
      1 while not $stop and $str =~ s{^((?:[^\r\n]*(?:$re_newline[ \t])?)*)($re_newline)?}{
  
          my $line = $1;
          my $sep = defined $2 ? $2 : '';
  
          $stop = 1 unless length($line) or length($sep);
  
          # NOTE: this code partially could break $chk support
          # in non strict mode concat consecutive encoded mime words with same charset, language and encoding
          # fixes breaking inside multi-byte characters
          1 while not $STRICT_DECODE and $line =~ s/$re_capture_encoded_word_split\s*=\?\1\2\?\3\?($re_encoded_text)\?=/=\?$1$2\?$3\?$4$5\?=/so;
  
          # process sequence of encoded MIME words at once
          1 while not $stop and $line =~ s{^(.*?)$re_match_decode}{
  
              my $begin = $1 . $2;
              my $words = $3;
  
              $begin =~ tr/\r\n//d;
              $output .= $begin;
  
              # decode one MIME word
              1 while not $stop and $words =~ s{^(.*?)($re_capture_decode)}{
  
                  $output .= $1;
                  my $orig = $2;
                  my $charset = $3;
                  my ($mime_enc, $text) = split /\?/, $5;
  
                  $text =~ tr/\r\n//d;
  
                  my $enc = Encode::find_mime_encoding($charset);
  
                  # in non strict mode allow also perl encoding aliases
                  if ( not defined $enc and not $STRICT_DECODE ) {
                      # make sure that decoded string will be always strict UTF-8
                      $charset = 'UTF-8' if lc($charset) eq 'utf8';
                      $enc = Encode::find_encoding($charset);
                  }
  
                  if ( not defined $enc ) {
                      Carp::croak qq(Unknown charset "$charset") if not ref $chk and $chk & Encode::DIE_ON_ERR;
                      Carp::carp qq(Unknown charset "$charset") if not ref $chk and $chk & Encode::WARN_ON_ERR;
                      $stop = 1 if not ref $chk and $chk & Encode::RETURN_ON_ERR;
                      $output .= ($output =~ /(?:\A|[ \t])$/ ? '' : ' ') . $orig unless $stop; # $orig mime word is separated by whitespace
                      $stop ? $orig : '';
                  } else {
                      if ( uc($mime_enc) eq 'B' and $obj->{decode_b} ) {
                          my $decoded = _decode_b($enc, $text, $chk);
                          $stop = 1 if not defined $decoded and not ref $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= (defined $decoded ? $decoded : $text) unless $stop;
                          $stop ? $orig : '';
                      } elsif ( uc($mime_enc) eq 'Q' and $obj->{decode_q} ) {
                          my $decoded = _decode_q($enc, $text, $chk);
                          $stop = 1 if not defined $decoded and not ref $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= (defined $decoded ? $decoded : $text) unless $stop;
                          $stop ? $orig : '';
                      } else {
                          Carp::croak qq(MIME "$mime_enc" unsupported) if not ref $chk and $chk & Encode::DIE_ON_ERR;
                          Carp::carp qq(MIME "$mime_enc" unsupported) if not ref $chk and $chk & Encode::WARN_ON_ERR;
                          $stop = 1 if not ref $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= ($output =~ /(?:\A|[ \t])$/ ? '' : ' ') . $orig unless $stop; # $orig mime word is separated by whitespace
                          $stop ? $orig : '';
                      }
                  }
  
              }se;
  
              if ( not $stop ) {
                  $output .= $words;
                  $words = '';
              }
  
              $words;
  
          }se;
  
          if ( not $stop ) {
              $line =~ tr/\r\n//d;
              $output .= $line . $sep;
              $line = '';
              $sep = '';
          }
  
          $line . $sep;
  
      }se;
  
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return $output;
  }
  
  sub _decode_b {
      my ($enc, $text, $chk) = @_;
      # MIME::Base64::decode ignores everything after a '=' padding character
      # in non strict mode split string after each sequence of padding characters and decode each substring
      my $octets = $STRICT_DECODE ?
          MIME::Base64::decode($text) :
          join('', map { MIME::Base64::decode($_) } split /(?<==)(?=[^=])/, $text);
      return _decode_octets($enc, $octets, $chk);
  }
  
  sub _decode_q {
      my ($enc, $text, $chk) = @_;
      $text =~ s/_/ /go;
      $text =~ s/=([0-9A-Fa-f]{2})/pack('C', hex($1))/ego;
      return _decode_octets($enc, $text, $chk);
  }
  
  sub _decode_octets {
      my ($enc, $octets, $chk) = @_;
      $chk &= ~Encode::LEAVE_SRC if not ref $chk and $chk;
      local $Carp::CarpLevel = $Carp::CarpLevel + 1; # propagate Carp messages back to caller
      my $output = $enc->decode($octets, $chk);
      return undef if not ref $chk and $chk and $octets ne '';
      return $output;
  }
  
  sub encode($$;$) {
      my ($obj, $str, $chk) = @_;
      my $output = $obj->_fold_line($obj->_encode_string($str, $chk));
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return $output . substr($str, 0, 0); # to propagate taintedness
  }
  
  sub _fold_line {
      my ($obj, $line) = @_;
      my $bpl = $obj->{bpl};
      my $output = '';
  
      while ( length($line) ) {
          if ( $line =~ s/^(.{0,$bpl})(\s|\z)// ) {
              $output .= $1;
              $output .= "\r\n" . $2 if length($line);
          } elsif ( $line =~ s/(\s)(.*)$// ) {
              $output .= $line;
              $line = $2;
              $output .= "\r\n" . $1 if length($line);
          } else {
              $output .= $line;
              last;
          }
      }
  
      return $output;
  }
  
  sub _encode_string {
      my ($obj, $str, $chk) = @_;
      my $wordlen = $obj->{bpl} > 76 ? 76 : $obj->{bpl};
      my $enc = Encode::find_mime_encoding($obj->{charset});
      my $enc_chk = (not ref $chk and $chk) ? ($chk | Encode::LEAVE_SRC) : $chk;
      my @result = ();
      my $octets = '';
      while ( length( my $chr = substr($str, 0, 1, '') ) ) {
          my $seq;
          {
              local $Carp::CarpLevel = $Carp::CarpLevel + 1; # propagate Carp messages back to caller
              $seq = $enc->encode($chr, $enc_chk);
          }
          if ( not length($seq) ) {
              substr($str, 0, 0, $chr);
              last;
          }
          if ( $obj->_encoded_word_len($octets . $seq) > $wordlen ) {
              push @result, $obj->_encode_word($octets);
              $octets = '';
          }
          $octets .= $seq;
      }
      length($octets) and push @result, $obj->_encode_word($octets);
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return join(' ', @result);
  }
  
  sub _encode_word {
      my ($obj, $octets) = @_;
      my $charset = $obj->{charset};
      my $encode = $obj->{encode};
      my $text = $encode eq 'B' ? _encode_b($octets) : _encode_q($octets);
      return "=?$charset?$encode?$text?=";
  }
  
  sub _encoded_word_len {
      my ($obj, $octets) = @_;
      my $charset = $obj->{charset};
      my $encode = $obj->{encode};
      my $text_len = $encode eq 'B' ? _encoded_b_len($octets) : _encoded_q_len($octets);
      return length("=?$charset?$encode??=") + $text_len;
  }
  
  sub _encode_b {
      my ($octets) = @_;
      return MIME::Base64::encode($octets, '');
  }
  
  sub _encoded_b_len {
      my ($octets) = @_;
      return ( length($octets) + 2 ) / 3 * 4;
  }
  
  my $re_invalid_q_char = qr/[^0-9A-Za-z !*+\-\/]/;
  
  sub _encode_q {
      my ($octets) = @_;
      $octets =~ s{($re_invalid_q_char)}{
          join('', map { sprintf('=%02X', $_) } unpack('C*', $1))
      }egox;
      $octets =~ s/ /_/go;
      return $octets;
  }
  
  sub _encoded_q_len {
      my ($octets) = @_;
      my $invalid_count = () = $octets =~ /$re_invalid_q_char/sgo;
      return ( $invalid_count * 3 ) + ( length($octets) - $invalid_count );
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::MIME::Header -- MIME encoding for an unstructured email header
  
  =head1 SYNOPSIS
  
      use Encode qw(encode decode);
  
      my $mime_str = encode("MIME-Header", "Sample:Text \N{U+263A}");
      # $mime_str is "=?UTF-8?B?U2FtcGxlOlRleHQg4pi6?="
  
      my $mime_q_str = encode("MIME-Q", "Sample:Text \N{U+263A}");
      # $mime_q_str is "=?UTF-8?Q?Sample=3AText_=E2=98=BA?="
  
      my $str = decode("MIME-Header",
          "=?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=\r\n " .
          "=?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?="
      );
      # $str is "If you can read this you understand the example."
  
      use Encode qw(decode :fallbacks);
      use Encode::MIME::Header;
      local $Encode::MIME::Header::STRICT_DECODE = 1;
      my $strict_string = decode("MIME-Header", $mime_string, FB_CROAK);
      # use strict decoding and croak on errors
  
  =head1 ABSTRACT
  
  This module implements L<RFC 2047|https://tools.ietf.org/html/rfc2047> MIME
  encoding for an unstructured field body of the email header.  It can also be
  used for L<RFC 822|https://tools.ietf.org/html/rfc822> 'text' token.  However,
  it cannot be used directly for the whole header with the field name or for the
  structured header fields like From, To, Cc, Message-Id, etc...  There are 3
  encoding names supported by this module: C<MIME-Header>, C<MIME-B> and
  C<MIME-Q>.
  
  =head1 DESCRIPTION
  
  Decode method takes an unstructured field body of the email header (or
  L<RFC 822|https://tools.ietf.org/html/rfc822> 'text' token) as its input and
  decodes each MIME encoded-word from input string to a sequence of bytes
  according to L<RFC 2047|https://tools.ietf.org/html/rfc2047> and
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>.  Subsequently, each sequence
  of bytes with the corresponding MIME charset is decoded with
  L<the Encode module|Encode> and finally, one output string is returned.  Text
  parts of the input string which do not contain MIME encoded-word stay
  unmodified in the output string.  Folded newlines between two consecutive MIME
  encoded-words are discarded, others are preserved in the output string.
  C<MIME-B> can decode Base64 variant, C<MIME-Q> can decode Quoted-Printable
  variant and C<MIME-Header> can decode both of them.  If L<Encode module|Encode>
  does not support particular MIME charset or chosen variant then an action based
  on L<CHECK flags|Encode/Handling Malformed Data> is performed (by default, the
  MIME encoded-word is not decoded).
  
  Encode method takes a scalar string as its input and uses
  L<strict UTF-8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder for encoding it to UTF-8
  bytes.  Then a sequence of UTF-8 bytes is encoded into MIME encoded-words
  (C<MIME-Header> and C<MIME-B> use a Base64 variant while C<MIME-Q> uses a
  Quoted-Printable variant) where each MIME encoded-word is limited to 75
  characters.  MIME encoded-words are separated by C<CRLF SPACE> and joined to
  one output string.  Output string is suitable for unstructured field body of
  the email header.
  
  Both encode and decode methods propagate
  L<CHECK flags|Encode/Handling Malformed Data> when encoding and decoding the
  MIME charset.
  
  =head1 BUGS
  
  Versions prior to 2.22 (part of Encode 2.83) have a malfunctioning decoder
  and encoder.  The MIME encoder infamously inserted additional spaces or
  discarded white spaces between consecutive MIME encoded-words, which led to
  invalid MIME headers produced by this module.  The MIME decoder had a tendency
  to discard white spaces, incorrectly interpret data or attempt to decode Base64
  MIME encoded-words as Quoted-Printable.  These problems were fixed in version
  2.22.  It is highly recommended not to use any version prior 2.22!
  
  Versions prior to 2.24 (part of Encode 2.87) ignored
  L<CHECK flags|Encode/Handling Malformed Data>.  The MIME encoder used
  L<not strict utf8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder for input Unicode
  strings which could lead to invalid UTF-8 sequences.  MIME decoder used also
  L<not strict utf8|Encode/UTF-8 vs. utf8 vs. UTF8> decoder and additionally
  called the decode method with a C<Encode::FB_PERLQQ> flag (thus user-specified
  L<CHECK flags|Encode/Handling Malformed Data> were ignored).  Moreover, it
  automatically croaked when a MIME encoded-word contained unknown encoding.
  Since version 2.24, this module uses
  L<strict UTF-8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder and decoder.  And
  L<CHECK flags|Encode/Handling Malformed Data> are correctly propagated.
  
  Since version 2.22 (part of Encode 2.83), the MIME encoder should be fully
  compliant to L<RFC 2047|https://tools.ietf.org/html/rfc2047> and
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>.  Due to the aforementioned
  bugs in previous versions of the MIME encoder, there is a I<less strict>
  compatible mode for the MIME decoder which is used by default.  It should be
  able to decode MIME encoded-words encoded by pre 2.22 versions of this module.
  However, note that this is not correct according to
  L<RFC 2047|https://tools.ietf.org/html/rfc2047>.
  
  In default I<not strict> mode the MIME decoder attempts to decode every substring
  which looks like a MIME encoded-word.  Therefore, the MIME encoded-words do not
  need to be separated by white space.  To enforce a correct I<strict> mode, set
  variable C<$Encode::MIME::Header::STRICT_DECODE> to 1 e.g. by localizing:
  
    use Encode::MIME::Header;
    local $Encode::MIME::Header::STRICT_DECODE = 1;
  
  =head1 AUTHORS
  
  Pali E<lt>pali@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Encode>,
  L<RFC 822|https://tools.ietf.org/html/rfc822>,
  L<RFC 2047|https://tools.ietf.org/html/rfc2047>,
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>
  
  =cut
DARWIN-2LEVEL_ENCODE_MIME_HEADER

$fatpacked{"darwin-2level/Encode/MIME/Header/ISO_2022_JP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_MIME_HEADER_ISO_2022_JP';
  package Encode::MIME::Header::ISO_2022_JP;
  
  use strict;
  use warnings;
  
  use parent qw(Encode::MIME::Header);
  
  $Encode::Encoding{'MIME-Header-ISO_2022_JP'} =
    bless { decode_b => '1', decode_q => '1', encode => 'B', bpl => 76, Name => 'MIME-Header-ISO_2022_JP' } =>
    __PACKAGE__;
  
  use constant HEAD => '=?ISO-2022-JP?B?';
  use constant TAIL => '?=';
  
  use Encode::CJKConstants qw(%RE);
  
  our $VERSION = do { my @r = ( q$Revision: 1.7 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  # I owe the below codes totally to
  #   Jcode by Dan Kogai & http://www.din.or.jp/~ohzaki/perl.htm#JP_Base64
  
  sub encode {
      my $self = shift;
      my $str  = shift;
  
      utf8::encode($str) if ( Encode::is_utf8($str) );
      Encode::from_to( $str, 'utf8', 'euc-jp' );
  
      my ($trailing_crlf) = ( $str =~ /(\n|\r|\x0d\x0a)$/o );
  
      $str = _mime_unstructured_header( $str, $self->{bpl} );
  
      not $trailing_crlf and $str =~ s/(\n|\r|\x0d\x0a)$//o;
  
      return $str;
  }
  
  sub _mime_unstructured_header {
      my ( $oldheader, $bpl ) = @_;
      my $crlf = $oldheader =~ /\n$/;
      my ( $header, @words, @wordstmp, $i ) = ('');
  
      $oldheader =~ s/\s+$//;
  
      @wordstmp = split /\s+/, $oldheader;
  
      for ( $i = 0 ; $i < $#wordstmp ; $i++ ) {
          if (    $wordstmp[$i] !~ /^[\x21-\x7E]+$/
              and $wordstmp[ $i + 1 ] !~ /^[\x21-\x7E]+$/ )
          {
              $wordstmp[ $i + 1 ] = "$wordstmp[$i] $wordstmp[$i + 1]";
          }
          else {
              push( @words, $wordstmp[$i] );
          }
      }
  
      push( @words, $wordstmp[-1] );
  
      for my $word (@words) {
          if ( $word =~ /^[\x21-\x7E]+$/ ) {
              $header =~ /(?:.*\n)*(.*)/;
              if ( length($1) + length($word) > $bpl ) {
                  $header .= "\n $word";
              }
              else {
                  $header .= $word;
              }
          }
          else {
              $header = _add_encoded_word( $word, $header, $bpl );
          }
  
          $header =~ /(?:.*\n)*(.*)/;
  
          if ( length($1) == $bpl ) {
              $header .= "\n ";
          }
          else {
              $header .= ' ';
          }
      }
  
      $header =~ s/\n? $//mg;
  
      $crlf ? "$header\n" : $header;
  }
  
  sub _add_encoded_word {
      my ( $str, $line, $bpl ) = @_;
      my $result = '';
  
      while ( length($str) ) {
          my $target = $str;
          $str = '';
  
          if (
              length($line) + 22 +
              ( $target =~ /^(?:$RE{EUC_0212}|$RE{EUC_C})/o ) * 8 > $bpl )
          {
              $line =~ s/[ \t\n\r]*$/\n/;
              $result .= $line;
              $line = ' ';
          }
  
          while (1) {
              my $iso_2022_jp = $target;
              Encode::from_to( $iso_2022_jp, 'euc-jp', 'iso-2022-jp' );
  
              my $encoded =
                HEAD . MIME::Base64::encode_base64( $iso_2022_jp, '' ) . TAIL;
  
              if ( length($encoded) + length($line) > $bpl ) {
                  $target =~
                    s/($RE{EUC_0212}|$RE{EUC_KANA}|$RE{EUC_C}|$RE{ASCII})$//o;
                  $str = $1 . $str;
              }
              else {
                  $line .= $encoded;
                  last;
              }
          }
  
      }
  
      $result . $line;
  }
  
  1;
  __END__
  
DARWIN-2LEVEL_ENCODE_MIME_HEADER_ISO_2022_JP

$fatpacked{"darwin-2level/Encode/MIME/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_MIME_NAME';
  package Encode::MIME::Name;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 1.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  # NOTE: This table must be 1:1 mapping
  our %MIME_NAME_OF = (
      'AdobeStandardEncoding' => 'Adobe-Standard-Encoding',
      'AdobeSymbol'           => 'Adobe-Symbol-Encoding',
      'ascii'                 => 'US-ASCII',
      'big5-hkscs'            => 'Big5-HKSCS',
      'cp1026'                => 'IBM1026',
      'cp1047'                => 'IBM1047',
      'cp1250'                => 'windows-1250',
      'cp1251'                => 'windows-1251',
      'cp1252'                => 'windows-1252',
      'cp1253'                => 'windows-1253',
      'cp1254'                => 'windows-1254',
      'cp1255'                => 'windows-1255',
      'cp1256'                => 'windows-1256',
      'cp1257'                => 'windows-1257',
      'cp1258'                => 'windows-1258',
      'cp37'                  => 'IBM037',
      'cp424'                 => 'IBM424',
      'cp437'                 => 'IBM437',
      'cp500'                 => 'IBM500',
      'cp775'                 => 'IBM775',
      'cp850'                 => 'IBM850',
      'cp852'                 => 'IBM852',
      'cp855'                 => 'IBM855',
      'cp857'                 => 'IBM857',
      'cp860'                 => 'IBM860',
      'cp861'                 => 'IBM861',
      'cp862'                 => 'IBM862',
      'cp863'                 => 'IBM863',
      'cp864'                 => 'IBM864',
      'cp865'                 => 'IBM865',
      'cp866'                 => 'IBM866',
      'cp869'                 => 'IBM869',
      'cp936'                 => 'GBK',
      'euc-jp'                => 'EUC-JP',
      'euc-kr'                => 'EUC-KR',
      #'gb2312-raw'            => 'GB2312', # no, you're wrong, I18N::Charset
      'hp-roman8'             => 'hp-roman8',
      'hz'                    => 'HZ-GB-2312',
      'iso-2022-jp'           => 'ISO-2022-JP',
      'iso-2022-jp-1'         => 'ISO-2022-JP-1',
      'iso-2022-kr'           => 'ISO-2022-KR',
      'iso-8859-1'            => 'ISO-8859-1',
      'iso-8859-10'           => 'ISO-8859-10',
      'iso-8859-13'           => 'ISO-8859-13',
      'iso-8859-14'           => 'ISO-8859-14',
      'iso-8859-15'           => 'ISO-8859-15',
      'iso-8859-16'           => 'ISO-8859-16',
      'iso-8859-2'            => 'ISO-8859-2',
      'iso-8859-3'            => 'ISO-8859-3',
      'iso-8859-4'            => 'ISO-8859-4',
      'iso-8859-5'            => 'ISO-8859-5',
      'iso-8859-6'            => 'ISO-8859-6',
      'iso-8859-7'            => 'ISO-8859-7',
      'iso-8859-8'            => 'ISO-8859-8',
      'iso-8859-9'            => 'ISO-8859-9',
      #'jis0201-raw'           => 'JIS_X0201',
      #'jis0208-raw'           => 'JIS_C6226-1983',
      #'jis0212-raw'           => 'JIS_X0212-1990',
      'koi8-r'                => 'KOI8-R',
      'koi8-u'                => 'KOI8-U',
      #'ksc5601-raw'           => 'KS_C_5601-1987',
      'shiftjis'              => 'Shift_JIS',
      'UTF-16'                => 'UTF-16',
      'UTF-16BE'              => 'UTF-16BE',
      'UTF-16LE'              => 'UTF-16LE',
      'UTF-32'                => 'UTF-32',
      'UTF-32BE'              => 'UTF-32BE',
      'UTF-32LE'              => 'UTF-32LE',
      'UTF-7'                 => 'UTF-7',
      'utf-8-strict'          => 'UTF-8',
      'viscii'                => 'VISCII',
  );
  
  # NOTE: %MIME_NAME_OF is still 1:1 mapping
  our %ENCODE_NAME_OF = map { uc $MIME_NAME_OF{$_} => $_ } keys %MIME_NAME_OF;
  
  # Add additional 1:N mapping
  $MIME_NAME_OF{'utf8'} = 'UTF-8';
  
  sub get_mime_name($) { $MIME_NAME_OF{$_[0]} };
  
  sub get_encode_name($) { $ENCODE_NAME_OF{uc $_[0]} };
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::MIME::NAME -- internally used by Encode
  
  =head1 SEE ALSO
  
  L<I18N::Charset>
  
  =cut
DARWIN-2LEVEL_ENCODE_MIME_NAME

$fatpacked{"darwin-2level/Encode/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_SYMBOL';
  package Encode::Symbol;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Symbol - Symbol Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $symbol  = encode("symbol", $utf8); # loads Encode::Symbol implicitly
      $utf8 = decode("", $symbol);        # ditto
  
  =head1 ABSTRACT
  
  This module implements symbol and dingbats encodings.  Encodings
  supported are as follows.   
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    symbol
    dingbats
    AdobeZDingbat
    AdobeSymbol
    MacDingbats
  
  =head1 DESCRIPTION
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
DARWIN-2LEVEL_ENCODE_SYMBOL

$fatpacked{"darwin-2level/Encode/TW.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_TW';
  package Encode::TW;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::TW not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::TW - Taiwan-based Chinese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $big5 = encode("big5", $utf8); # loads Encode::TW implicitly
      $utf8 = decode("big5", $big5); # ditto
  
  =head1 DESCRIPTION
  
  This module implements tradition Chinese charset encodings as used
  in Taiwan and Hong Kong.
  Encodings supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    big5-eten   /\bbig-?5$/i	Big5 encoding (with ETen extensions)
            /\bbig5-?et(en)?$/i
            /\btca-?big5$/i
    big5-hkscs  /\bbig5-?hk(scs)?$/i
                /\bhk(scs)?-?big5$/i
                                  Big5 + Cantonese characters in Hong Kong
    MacChineseTrad		Big5 + Apple Vendor Mappings
    cp950		                Code Page 950 
                                  = Big5 + Microsoft vendor mappings
    --------------------------------------------------------------------
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 NOTES
  
  Due to size concerns, C<EUC-TW> (Extended Unix Character), C<CCCII>
  (Chinese Character Code for Information Interchange), C<BIG5PLUS>
  (CMEX's Big5+) and C<BIG5EXT> (CMEX's Big5e) are distributed separately
  on CPAN, under the name L<Encode::HanExtra>. That module also contains
  extra China-based encodings.
  
  =head1 BUGS
  
  Since the original C<big5> encoding (1984) is not supported anywhere
  (glibc and DOS-based systems uses C<big5> to mean C<big5-eten>; Microsoft
  uses C<big5> to mean C<cp950>), a conscious decision was made to alias
  C<big5> to C<big5-eten>, which is the de facto superset of the original
  big5.
  
  The C<CNS11643> encoding files are not complete. For common C<CNS11643>
  manipulation, please use C<EUC-TW> in L<Encode::HanExtra>, which contains
  planes 1-7.
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
DARWIN-2LEVEL_ENCODE_TW

$fatpacked{"darwin-2level/Encode/Unicode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_UNICODE';
  package Encode::Unicode;
  
  use strict;
  use warnings;
  no warnings 'redefine';
  
  our $VERSION = do { my @r = ( q$Revision: 2.15 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  #
  # Object Generator 8 transcoders all at once!
  #
  
  require Encode;
  
  our %BOM_Unknown = map { $_ => 1 } qw(UTF-16 UTF-32);
  
  for my $name (
      qw(UTF-16 UTF-16BE UTF-16LE
      UTF-32 UTF-32BE UTF-32LE
      UCS-2BE  UCS-2LE)
    )
  {
      my ( $size, $endian, $ucs2, $mask );
      $name =~ /^(\w+)-(\d+)(\w*)$/o;
      if ( $ucs2 = ( $1 eq 'UCS' ) ) {
          $size = 2;
      }
      else {
          $size = $2 / 8;
      }
      $endian = ( $3 eq 'BE' ) ? 'n' : ( $3 eq 'LE' ) ? 'v' : '';
      $size == 4 and $endian = uc($endian);
  
      $Encode::Encoding{$name} = bless {
          Name   => $name,
          size   => $size,
          endian => $endian,
          ucs2   => $ucs2,
      } => __PACKAGE__;
  }
  
  use parent qw(Encode::Encoding);
  
  sub renew {
      my $self = shift;
      $BOM_Unknown{ $self->name } or return $self;
      my $clone = bless {%$self} => ref($self);
      $clone->{renewed}++;    # so the caller knows it is renewed.
      return $clone;
  }
  
  # There used to be a perl implementation of (en|de)code but with
  # XS version is ripe, perl version is zapped for optimal speed
  
  *decode = \&decode_xs;
  *encode = \&encode_xs;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Unicode -- Various Unicode Transformation Formats
  
  =cut
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/;
      $ucs2 = encode("UCS-2BE", $utf8);
      $utf8 = decode("UCS-2BE", $ucs2);
  
  =head1 ABSTRACT
  
  This module implements all Character Encoding Schemes of Unicode that
  are officially documented by Unicode Consortium (except, of course,
  for UTF-8, which is a native format in perl).
  
  =over 4
  
  =item L<http://www.unicode.org/glossary/> says:
  
  I<Character Encoding Scheme> A character encoding form plus byte
  serialization. There are Seven character encoding schemes in Unicode:
  UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and
  UTF-32LE (UCS-4LE), and UTF-7.
  
  Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of
  Unicode's Character Encoding Scheme.  It is separately implemented in
  Encode::Unicode::UTF7.  For details see L<Encode::Unicode::UTF7>.
  
  =item Quick Reference
  
                  Decodes from ord(N)           Encodes chr(N) to...
         octet/char BOM S.P d800-dfff  ord > 0xffff     \x{1abcd} ==
    ---------------+-----------------+------------------------------
    UCS-2BE       2   N   N  is bogus                  Not Available
    UCS-2LE       2   N   N     bogus                  Not Available
    UTF-16      2/4   Y   Y  is   S.P           S.P            BE/LE
    UTF-16BE    2/4   N   Y       S.P           S.P    0xd82a,0xdfcd
    UTF-16LE    2/4   N   Y       S.P           S.P    0x2ad8,0xcddf
    UTF-32        4   Y   -  is bogus         As is            BE/LE
    UTF-32BE      4   N   -     bogus         As is       0x0001abcd
    UTF-32LE      4   N   -     bogus         As is       0xcdab0100
    UTF-8       1-4   -   -     bogus   >= 4 octets   \xf0\x9a\af\8d
    ---------------+-----------------+------------------------------
  
  =back
  
  =head1 Size, Endianness, and BOM
  
  You can categorize these CES by 3 criteria:  size of each character,
  endianness, and Byte Order Mark.
  
  =head2 by size
  
  UCS-2 is a fixed-length encoding with each character taking 16 bits.
  It B<does not> support I<surrogate pairs>.  When a surrogate pair
  is encountered during decode(), its place is filled with \x{FFFD}
  if I<CHECK> is 0, or the routine croaks if I<CHECK> is 1.  When a
  character whose ord value is larger than 0xFFFF is encountered,
  its place is filled with \x{FFFD} if I<CHECK> is 0, or the routine
  croaks if I<CHECK> is 1.
  
  UTF-16 is almost the same as UCS-2 but it supports I<surrogate pairs>.
  When it encounters a high surrogate (0xD800-0xDBFF), it fetches the
  following low surrogate (0xDC00-0xDFFF) and C<desurrogate>s them to
  form a character.  Bogus surrogates result in death.  When \x{10000}
  or above is encountered during encode(), it C<ensurrogate>s them and
  pushes the surrogate pair to the output stream.
  
  UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits.
  Since it is 32-bit, there is no need for I<surrogate pairs>.
  
  =head2 by endianness
  
  The first (and now failed) goal of Unicode was to map all character
  repertoires into a fixed-length integer so that programmers are happy.
  Since each character is either a I<short> or I<long> in C, you have to
  pay attention to the endianness of each platform when you pass data
  to one another.
  
  Anything marked as BE is Big Endian (or network byte order) and LE is
  Little Endian (aka VAX byte order).  For anything not marked either
  BE or LE, a character called Byte Order Mark (BOM) indicating the
  endianness is prepended to the string.
  
  CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is meaningless
  and as of this writing Encode suite just leave it as is (\x{FeFF}).
  
  =over 4
  
  =item BOM as integer when fetched in network byte order
  
                16         32 bits/char
    -------------------------
    BE      0xFeFF 0x0000FeFF
    LE      0xFFFe 0xFFFe0000
    -------------------------
  
  =back
  
  This modules handles the BOM as follows.
  
  =over 4
  
  =item *
  
  When BE or LE is explicitly stated as the name of encoding, BOM is
  simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).
  
  =item *
  
  When BE or LE is omitted during decode(), it checks if BOM is at the
  beginning of the string; if one is found, the endianness is set to
  what the BOM says.  
  
  =item *
  
  Default Byte Order
  
  When no BOM is found, Encode 2.76 and blow croaked.  Since Encode
  2.77, it falls back to BE accordingly to RFC2781 and the Unicode
  Standard version 8.0
  
  =item *
  
  When BE or LE is omitted during encode(), it returns a BE-encoded
  string with BOM prepended.  So when you want to encode a whole text
  file, make sure you encode() the whole text at once, not line by line
  or each line, not file, will have a BOM prepended.
  
  =item *
  
  C<UCS-2> is an exception.  Unlike others, this is an alias of UCS-2BE.
  UCS-2 is already registered by IANA and others that way.
  
  =back
  
  =head1 Surrogate Pairs
  
  To say the least, surrogate pairs were the biggest mistake of the
  Unicode Consortium.  But according to the late Douglas Adams in I<The
  Hitchhiker's Guide to the Galaxy> Trilogy, C<In the beginning the
  Universe was created. This has made a lot of people very angry and
  been widely regarded as a bad move>.  Their mistake was not of this
  magnitude so let's forgive them.
  
  (I don't dare make any comparison with Unicode Consortium and the
  Vogons here ;)  Or, comparing Encode to Babel Fish is completely
  appropriate -- if you can only stick this into your ear :)
  
  Surrogate pairs were born when the Unicode Consortium finally
  admitted that 16 bits were not big enough to hold all the world's
  character repertoires.  But they already made UCS-2 16-bit.  What
  do we do?
  
  Back then, the range 0xD800-0xDFFF was not allocated.  Let's split
  that range in half and use the first half to represent the C<upper
  half of a character> and the second half to represent the C<lower
  half of a character>.  That way, you can represent 1024 * 1024 =
  1048576 more characters.  Now we can store character ranges up to
  \x{10ffff} even with 16-bit encodings.  This pair of half-character is
  now called a I<surrogate pair> and UTF-16 is the name of the encoding
  that embraces them.
  
  Here is a formula to ensurrogate a Unicode character \x{10000} and
  above;
  
    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
  
  And to desurrogate;
  
   $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
  
  Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but
  perl does not prohibit the use of characters within this range.  To perl,
  every one of \x{0000_0000} up to \x{ffff_ffff} (*) is I<a character>.
  
    (*) or \x{ffff_ffff_ffff_ffff} if your perl is compiled with 64-bit
    integer support!
  
  =head1 Error Checking
  
  Unlike most encodings which accept various ways to handle errors,
  Unicode encodings simply croaks.
  
    % perl -MEncode -e'$_ = "\xfe\xff\xd8\xd9\xda\xdb\0\n"' \
           -e'Encode::from_to($_, "utf16","shift_jis", 0); print'
    UTF-16:Malformed LO surrogate d8d9 at /path/to/Encode.pm line 184.
    % perl -MEncode -e'$a = "BOM missing"' \
           -e' Encode::from_to($a, "utf16", "shift_jis", 0); print'
    UTF-16:Unrecognised BOM 424f at /path/to/Encode.pm line 184.
  
  Unlike other encodings where mappings are not one-to-one against
  Unicode, UTFs are supposed to map 100% against one another.  So Encode
  is more strict on UTFs.
  
  Consider that "division by zero" of Encode :)
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Unicode::UTF7>, L<http://www.unicode.org/glossary/>,
  L<http://www.unicode.org/unicode/faq/utf_bom.html>,
  
  RFC 2781 L<http://www.ietf.org/rfc/rfc2781.txt>,
  
  The whole Unicode standard L<http://www.unicode.org/unicode/uni2book/u2.html>
  
  Ch. 15, pp. 403 of C<Programming Perl (3rd Edition)>
  by Larry Wall, Tom Christiansen, Jon Orwant;
  O'Reilly & Associates; ISBN 0-596-00027-8
  
  =cut
DARWIN-2LEVEL_ENCODE_UNICODE

$fatpacked{"darwin-2level/Encode/Unicode/UTF7.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODE_UNICODE_UTF7';
  #
  # $Id: UTF7.pm,v 2.8 2013/09/14 07:51:59 dankogai Exp $
  #
  package Encode::Unicode::UTF7;
  use strict;
  use warnings;
  no warnings 'redefine';
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('UTF-7');
  our $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use MIME::Base64;
  use Encode;
  
  #
  # Algorithms taken from Unicode::String by Gisle Aas
  #
  
  our $OPTIONAL_DIRECT_CHARS = 1;
  my $specials = quotemeta "\'(),-./:?";
  $OPTIONAL_DIRECT_CHARS
    and $specials .= quotemeta "!\"#$%&*;<=>@[]^_`{|}";
  
  # \s will not work because it matches U+3000 DEOGRAPHIC SPACE
  # We use qr/[\n\r\t\ ] instead
  my $re_asis    = qr/(?:[\n\r\t\ A-Za-z0-9$specials])/;
  my $re_encoded = qr/(?:[^\n\r\t\ A-Za-z0-9$specials])/;
  my $e_utf16    = find_encoding("UTF-16BE");
  
  sub needs_lines { 1 }
  
  sub encode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      my $len = length($str);
      pos($str) = 0;
      my $bytes = substr($str, 0, 0); # to propagate taintedness
      while ( pos($str) < $len ) {
          if ( $str =~ /\G($re_asis+)/ogc ) {
  	    my $octets = $1;
  	    utf8::downgrade($octets);
  	    $bytes .= $octets;
          }
          elsif ( $str =~ /\G($re_encoded+)/ogsc ) {
              if ( $1 eq "+" ) {
                  $bytes .= "+-";
              }
              else {
                  my $s = $1;
                  my $base64 = encode_base64( $e_utf16->encode($s), '' );
                  $base64 =~ s/=+$//;
                  $bytes .= "+$base64-";
              }
          }
          else {
              die "This should not happen! (pos=" . pos($str) . ")";
          }
      }
      $_[1] = '' if $chk;
      return $bytes;
  }
  
  sub decode($$;$) {
      use re 'taint';
      my ( $obj, $bytes, $chk ) = @_;
      my $len = length($bytes);
      my $str = substr($bytes, 0, 0); # to propagate taintedness;
      pos($bytes) = 0;
      no warnings 'uninitialized';
      while ( pos($bytes) < $len ) {
          if ( $bytes =~ /\G([^+]+)/ogc ) {
              $str .= $1;
          }
          elsif ( $bytes =~ /\G\+-/ogc ) {
              $str .= "+";
          }
          elsif ( $bytes =~ /\G\+([A-Za-z0-9+\/]+)-?/ogsc ) {
              my $base64 = $1;
              my $pad    = length($base64) % 4;
              $base64 .= "=" x ( 4 - $pad ) if $pad;
              $str .= $e_utf16->decode( decode_base64($base64) );
          }
          elsif ( $bytes =~ /\G\+/ogc ) {
              $^W and warn "Bad UTF7 data escape";
              $str .= "+";
          }
          else {
              die "This should not happen " . pos($bytes);
          }
      }
      $_[1] = '' if $chk;
      return $str;
  }
  1;
  __END__
  
  =head1 NAME
  
  Encode::Unicode::UTF7 -- UTF-7 encoding
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $utf7 = encode("UTF-7", $utf8);
      $utf8 = decode("UTF-7", $ucs2);
  
  =head1 ABSTRACT
  
  This module implements UTF-7 encoding documented in RFC 2152.  UTF-7,
  as its name suggests, is a 7-bit re-encoded version of UTF-16BE.  It
  is designed to be MTA-safe and expected to be a standard way to
  exchange Unicoded mails via mails.  But with the advent of UTF-8 and
  8-bit compliant MTAs, UTF-7 is hardly ever used.
  
  UTF-7 was not supported by Encode until version 1.95 because of that.
  But Unicode::String, a module by Gisle Aas which adds Unicode supports
  to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added
  so Encode can supersede Unicode::String 100%.
  
  =head1 In Practice
  
  When you want to encode Unicode for mails and web pages, however, do
  not use UTF-7 unless you are sure your recipients and readers can
  handle it.  Very few MUAs and WWW Browsers support these days (only
  Mozilla seems to support one).  For general cases, use UTF-8 for
  message body and MIME-Header for header instead.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Unicode>, L<Unicode::String>
  
  RFC 2781 L<http://www.ietf.org/rfc/rfc2152.txt>
  
  =cut
DARWIN-2LEVEL_ENCODE_UNICODE_UTF7

$fatpacked{"darwin-2level/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin',
  	      amigaos => 'AmigaOS');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC

$fatpacked{"darwin-2level/File/Spec/AmigaOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_AMIGAOS';
  package File::Spec::AmigaOS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::AmigaOS - File::Spec for AmigaOS
  
  =head1 SYNOPSIS
  
   require File::Spec::AmigaOS; # Done automatically by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item tmpdir
  
  Returns $ENV{TMPDIR} or if that is unset, "/t".
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
    return $tmpdir if defined $tmpdir;
    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/t" );
  }
  
  =item file_name_is_absolute
  
  Returns true if there's a colon in the file name,
  or if it begins with a slash.
  
  =cut
  
  sub file_name_is_absolute {
    my ($self, $file) = @_;
  
    # Not 100% robust as a "/" must not preceded a ":"
    # but this cannot happen in a well formed path.
    return $file =~ m{^/|:}s;
  }
  
  =back
  
  All the other methods are from L<File::Spec::Unix>.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_AMIGAOS

$fatpacked{"darwin-2level/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir(
          $_[0]->_tmpdir(
              $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp'
          ),
          qw 'TMPDIR TMP TEMP'
      );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_CYGWIN

$fatpacked{"darwin-2level/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there.  This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still a work in progress. ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path.  On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_EPOC

$fatpacked{"darwin-2level/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  require File::Spec::Unix;
  my %udeps = (
      canonpath => [],
      catdir => [qw(canonpath)],
      catfile => [qw(canonpath catdir)],
      case_tolerant => [],
      curdir => [],
      devnull => [],
      rootdir => [],
      updir => [],
  );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&
  	    !(grep {
  		File::Spec->can($_) != File::Spec::Unix->can($_)
  	    } @{$udeps{$meth}}) &&
  	    defined(&{"File::Spec::Unix::_fn_$meth"})) {
  	*{$meth} = \&{"File::Spec::Unix::_fn_$meth"};
      } else {
  	*{$meth} = sub {&$sub('File::Spec', @_)};
      }
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS

$fatpacked{"darwin-2level/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR} ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_MAC

$fatpacked{"darwin-2level/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');
      return $cached if defined $cached;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $_[0]->_cache_tmpdir(
  	$_[0]->_tmpdir( @d, '/tmp', '/' ), qw 'TMPDIR TEMP TMP'
      );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC_OS2

$fatpacked{"darwin-2level/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  #dont try to load XSLoader and DynaLoader only to ultimately fail on miniperl
  if(!defined &canonpath && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
  	require XSLoader;
  	XSLoader::load("Cwd", $xs_version);
      } else {
  	require Cwd;
      }
    };
  }
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub _pp_canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  *canonpath = \&_pp_canonpath unless defined &canonpath;
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub _pp_catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  *catdir = \&_pp_catdir unless defined &catdir;
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub _pp_catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  *catfile = \&_pp_catfile unless defined &catfile;
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  use constant _fn_curdir => ".";
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  use constant _fn_devnull => "/dev/null";
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  use constant _fn_rootdir => "/";
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my ($tmpdir, %tmpenv);
  # Cache and return the calculated tmpdir, recording which env vars
  # determined it.
  sub _cache_tmpdir {
      @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};
      return $tmpdir = $_[1];
  }
  # Retrieve the cached tmpdir, checking first whether relevant env vars have
  # changed and invalidated the cache.
  sub _cached_tmpdir {
      shift;
      local $^W;
      return if grep $ENV{$_} ne $tmpenv{$_}, @_;
      return $tmpdir;
  }
  sub _tmpdir {
      my $self = shift;
      my @dirlist = @_;
      my $taint = do { no strict 'refs'; ${"\cTAINT"} };
      if ($taint) { # Check for taint mode on perl >= 5.8.0
  	require Scalar::Util;
  	@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
      }
      elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	@dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;
      }
      
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      if ( !$self->file_name_is_absolute($tmpdir) ) {
          # See [perl #120593] for the full details
          # If possible, return a full path, rather than '.' or 'lib', but
          # jump through some hoops to avoid returning a tainted value.
          ($tmpdir) = grep {
              $taint     ? ! Scalar::Util::tainted($_) :
              $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1
          } $self->rel2abs($tmpdir), $tmpdir;
      }
      return $tmpdir;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  use constant _fn_updir => "..";
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  use constant _fn_case_tolerant => 0;
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
  	my ($path_volume) = $self->splitpath($path, 1);
  	my ($base_volume) = $self->splitpath($base, 1);
  
  	# Can't relativize across volumes
  	return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
  	# For UNC paths, the user might give a volume like //foo/bar that
  	# strictly speaking has no directory portion.  Treat it as if it
  	# had the root directory for that volume.
  	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
  	    $base_directories = $self->rootdir;
  	}
      }
      else {
  	my $wd= ($self->splitpath($self->_cwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
DARWIN-2LEVEL_FILE_SPEC_UNIX

$fatpacked{"darwin-2level/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicitly requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
  	}
  
  	$rslt = vmspath( unixify($spath) . '/' . unixify($sdir));
  
  	# Special case for VMS absolute directory specs: these will have
  	# had device prepended during trip through Unix syntax in
  	# eliminate_macros(), since Unix syntax has no way to express
  	# "absolute from the top of this device's directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
      } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
  	} else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
             $rslt = unixify($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $xfile : vmsify($xfile);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  sub tmpdir {
      my $self = shift @_;
      my $tmpdir = $self->_cached_tmpdir('TMPDIR');
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
      }
      else {
          $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
      }
      $self->_cache_tmpdir($tmpdir, 'TMPDIR');
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/);
  }
  
  =item splitpath (override)
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
          $dir = vmspath($dir);
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      return vmspath(File::Spec::Unix::abs2rel( $self, @_ ))
          if ((grep m{/}, @_) && !(grep m{(?<!\^)[\[<:]}, @_));
  
      my($path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      # If there is no device or directory syntax on $base, make sure it
      # is treated as a directory.
      $base = VMS::Filespec::vmspath($base) unless $base =~ m{(?<!\^)[\[<:]};
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
         $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                    ? vmspath($path)             # whether it's a directory
                    : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-14 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_VMS

$fatpacked{"darwin-2level/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $tmpdir = $_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
      $_[0]->_cache_tmpdir($tmpdir, qw(TMPDIR TEMP TMP));
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
DARWIN-2LEVEL_FILE_SPEC_WIN32

$fatpacked{"darwin-2level/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.47";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of the all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
DARWIN-2LEVEL_LIST_UTIL

$fatpacked{"darwin-2level/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.47";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_LIST_UTIL_XS

$fatpacked{"darwin-2level/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.47";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_SCALAR_UTIL

$fatpacked{"darwin-2level/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.47";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
DARWIN-2LEVEL_SUB_UTIL

$fatpacked{"darwin-2level/encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_ENCODING';
  # $Id: encoding.pm,v 2.19 2016/11/01 13:30:38 dankogai Exp $
  package encoding;
  our $VERSION = sprintf "%d.%02d", q$Revision: 2.19 $ =~ /(\d+)/g;
  
  use Encode;
  use strict;
  use warnings;
  
  use constant {
      DEBUG => !!$ENV{PERL_ENCODE_DEBUG},
      HAS_PERLIO => eval { require PerlIO::encoding; PerlIO::encoding->VERSION(0.02) },
      PERL_5_21_7 => $^V && $^V ge v5.21.7,
  };
  
  sub _exception {
      my $name = shift;
      $] > 5.008 and return 0;    # 5.8.1 or higher then no
      my %utfs = map { $_ => 1 }
        qw(utf8 UCS-2BE UCS-2LE UTF-16 UTF-16BE UTF-16LE
        UTF-32 UTF-32BE UTF-32LE);
      $utfs{$name} or return 0;    # UTFs or no
      require Config;
      Config->import();
      our %Config;
      return $Config{perl_patchlevel} ? 0 : 1    # maintperl then no
  }
  
  sub in_locale { $^H & ( $locale::hint_bits || 0 ) }
  
  sub _get_locale_encoding {
      my $locale_encoding;
  
      if ($^O eq 'MSWin32') {
          my @tries = (
              # First try to get the OutputCP. This will work only if we
              # are attached to a console
              'Win32.pm' => 'Win32::GetConsoleOutputCP',
              'Win32/Console.pm' => 'Win32::Console::OutputCP',
              # If above failed, this means that we are a GUI app
              # Let's assume that the ANSI codepage is what matters
              'Win32.pm' => 'Win32::GetACP',
          );
          while (@tries) {
              my $cp = eval {
                  require $tries[0];
                  no strict 'refs';
                  &{$tries[1]}()
              };
              if ($cp) {
                  if ($cp == 65001) { # Code page for UTF-8
                      $locale_encoding = 'UTF-8';
                  } else {
                      $locale_encoding = 'cp' . $cp;
                  }
                  return $locale_encoding;
              }
              splice(@tries, 0, 2)
          }
      }
  
      # I18N::Langinfo isn't available everywhere
      $locale_encoding = eval {
          require I18N::Langinfo;
          find_encoding(
              I18N::Langinfo::langinfo( I18N::Langinfo::CODESET() )
          )->name
      };
      return $locale_encoding if defined $locale_encoding;
  
      eval {
          require POSIX;
          # Get the current locale
          # Remember that MSVCRT impl is quite different from Unixes
          my $locale = POSIX::setlocale(POSIX::LC_CTYPE());
          if ( $locale =~ /^([^.]+)\.([^.@]+)(?:@.*)?$/ ) {
              my $country_language;
              ( $country_language, $locale_encoding ) = ( $1, $2 );
  
              # Could do more heuristics based on the country and language
              # since we have Locale::Country and Locale::Language available.
              # TODO: get a database of Language -> Encoding mappings
              # (the Estonian database at http://www.eki.ee/letter/
              # would be excellent!) --jhi
              if (lc($locale_encoding) eq 'euc') {
                  if ( $country_language =~ /^ja_JP|japan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-jp';
                  }
                  elsif ( $country_language =~ /^ko_KR|korean?$/i ) {
                      $locale_encoding = 'euc-kr';
                  }
                  elsif ( $country_language =~ /^zh_CN|chin(?:a|ese)$/i ) {
                      $locale_encoding = 'euc-cn';
                  }
                  elsif ( $country_language =~ /^zh_TW|taiwan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-tw';
                  }
                  else {
                      require Carp;
                      Carp::croak(
                          "encoding: Locale encoding '$locale_encoding' too ambiguous"
                      );
                  }
              }
          }
      };
  
      return $locale_encoding;
  }
  
  sub import {
  
      if ( ord("A") == 193 ) {
          require Carp;
          Carp::croak("encoding: pragma does not support EBCDIC platforms");
      }
  
      my $deprecate =
          $] >= 5.017 ? "Use of the encoding pragma is deprecated" : 0;
  
      my $class = shift;
      my $name  = shift;
      if (!$name){
  	require Carp;
          Carp::croak("encoding: no encoding specified.");
      }
      if ( $name eq ':_get_locale_encoding' ) {    # used by lib/open.pm
          my $caller = caller();
          {
              no strict 'refs';
              *{"${caller}::_get_locale_encoding"} = \&_get_locale_encoding;
          }
          return;
      }
      $name = _get_locale_encoding() if $name eq ':locale';
      my %arg = @_;
      $name = $ENV{PERL_ENCODING} unless defined $name;
      my $enc = find_encoding($name);
      unless ( defined $enc ) {
          require Carp;
          Carp::croak("encoding: Unknown encoding '$name'");
      }
      $name = $enc->name;    # canonize
      unless ( $arg{Filter} ) {
          if ($] >= 5.025003) {
              require Carp;
              Carp::croak("The encoding pragma is no longer supported");
          }
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          DEBUG and warn "_exception($name) = ", _exception($name);
          if (! _exception($name)) {
              if (!PERL_5_21_7) {
                  ${^ENCODING} = $enc;
              }
              else {
                  # Starting with 5.21.7, this pragma uses a shadow variable
                  # designed explicitly for it, ${^E_NCODING}, to enforce
                  # lexical scope; instead of ${^ENCODING}.
                  $^H{'encoding'} = 1;
                  ${^E_NCODING} = $enc;
              }
          }
          if (! HAS_PERLIO ) {
              return 1;
          }
      }
      else {
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          defined( ${^ENCODING} ) and undef ${^ENCODING};
          undef ${^E_NCODING} if PERL_5_21_7;
  
          # implicitly 'use utf8'
          require utf8;      # to fetch $utf8::hint_bits;
          $^H |= $utf8::hint_bits;
          eval {
              require Filter::Util::Call;
              Filter::Util::Call->import;
              filter_add(
                  sub {
                      my $status = filter_read();
                      if ( $status > 0 ) {
                          $_ = $enc->decode( $_, 1 );
                          DEBUG and warn $_;
                      }
                      $status;
                  }
              );
          };
          $@ eq '' and DEBUG and warn "Filter installed";
      }
      defined ${^UNICODE} and ${^UNICODE} != 0 and return 1;
      for my $h (qw(STDIN STDOUT)) {
          if ( $arg{$h} ) {
              unless ( defined find_encoding( $arg{$h} ) ) {
                  require Carp;
                  Carp::croak(
                      "encoding: Unknown encoding for $h, '$arg{$h}'");
              }
              eval { binmode( $h, ":raw :encoding($arg{$h})" ) };
          }
          else {
              unless ( exists $arg{$h} ) {
                  eval {
                      no warnings 'uninitialized';
                      binmode( $h, ":raw :encoding($name)" );
                  };
              }
          }
          if ($@) {
              require Carp;
              Carp::croak($@);
          }
      }
      return 1;    # I doubt if we need it, though
  }
  
  sub unimport {
      no warnings;
      undef ${^ENCODING};
      undef ${^E_NCODING} if PERL_5_21_7;
      if (HAS_PERLIO) {
          binmode( STDIN,  ":raw" );
          binmode( STDOUT, ":raw" );
      }
      else {
          binmode(STDIN);
          binmode(STDOUT);
      }
      if ( $INC{"Filter/Util/Call.pm"} ) {
          eval { filter_del() };
      }
  }
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  encoding - allows you to write your script in non-ASCII and non-UTF-8
  
  =head1 WARNING
  
  This module has been deprecated since perl v5.18.  See L</DESCRIPTION> and
  L</BUGS>.
  
  =head1 SYNOPSIS
  
    use encoding "greek";  # Perl like Greek to you?
    use encoding "euc-jp"; # Jperl!
  
    # or you can even do this if your shell supports your native encoding
  
    perl -Mencoding=latin2 -e'...' # Feeling centrally European?
    perl -Mencoding=euc-kr -e'...' # Or Korean?
  
    # more control
  
    # A simple euc-cn => utf-8 converter
    use encoding "euc-cn", STDOUT => "utf8";  while(<>){print};
  
    # "no encoding;" supported
    no encoding;
  
    # an alternate way, Filter
    use encoding "euc-jp", Filter=>1;
    # now you can use kanji identifiers -- in euc-jp!
  
    # encode based on the current locale - specialized purposes only;
    # fraught with danger!!
    use encoding ':locale';
  
  =head1 DESCRIPTION
  
  This pragma is used to enable a Perl script to be written in encodings that
  aren't strictly ASCII nor UTF-8.  It translates all or portions of the Perl
  program script from a given encoding into UTF-8, and changes the PerlIO layers
  of C<STDIN> and C<STDOUT> to the encoding specified.
  
  This pragma dates from the days when UTF-8-enabled editors were uncommon.  But
  that was long ago, and the need for it is greatly diminished.  That, coupled
  with the fact that it doesn't work with threads, along with other problems,
  (see L</BUGS>) have led to its being deprecated.  It is planned to remove this
  pragma in a future Perl version.  New code should be written in UTF-8, and the
  C<use utf8> pragma used instead (see L<perluniintro> and L<utf8> for details).
  Old code should be converted to UTF-8, via something like the recipe in the
  L</SYNOPSIS> (though this simple approach may require manual adjustments
  afterwards).
  
  If UTF-8 is not an option, it is recommended that one use a simple source
  filter, such as that provided by L<Filter::Encoding> on CPAN or this
  pragma's own C<Filter> option (see below).
  
  The only legitimate use of this pragma is almost certainly just one per file,
  near the top, with file scope, as the file is likely going to only be written
  in one encoding.  Further restrictions apply in Perls before v5.22 (see
  L</Prior to Perl v5.22>).
  
  There are two basic modes of operation (plus turning if off):
  
  =over 4
  
  =item C<use encoding ['I<ENCNAME>'] ;>
  
  Please note: This mode of operation is no longer supported as of Perl
  v5.26.
  
  This is the normal operation.  It translates various literals encountered in
  the Perl source file from the encoding I<ENCNAME> into UTF-8, and similarly
  converts character code points.  This is used when the script is a combination
  of ASCII (for the variable names and punctuation, I<etc>), but the literal
  data is in the specified encoding.
  
  I<ENCNAME> is optional.  If omitted, the encoding specified in the environment
  variable L<C<PERL_ENCODING>|perlrun/PERL_ENCODING> is used.  If this isn't
  set, or the resolved-to encoding is not known to C<L<Encode>>, the error
  C<Unknown encoding 'I<ENCNAME>'> will be thrown.
  
  Starting in Perl v5.8.6 (C<Encode> version 2.0.1), I<ENCNAME> may be the
  name C<:locale>.  This is for very specialized applications, and is documented
  in L</The C<:locale> sub-pragma> below.
  
  The literals that are converted are C<q//, qq//, qr//, qw///, qx//>, and
  starting in v5.8.1, C<tr///>.  Operations that do conversions include C<chr>,
  C<ord>, C<utf8::upgrade> (but not C<utf8::downgrade>), and C<chomp>.
  
  Also starting in v5.8.1, the C<DATA> pseudo-filehandle is translated from the
  encoding into UTF-8.
  
  For example, you can write code in EUC-JP as follows:
  
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
                 #<-char-><-char->   # 4 octets
    s/\bCamel\b/$Rakuda/;
  
  And with C<use encoding "euc-jp"> in effect, it is the same thing as
  that code in UTF-8:
  
    my $Rakuda = "\x{99F1}\x{99DD}"; # two Unicode Characters
    s/\bCamel\b/$Rakuda/;
  
  See L</EXAMPLE> below for a more complete example.
  
  Unless C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero, the
  PerlIO layers of C<STDIN> and C<STDOUT> are set to "C<:encoding(I<ENCNAME>)>".
  Therefore,
  
    use encoding "euc-jp";
    my $message = "Camel is the symbol of perl.\n";
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
    $message =~ s/\bCamel\b/$Rakuda/;
    print $message;
  
  will print
  
   "\xF1\xD1\xF1\xCC is the symbol of perl.\n"
  
  not
  
   "\x{99F1}\x{99DD} is the symbol of perl.\n"
  
  You can override this by giving extra arguments; see below.
  
  Note that C<STDERR> WILL NOT be changed, regardless.
  
  Also note that non-STD file handles remain unaffected.  Use C<use
  open> or C<binmode> to change the layers of those.
  
  =item C<use encoding I<ENCNAME> Filter=E<gt>1;>
  
  This operates as above, but the C<Filter> argument with a non-zero
  value causes the entire script, and not just literals, to be translated from
  the encoding into UTF-8.  This allows identifiers in the source to be in that
  encoding as well.  (Problems may occur if the encoding is not a superset of
  ASCII; imagine all your semi-colons being translated into something
  different.)  One can use this form to make
  
   ${"\x{4eba}"}++
  
  work.  (This is equivalent to C<$I<human>++>, where I<human> is a single Han
  ideograph).
  
  This effectively means that your source code behaves as if it were written in
  UTF-8 with C<'use utf8>' in effect.  So even if your editor only supports
  Shift_JIS, for example, you can still try examples in Chapter 15 of
  C<Programming Perl, 3rd Ed.>.
  
  This option is significantly slower than the other one.
  
  =item C<no encoding;>
  
  Unsets the script encoding. The layers of C<STDIN>, C<STDOUT> are
  reset to "C<:raw>" (the default unprocessed raw stream of bytes).
  
  =back
  
  =head1 OPTIONS
  
  =head2 Setting C<STDIN> and/or C<STDOUT> individually
  
  The encodings of C<STDIN> and C<STDOUT> are individually settable by parameters to
  the pragma:
  
   use encoding 'euc-tw', STDIN => 'greek'  ...;
  
  In this case, you cannot omit the first I<ENCNAME>.  C<< STDIN => undef >>
  turns the I/O transcoding completely off for that filehandle.
  
  When C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero,
  these options will be completely ignored.  See L<perlvar/C<${^UNICODE}>> and
  L<"C<-C>" in perlrun|perlrun/-C [numberE<sol>list]> for details.
  
  =head2 The C<:locale> sub-pragma
  
  Starting in v5.8.6, the encoding name may be C<:locale>.  This means that the
  encoding is taken from the current locale, and not hard-coded by the pragma.
  Since a script really can only be encoded in exactly one encoding, this option
  is dangerous.  It makes sense only if the script itself is written in ASCII,
  and all the possible locales that will be in use when the script is executed
  are supersets of ASCII.  That means that the script itself doesn't get
  changed, but the I/O handles have the specified encoding added, and the
  operations like C<chr> and C<ord> use that encoding.
  
  The logic of finding which locale C<:locale> uses is as follows:
  
  =over 4
  
  =item 1.
  
  If the platform supports the C<langinfo(CODESET)> interface, the codeset
  returned is used as the default encoding for the open pragma.
  
  =item 2.
  
  If 1. didn't work but we are under the locale pragma, the environment
  variables C<LC_ALL> and C<LANG> (in that order) are matched for encodings
  (the part after "C<.>", if any), and if any found, that is used
  as the default encoding for the open pragma.
  
  =item 3.
  
  If 1. and 2. didn't work, the environment variables C<LC_ALL> and C<LANG>
  (in that order) are matched for anything looking like UTF-8, and if
  any found, C<:utf8> is used as the default encoding for the open
  pragma.
  
  =back
  
  If your locale environment variables (C<LC_ALL>, C<LC_CTYPE>, C<LANG>)
  contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching),
  the default encoding of your C<STDIN>, C<STDOUT>, and C<STDERR>, and of
  B<any subsequent file open>, is UTF-8.
  
  =head1 CAVEATS
  
  =head2 SIDE EFFECTS
  
  =over
  
  =item *
  
  If the C<encoding> pragma is in scope then the lengths returned are
  calculated from the length of C<$/> in Unicode characters, which is not
  always the same as the length of C<$/> in the native encoding.
  
  =item *
  
  Without this pragma, if strings operating under byte semantics and strings
  with Unicode character data are concatenated, the new string will
  be created by decoding the byte strings as I<ISO 8859-1 (Latin-1)>.
  
  The B<encoding> pragma changes this to use the specified encoding
  instead.  For example:
  
      use encoding 'utf8';
      my $string = chr(20000); # a Unicode string
      utf8::encode($string);   # now it's a UTF-8 encoded byte string
      # concatenate with another Unicode string
      print length($string . chr(20000));
  
  Will print C<2>, because C<$string> is upgraded as UTF-8.  Without
  C<use encoding 'utf8';>, it will print C<4> instead, since C<$string>
  is three octets when interpreted as Latin-1.
  
  =back
  
  =head2 DO NOT MIX MULTIPLE ENCODINGS
  
  Notice that only literals (string or regular expression) having only
  legacy code points are affected: if you mix data like this
  
      \x{100}\xDF
      \xDF\x{100}
  
  the data is assumed to be in (Latin 1 and) Unicode, not in your native
  encoding.  In other words, this will match in "greek":
  
      "\xDF" =~ /\x{3af}/
  
  but this will not
  
      "\xDF\x{100}" =~ /\x{3af}\x{100}/
  
  since the C<\xDF> (ISO 8859-7 GREEK SMALL LETTER IOTA WITH TONOS) on
  the left will B<not> be upgraded to C<\x{3af}> (Unicode GREEK SMALL
  LETTER IOTA WITH TONOS) because of the C<\x{100}> on the left.  You
  should not be mixing your legacy data and Unicode in the same string.
  
  This pragma also affects encoding of the 0x80..0xFF code point range:
  normally characters in that range are left as eight-bit bytes (unless
  they are combined with characters with code points 0x100 or larger,
  in which case all characters need to become UTF-8 encoded), but if
  the C<encoding> pragma is present, even the 0x80..0xFF range always
  gets UTF-8 encoded.
  
  After all, the best thing about this pragma is that you don't have to
  resort to \x{....} just to spell your name in a native encoding.
  So feel free to put your strings in your encoding in quotes and
  regexes.
  
  =head2 Prior to Perl v5.22
  
  The pragma was a per script, not a per block lexical.  Only the last
  C<use encoding> or C<no encoding> mattered, and it affected
  B<the whole script>.  However, the C<no encoding> pragma was supported and
  C<use encoding> could appear as many times as you want in a given script
  (though only the last was effective).
  
  Since the scope wasn't lexical, other modules' use of C<chr>, C<ord>, I<etc.>
  were affected.  This leads to spooky, incorrect action at a distance that is
  hard to debug.
  
  This means you would have to be very careful of the load order:
  
    # called module
    package Module_IN_BAR;
    use encoding "bar";
    # stuff in "bar" encoding here
    1;
  
    # caller script
    use encoding "foo"
    use Module_IN_BAR;
    # surprise! use encoding "bar" is in effect.
  
  The best way to avoid this oddity is to use this pragma RIGHT AFTER
  other modules are loaded.  i.e.
  
    use Module_IN_BAR;
    use encoding "foo";
  
  =head2 Prior to Encode version 1.87
  
  =over
  
  =item *
  
  C<STDIN> and C<STDOUT> were not set under the filter option.
  And C<< STDIN=>I<ENCODING> >> and C<< STDOUT=>I<ENCODING> >> didn't work like
  non-filter version.
  
  =item *
  
  C<use utf8> wasn't implicitly declared so you have to C<use utf8> to do
  
   ${"\x{4eba}"}++
  
  =back
  
  =head2 Prior to Perl v5.8.1
  
  =over
  
  =item "NON-EUC" doublebyte encodings
  
  Because perl needs to parse the script before applying this pragma, such
  encodings as Shift_JIS and Big-5 that may contain C<'\'> (BACKSLASH;
  C<\x5c>) in the second byte fail because the second byte may
  accidentally escape the quoting character that follows.
  
  =item C<tr///>
  
  The B<encoding> pragma works by decoding string literals in
  C<q//,qq//,qr//,qw///, qx//> and so forth.  In perl v5.8.0, this
  does not apply to C<tr///>.  Therefore,
  
    use encoding 'euc-jp';
    #....
    $kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/;
    #           -------- -------- -------- --------
  
  Does not work as
  
    $kana =~ tr/\x{3041}-\x{3093}/\x{30a1}-\x{30f3}/;
  
  =over
  
  =item Legend of characters above
  
    utf8     euc-jp   charnames::viacode()
    -----------------------------------------
    \x{3041} \xA4\xA1 HIRAGANA LETTER SMALL A
    \x{3093} \xA4\xF3 HIRAGANA LETTER N
    \x{30a1} \xA5\xA1 KATAKANA LETTER SMALL A
    \x{30f3} \xA5\xF3 KATAKANA LETTER N
  
  =back
  
  This counterintuitive behavior has been fixed in perl v5.8.1.
  
  In perl v5.8.0, you can work around this as follows;
  
    use encoding 'euc-jp';
    #  ....
    eval qq{ \$kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/ };
  
  Note the C<tr//> expression is surrounded by C<qq{}>.  The idea behind
  this is the same as the classic idiom that makes C<tr///> 'interpolate':
  
     tr/$from/$to/;            # wrong!
     eval qq{ tr/$from/$to/ }; # workaround.
  
  =back
  
  =head1 EXAMPLE - Greekperl
  
      use encoding "iso 8859-7";
  
      # \xDF in ISO 8859-7 (Greek) is \x{3af} in Unicode.
  
      $a = "\xDF";
      $b = "\x{100}";
  
      printf "%#x\n", ord($a); # will print 0x3af, not 0xdf
  
      $c = $a . $b;
  
      # $c will be "\x{3af}\x{100}", not "\x{df}\x{100}".
  
      # chr() is affected, and ...
  
      print "mega\n"  if ord(chr(0xdf)) == 0x3af;
  
      # ... ord() is affected by the encoding pragma ...
  
      print "tera\n" if ord(pack("C", 0xdf)) == 0x3af;
  
      # ... as are eq and cmp ...
  
      print "peta\n" if "\x{3af}" eq  pack("C", 0xdf);
      print "exa\n"  if "\x{3af}" cmp pack("C", 0xdf) == 0;
  
      # ... but pack/unpack C are not affected, in case you still
      # want to go back to your native encoding
  
      print "zetta\n" if unpack("C", (pack("C", 0xdf))) == 0xdf;
  
  =head1 BUGS
  
  =over
  
  =item Thread safety
  
  C<use encoding ...> is not thread-safe (i.e., do not use in threaded
  applications).
  
  =item Can't be used by more than one module in a single program.
  
  Only one encoding is allowed.  If you combine modules in a program that have
  different encodings, only one will be actually used.
  
  =item Other modules using C<STDIN> and C<STDOUT> get the encoded stream
  
  They may be expecting something completely different.
  
  =item literals in regex that are longer than 127 bytes
  
  For native multibyte encodings (either fixed or variable length),
  the current implementation of the regular expressions may introduce
  recoding errors for regular expression literals longer than 127 bytes.
  
  =item EBCDIC
  
  The encoding pragma is not supported on EBCDIC platforms.
  
  =item C<format>
  
  This pragma doesn't work well with C<format> because PerlIO does not
  get along very well with it.  When C<format> contains non-ASCII
  characters it prints funny or gets "wide character warnings".
  To understand it, try the code below.
  
    # Save this one in utf8
    # replace *non-ascii* with a non-ascii string
    my $camel;
    format STDOUT =
    *non-ascii*@>>>>>>>
    $camel
    .
    $camel = "*non-ascii*";
    binmode(STDOUT=>':encoding(utf8)'); # bang!
    write;              # funny
    print $camel, "\n"; # fine
  
  Without binmode this happens to work but without binmode, print()
  fails instead of write().
  
  At any rate, the very use of C<format> is questionable when it comes to
  unicode characters since you have to consider such things as character
  width (i.e. double-width for ideographs) and directions (i.e. BIDI for
  Arabic and Hebrew).
  
  =item See also L</CAVEATS>
  
  =back
  
  =head1 HISTORY
  
  This pragma first appeared in Perl v5.8.0.  It has been enhanced in later
  releases as specified above.
  
  =head1 SEE ALSO
  
  L<perlunicode>, L<Encode>, L<open>, L<Filter::Util::Call>,
  
  Ch. 15 of C<Programming Perl (3rd Edition)>
  by Larry Wall, Tom Christiansen, Jon Orwant;
  O'Reilly & Associates; ISBN 0-596-00027-8
  
  =cut
DARWIN-2LEVEL_ENCODING

$fatpacked{"fields.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FIELDS';
  use 5.008;
  package fields;
  
  require 5.005;
  use strict;
  no strict 'refs';
  unless( eval q{require warnings::register; warnings::register->import; 1} ) {
      *warnings::warnif = sub { 
          require Carp;
          Carp::carp(@_);
      }
  }
  use vars qw(%attr $VERSION);
  
  $VERSION = '2.23';
  $VERSION =~ tr/_//d;
  
  # constant.pm is slow
  sub PUBLIC     () { 2**0  }
  sub PRIVATE    () { 2**1  }
  sub INHERITED  () { 2**2  }
  sub PROTECTED  () { 2**3  }
  
  
  # The %attr hash holds the attributes of the currently assigned fields
  # per class.  The hash is indexed by class names and the hash value is
  # an array reference.  The first element in the array is the lowest field
  # number not belonging to a base class.  The remaining elements' indices
  # are the field numbers.  The values are integer bit masks, or undef
  # in the case of base class private fields (which occupy a slot but are
  # otherwise irrelevant to the class).
  
  sub import {
      my $class = shift;
      return unless @_;
      my $package = caller(0);
      # avoid possible typo warnings
      %{"$package\::FIELDS"} = () unless %{"$package\::FIELDS"};
      my $fields = \%{"$package\::FIELDS"};
      my $fattr = ($attr{$package} ||= [1]);
      my $next = @$fattr;
  
      # Quiet pseudo-hash deprecation warning for uses of fields::new.
      bless \%{"$package\::FIELDS"}, 'pseudohash';
  
      if ($next > $fattr->[0]
          and ($fields->{$_[0]} || 0) >= $fattr->[0])
      {
          # There are already fields not belonging to base classes.
          # Looks like a possible module reload...
          $next = $fattr->[0];
      }
      foreach my $f (@_) {
          my $fno = $fields->{$f};
  
          # Allow the module to be reloaded so long as field positions
          # have not changed.
          if ($fno and $fno != $next) {
              require Carp;
              if ($fno < $fattr->[0]) {
                if ($] < 5.006001) {
                  warn("Hides field '$f' in base class") if $^W;
                } else {
                  warnings::warnif("Hides field '$f' in base class") ;
                }
              } else {
                  Carp::croak("Field name '$f' already in use");
              }
          }
          $fields->{$f} = $next;
          $fattr->[$next] = ($f =~ /^_/) ? PRIVATE : PUBLIC;
          $next += 1;
      }
      if (@$fattr > $next) {
          # Well, we gave them the benefit of the doubt by guessing the
          # module was reloaded, but they appear to be declaring fields
          # in more than one place.  We can't be sure (without some extra
          # bookkeeping) that the rest of the fields will be declared or
          # have the same positions, so punt.
          require Carp;
          Carp::croak ("Reloaded module must declare all fields at once");
      }
  }
  
  sub inherit {
      require base;
      goto &base::inherit_fields;
  }
  
  sub _dump  # sometimes useful for debugging
  {
      for my $pkg (sort keys %attr) {
          print "\n$pkg";
          if (@{"$pkg\::ISA"}) {
              print " (", join(", ", @{"$pkg\::ISA"}), ")";
          }
          print "\n";
          my $fields = \%{"$pkg\::FIELDS"};
          for my $f (sort {$fields->{$a} <=> $fields->{$b}} keys %$fields) {
              my $no = $fields->{$f};
              print "   $no: $f";
              my $fattr = $attr{$pkg}[$no];
              if (defined $fattr) {
                  my @a;
                  push(@a, "public")    if $fattr & PUBLIC;
                  push(@a, "private")   if $fattr & PRIVATE;
                  push(@a, "inherited") if $fattr & INHERITED;
                  print "\t(", join(", ", @a), ")";
              }
              print "\n";
          }
      }
  }
  
  if ($] < 5.009) {
    *new = sub {
      my $class = shift;
      $class = ref $class if ref $class;
      return bless [\%{$class . "::FIELDS"}], $class;
    }
  } else {
    *new = sub {
      my $class = shift;
      $class = ref $class if ref $class;
      require Hash::Util;
      my $self = bless {}, $class;
  
      # The lock_keys() prototype won't work since we require Hash::Util :(
      &Hash::Util::lock_keys(\%$self, _accessible_keys($class));
      return $self;
    }
  }
  
  sub _accessible_keys {
      my ($class) = @_;
      return (
          keys %{$class.'::FIELDS'},
          map(_accessible_keys($_), @{$class.'::ISA'}),
      );
  }
  
  sub phash {
      die "Pseudo-hashes have been removed from Perl" if $] >= 5.009;
      my $h;
      my $v;
      if (@_) {
         if (ref $_[0] eq 'ARRAY') {
             my $a = shift;
             @$h{@$a} = 1 .. @$a;
             if (@_) {
                 $v = shift;
                 unless (! @_ and ref $v eq 'ARRAY') {
                     require Carp;
                     Carp::croak ("Expected at most two array refs\n");
                 }
             }
         }
         else {
             if (@_ % 2) {
                 require Carp;
                 Carp::croak ("Odd number of elements initializing pseudo-hash\n");
             }
             my $i = 0;
             @$h{grep ++$i % 2, @_} = 1 .. @_ / 2;
             $i = 0;
             $v = [grep $i++ % 2, @_];
         }
      }
      else {
         $h = {};
         $v = [];
      }
      [ $h, @$v ];
  
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  fields - compile-time class fields
  
  =head1 SYNOPSIS
  
      {
          package Foo;
          use fields qw(foo bar _Foo_private);
          sub new {
              my Foo $self = shift;
              unless (ref $self) {
                  $self = fields::new($self);
                  $self->{_Foo_private} = "this is Foo's secret";
              }
              $self->{foo} = 10;
              $self->{bar} = 20;
              return $self;
          }
      }
  
      my $var = Foo->new;
      $var->{foo} = 42;
  
      # this will generate a run-time error
      $var->{zap} = 42;
  
      # this will generate a compile-time error
      my Foo $foo = Foo->new;
      $foo->{zap} = 24;
  
      # subclassing
      {
          package Bar;
          use base 'Foo';
          use fields qw(baz _Bar_private);        # not shared with Foo
          sub new {
              my $class = shift;
              my $self = fields::new($class);
              $self->SUPER::new();                # init base fields
              $self->{baz} = 10;                  # init own fields
              $self->{_Bar_private} = "this is Bar's secret";
              return $self;
          }
      }
  
  =head1 DESCRIPTION
  
  The C<fields> pragma enables compile-time and run-time verified class
  fields.
  
  NOTE: The current implementation keeps the declared fields in the %FIELDS
  hash of the calling package, but this may change in future versions.
  Do B<not> update the %FIELDS hash directly, because it must be created
  at compile-time for it to be fully useful, as is done by this pragma.
  
  If a typed lexical variable (C<my Class
  $var>) holding a reference is used to access a
  hash element and a package with the same name as the type has
  declared class fields using this pragma, then the hash key is
  verified at compile time.  If the variables are not typed, access is
  only checked at run time.
  
  The related C<base> pragma will combine fields from base classes and any
  fields declared using the C<fields> pragma.  This enables field
  inheritance to work properly.  Inherited fields can be overridden but
  will generate a warning if warnings are enabled.
  
  B<Only valid for Perl 5.8.x and earlier:> Field names that start with an
  underscore character are made private to the class and are not visible
  to subclasses.
  
  Also, B<in Perl 5.8.x and earlier>, this pragma uses pseudo-hashes, the
  effect being that you can have objects with named fields which are as
  compact and as fast arrays to access, as long as the objects are
  accessed through properly typed variables.
  
  The following functions are supported:
  
  =over 4
  
  =item new
  
  fields::new() creates and blesses a hash comprised of the fields declared
  using the C<fields> pragma into the specified class.  It is the
  recommended way to construct a fields-based object.
  
  This makes it possible to write a constructor like this:
  
      package Critter::Sounds;
      use fields qw(cat dog bird);
  
      sub new {
          my $self = shift;
          $self = fields::new($self) unless ref $self;
          $self->{cat} = 'meow';                      # scalar element
          @$self{'dog','bird'} = ('bark','tweet');    # slice
          return $self;
      }
  
  =item phash
  
  B<This function only works in Perl 5.8.x and earlier.>  Pseudo-hashes
  were removed from Perl as of 5.10.  Consider using restricted hashes or
  fields::new() instead (which itself uses restricted hashes under 5.10+).
  See L<Hash::Util>.  Using fields::phash() under 5.10 or higher will
  cause an error.
  
  fields::phash() can be used to create and initialize a plain (unblessed)
  pseudo-hash.  This function should always be used instead of creating
  pseudo-hashes directly.
  
  If the first argument is a reference to an array, the pseudo-hash will
  be created with keys from that array.  If a second argument is supplied,
  it must also be a reference to an array whose elements will be used as
  the values.  If the second array contains less elements than the first,
  the trailing elements of the pseudo-hash will not be initialized.
  This makes it particularly useful for creating a pseudo-hash from
  subroutine arguments:
  
      sub dogtag {
         my $tag = fields::phash([qw(name rank ser_num)], [@_]);
      }
  
  fields::phash() also accepts a list of key-value pairs that will
  be used to construct the pseudo hash.  Examples:
  
      my $tag = fields::phash(name => "Joe",
                              rank => "captain",
                              ser_num => 42);
  
      my $pseudohash = fields::phash(%args);
  
  =back
  
  =head1 SEE ALSO
  
  L<base>, L<Hash::Util>
  
  =cut
FIELDS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use Config::YAML;
use Data::Dumper;
use Encode ();
use FindBin;
use URI::Encode ();


my $config_file = "$FindBin::Bin/mirrorpad.yml";
die "'$config_file' introuvable\n" unless -r $config_file;
my $config = Config::YAML->new(config => $config_file);

my $pad_base = $config->get_apiurl or die "apiurl is missing in config file ?";

my $pad_url = URI::Encode::uri_decode(shift);
warn "PAD_URL=$pad_url";

my $pad_content;
if($pad_url =~ m{\Q$pad_base/group.html}) {
    my $api_key = $config->get_apikey or die "apikey is missing in config file ?";
    $pad_content = get_private_pad($pad_url, $pad_base, $api_key);
    exit 1 if not defined $pad_content;
}
else {
    $pad_content = get_public_pad($pad_url);
}
print $pad_content;

sub get_private_pad {
    require Etherpad;
    my ($pad_url, $api_url, $api_key) = @_;
    my $ep = Etherpad->new(
      url    => $api_url,
      apikey => $api_key,
    );

    my $pad_base = quotemeta $api_url;
    warn "PAD_BASE=$pad_base";
    # Extraction de l'id du pad  partir de l'url du pad
    my $pad_id;
    ($pad_id) = $pad_url =~ m{^$pad_base/.+?/(g\.[^/]+)}o;
    warn "PADID=$pad_id\n";
    if(my($pad_text) = $ep->get_text($pad_id)) {
        $pad_text = Encode::encode('UTF-8', $pad_text);
        return $pad_text;
    }
    else {
        return;
    }
}


sub get_public_pad {
    require LWP::UserAgent;
    my ($pad_url) = @_;
    my $ua = LWP::UserAgent->new;
    my $resp = $ua->get($pad_url);
    if($resp->is_success) {
        return $resp->decoded_content;
    }
    else {
        warn $resp->status_line;
        return
    }
}

